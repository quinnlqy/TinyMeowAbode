<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫咪的家 - 阶段6.5: 修复AI逻辑</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; font-family: 'Microsoft YaHei', sans-serif; }
        canvas { display: block; outline: none; }

        #heart-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px; border-radius: 20px;
            font-size: 18px; color: #e74c3c; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: flex; align-items: center; gap: 10px;
            z-index: 20; user-select: none;
        }

        #debug-btn {
            background: #e74c3c; color: white; border: none;
            padding: 4px 8px; border-radius: 8px; font-size: 12px;
            cursor: pointer; opacity: 0.8; transition: opacity 0.2s;
        }
        #debug-btn:hover { opacity: 1; }

        #shop-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 650px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; overflow: hidden;
            user-select: none; z-index: 10;
        }

        #tabs { display: flex; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; text-align: center; padding: 10px 0; cursor: pointer; font-size: 14px; color: #666; transition: background 0.2s; }
        .tab.active { background: #fff; color: #333; font-weight: bold; border-bottom: 3px solid #ffaa00; }

        #items-scroll {
            display: flex; gap: 12px; padding: 15px; overflow-x: auto; white-space: nowrap;
            scrollbar-width: thin;
        }
        
        .item-btn {
            flex: 0 0 auto; width: 80px; height: 85px;
            border: 2px solid #eee; border-radius: 12px;
            cursor: pointer; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            font-size: 12px; background: #fff; color: #333; transition: all 0.2s;
            position: relative;
        }
        .item-btn:hover { transform: translateY(-3px); border-color: #ffaa00; }
        .item-btn.selected { border-color: #ffaa00; background: #fff8e1; }
        .item-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; border-color: #eee; }
        .item-btn.disabled:hover { transform: none; }

        .color-preview { width: 24px; height: 24px; border-radius: 50%; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.1); }
        .price-tag { margin-top: 4px; font-size: 11px; color: #e74c3c; font-weight: bold; background: #fff0f0; padding: 2px 6px; border-radius: 8px; }

        #tutorial { position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; pointer-events: none; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 14px; line-height: 1.6; z-index: 5; }
        #context-menu { position: absolute; display: none; background: white; padding: 8px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 100; flex-direction: column; gap: 5px; }
        .context-btn { padding: 8px 16px; border: 1px solid #eee; background: #f9f9f9; border-radius: 4px; cursor: pointer; font-size: 12px; text-align: center; }
        .context-btn:hover { background: #eee; }
        .btn-delete { color: red; border-color: #ffcccc; background: #fff0f0; }
        .status-valid { color: green; font-weight: bold; }
        .status-invalid { color: red; font-weight: bold; }
        .heart-float { position: absolute; color: #e74c3c; font-weight: bold; font-size: 20px; pointer-events: none; animation: floatUp 1.5s ease-out forwards; z-index: 30; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
        
        /* 表情气泡 (猫咪被打断时用) */
        .emote-bubble {
            position: absolute; font-size: 24px; pointer-events: none; 
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25;
        }
        @keyframes popUp { 0% { transform: scale(0); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="heart-panel">
        ❤️ <span id="heart-count">50</span>
        <button id="debug-btn" onclick="debugAddMoney()">+100 (Debug)</button>
    </div>

    <div id="tutorial">
        <strong>系统升级: 智能AI</strong><br>
        1. 移动家具会打断猫咪<br>
        2. 删除家具猫咪会重置<br>
        3. 购买新家具丰富家园<br>
        <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;">
            当前状态: <span id="status-text">浏览中</span>
        </div>
    </div>

    <div id="context-menu">
        <div class="context-btn" id="btn-move">移动位置</div>
        <div class="context-btn btn-delete" id="btn-delete">删除家具</div>
        <div class="context-btn" id="btn-cancel">取消选中</div>
    </div>

    <div id="shop-panel">
        <div id="tabs">
            <div class="tab active" onclick="switchCategory('floor')">地面家具</div>
            <div class="tab" onclick="switchCategory('wall')">墙壁装饰</div>
        </div>
        <div id="items-scroll"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let raycaster, pointer, floorPlane;
        
        let mode = 'idle'; 
        let ghostMesh = null; 
        let currentItemData = null; 
        let currentRotation = 0;
        let canPlace = false;
        
        let selectedObject = null; 
        let selectionBox = null; 
        let editingObjectOriginalPos = null;
        let editingObjectOriginalQuat = null;
        
        let longPressTimer = null;
        let startPointer = new THREE.Vector2();
        const obstacles = []; 
        const placedFurniture = []; 
        const cats = []; 
        
        let heartScore = 50; 
        let currentCategory = 'floor';

        // --- 数据库 ---
        const FURNITURE_DB = [
            { id: 'rug',      type: 'floor', name: '地毯',   price: 10, color: 0x3498db, size: {x:2, y:0.1, z:2}, catAction: 'sit' },
            { id: 'bed',      type: 'floor', name: '猫窝',   price: 40, color: 0xe67e22, size: {x:1, y:0.5, z:1}, catAction: 'sleep' },
            { id: 'table',    type: 'floor', name: '小矮桌', price: 60, color: 0x95a5a6, size: {x:1.5, y:0.8, z:1.5}, catAction: 'jump' },
            { id: 'cat_tree', type: 'floor', name: '猫爬架', price: 100, color: 0x8e44ad, size: {x:1, y:2, z:1}, catAction: 'climb' },
            { id: 'sofa',     type: 'floor', name: '大沙发', price: 150, color: 0xe74c3c, size: {x:3, y:1, z:1}, catAction: 'sit' },
            
            { id: 'plant',    type: 'wall',  name: '壁挂藤', price: 20, color: 0x2ecc71, size: {x:0.5, y:1, z:0.2} },
            { id: 'painting', type: 'wall',  name: '风景画', price: 50, color: 0xFFD700, size: {x:1, y:1, z:0.1} },
            { id: 'shelf',    type: 'wall',  name: '墙搁板', price: 40, color: 0x8d6e63, size: {x:1.5, y:0.2, z:0.5} },
            { id: 'win_sm',   type: 'wall',  name: '小窗户', price: 80, color: 0x87CEEB, size: {x:0.8, y:0.8, z:0.2}, light: true },
            { id: 'window',   type: 'wall',  name: '落地窗', price: 120, color: 0x87CEEB, size: {x:1.5, y:2, z:0.2}, light: true }
        ];

        window.debugAddMoney = function() {
            updateMoney(100);
        };

        function updateMoney(amount) {
            heartScore += amount;
            document.getElementById('heart-count').innerText = heartScore;
            refreshShopState();
        }

        function refreshShopState() {
            document.querySelectorAll('.item-btn').forEach(btn => {
                const price = parseInt(btn.dataset.price);
                if (heartScore >= price) btn.classList.remove('disabled');
                else btn.classList.add('disabled');
            });
        }

        // --- 猫咪类 (增强版) ---
        class Cat {
            constructor(scene, color) {
                this.scene = scene;
                this.state = 'idle'; 
                this.targetPos = new THREE.Vector3();
                this.interactTarget = null;
                this.walkSpeed = 2.0;
                this.timer = 0;
                
                this.mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: color });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.6), mat);
                body.position.y = 0.15; this.mesh.add(body);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.3), mat);
                head.position.set(0, 0.4, 0.4); this.mesh.add(head);
                const earL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), mat);
                earL.position.set(-0.1, 0.6, 0.4); earL.rotation.y = -0.2; this.mesh.add(earL);
                const earR = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), mat);
                earR.position.set(0.1, 0.6, 0.4); earR.rotation.y = 0.2; this.mesh.add(earR);
                const tail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), mat);
                tail.position.set(0, 0.3, -0.4); tail.rotation.x = 0.5; this.mesh.add(tail);
                
                this.mesh.traverse(o => { if(o.isMesh) o.castShadow = true; });
                this.scene.add(this.mesh);
                this.chooseNewAction();
            }

            update(dt) {
                // --- 核心修复：实时检查目标有效性 ---
                if (this.interactTarget) {
                    // 检查1: 家具是否已经被移除 (不在 placedFurniture 数组里)
                    // 检查2: 家具是否被隐藏 (正在移动中 visible=false)
                    const isValid = placedFurniture.includes(this.interactTarget) && this.interactTarget.visible === true;
                    
                    if (!isValid) {
                        this.interrupt(); // 触发打断逻辑
                        return; // 本帧不再执行后续逻辑
                    }
                }

                if (this.state === 'walking') {
                    const direction = new THREE.Vector3().subVectors(this.targetPos, this.mesh.position);
                    direction.y = 0; 
                    const dist = direction.length();
                    
                    if (dist < 0.1) {
                        this.mesh.position.x = this.targetPos.x;
                        this.mesh.position.z = this.targetPos.z;
                        if (this.interactTarget) { this.enterInteraction(); } 
                        else { this.state = 'idle'; this.timer = 1 + Math.random() * 2; }
                    } else {
                        direction.normalize();
                        this.mesh.position.add(direction.multiplyScalar(this.walkSpeed * dt));
                        this.mesh.lookAt(this.targetPos.x, this.mesh.position.y, this.targetPos.z);
                        this.mesh.position.y = (this.interactTarget ? this.interactTarget.position.y : 0) + Math.sin(Date.now() * 0.015) * 0.05; 
                    }
                } else if (this.state === 'idle') {
                    this.timer -= dt;
                    if (this.timer <= 0) this.chooseNewAction();
                } else if (this.state === 'interacting') {
                    this.timer -= dt;
                    if (Math.random() < 0.01) spawnHeart(this.mesh.position);
                    if (this.timer <= 0) this.leaveInteraction();
                }
            }

            // 新增：打断逻辑
            interrupt() {
                // 显示一个问号气泡
                showEmote(this.mesh.position, '❓');
                
                // 重置所有状态
                this.state = 'idle';
                this.interactTarget = null;
                this.timer = 1.0; // 愣住 1秒
                
                // 如果猫咪在空中 (家具被抽走了)，掉下来
                this.mesh.position.y = 0;
            }

            chooseNewAction() {
                const validFurniture = placedFurniture.filter(f => f.userData.type === 'floor' && f.visible === true);
                if (validFurniture.length > 0 && Math.random() < 0.7) {
                    const target = validFurniture[Math.floor(Math.random() * validFurniture.length)];
                    this.interactTarget = target;
                    this.targetPos.copy(target.position);
                    this.state = 'walking';
                } else {
                    this.interactTarget = null;
                    this.targetPos.set((Math.random() - 0.5) * 8, 0, (Math.random() - 0.5) * 8);
                    this.state = 'walking';
                }
            }

            enterInteraction() {
                this.state = 'interacting';
                this.timer = 5 + Math.random() * 5; 
                if (this.interactTarget) {
                    const box = new THREE.Box3().setFromObject(this.interactTarget);
                    this.mesh.position.y = box.max.y;
                    this.mesh.rotation.y = Math.random() * Math.PI * 2;
                }
            }

            leaveInteraction() {
                this.state = 'idle'; this.mesh.position.y = 0; this.timer = 0.5;
            }
        }

        function spawnHeart(pos3d) {
            const vec = pos3d.clone(); vec.y += 1.0; vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;

            const el = document.createElement('div');
            el.className = 'heart-float'; el.innerText = '❤ +5';
            el.style.left = x + 'px'; el.style.top = y + 'px';
            document.body.appendChild(el);
            
            updateMoney(5); 
            setTimeout(() => { el.remove(); }, 1500);
        }

        // 显示表情气泡
        function showEmote(pos3d, text) {
            const vec = pos3d.clone(); vec.y += 1.2; vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;

            const el = document.createElement('div');
            el.className = 'emote-bubble'; el.innerText = text;
            el.style.left = x + 'px'; el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => { el.remove(); }, 1000);
        }

        // --- 标准逻辑区域 ---

        window.switchCategory = function(cat) {
            currentCategory = cat;
            document.querySelectorAll('.tab').forEach(e=>e.classList.remove('active'));
            event.target.classList.add('active');
            renderShopItems(cat);
        }

        window.startNewPlacement = function(id) {
            const item = FURNITURE_DB.find(i=>i.id===id);
            if (heartScore < item.price) { alert("爱心不足！去撸猫赚爱心吧！"); return; }
            deselect(); mode = 'placing_new';
            currentItemData = item;
            currentRotation = 0;
            createGhost(currentItemData.color, currentItemData.size);
            updateStatusText("放置: "+currentItemData.name+" (-"+item.price+")");
            document.querySelectorAll('.item-btn').forEach(b=>b.classList.remove('selected'));
        }

        document.getElementById('btn-move').onclick = ()=>{ if(selectedObject) startMovingOld(selectedObject); hideContextMenu(); }
        document.getElementById('btn-delete').onclick = ()=>{ if(selectedObject) deleteSelected(); hideContextMenu(); }
        document.getElementById('btn-cancel').onclick = ()=>{ deselect(); hideContextMenu(); }

        function renderShopItems(cat) {
            const c = document.getElementById('items-scroll'); c.innerHTML='';
            FURNITURE_DB.filter(i=>i.type===cat).forEach(item=>{
                const b = document.createElement('div'); b.className='item-btn';
                b.dataset.price = item.price;
                b.onclick=(e)=>{ 
                    e.stopPropagation(); 
                    if(!b.classList.contains('disabled')) {
                        startNewPlacement(item.id); 
                        document.querySelectorAll('.item-btn').forEach(x=>x.classList.remove('selected')); 
                        b.classList.add('selected'); 
                    }
                };
                const col = document.createElement('div'); col.className='color-preview';
                col.style.background='#'+item.color.toString(16).padStart(6,'0');
                const t = document.createElement('span'); t.innerText=item.name;
                const p = document.createElement('div'); p.className='price-tag'; p.innerText = '❤ ' + item.price;
                b.append(col,t,p); c.appendChild(b);
            });
            refreshShopState();
        }

        function init() {
            document.getElementById('heart-count').innerText = heartScore;
            renderShopItems('floor');
            
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xdceefb);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const aspect = window.innerWidth/window.innerHeight; const d=12;
            camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
            camera.position.set(20, 20, 20); camera.lookAt(0,0,0);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2.1;

            const al = new THREE.AmbientLight(0xffffff, 0.6); scene.add(al);
            const dl = new THREE.DirectionalLight(0xffdfba, 0.8); dl.position.set(10,20,10);
            dl.castShadow=true; dl.shadow.camera.left=-15; dl.shadow.camera.right=15;
            dl.shadow.camera.top=15; dl.shadow.camera.bottom=-15; scene.add(dl);

            raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();

            createEnvironment();
            
            cats.push(new Cat(scene, 0xffa502));

            window.addEventListener('resize', onResize);
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerdown', onDown);
            window.addEventListener('pointerup', onUp);
            window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode==='placing_new') cancelPlace(); else if(mode==='moving_old') cancelMove(); else deselect(); });
            window.addEventListener('keydown', (e)=>{ if((e.key==='r'||e.key==='R') && ghostMesh && currentItemData.type==='floor') rotateItem(); });

            animate();
        }

        function createEnvironment() {
            const fg = new THREE.PlaneGeometry(12,12); const fm = new THREE.MeshStandardMaterial({color:0x8ec976});
            floorPlane = new THREE.Mesh(fg, fm); floorPlane.rotation.x=-Math.PI/2; floorPlane.receiveShadow=true; scene.add(floorPlane);
            const gh = new THREE.GridHelper(12,24,0xffffff,0xffffff); gh.position.y=0.01; gh.material.opacity=0.2; gh.material.transparent=true; scene.add(gh);
            const wm = new THREE.MeshStandardMaterial({color:0xfff6d3});
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(10,3,0.5), wm); w1.position.set(0,1.5,-5.25);
            w1.receiveShadow=true; w1.castShadow=true; scene.add(w1); obstacles.push(w1);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(0.5,3,10), wm); w2.position.set(-5.25,1.5,0);
            w2.receiveShadow=true; w2.castShadow=true; scene.add(w2); obstacles.push(w2);
        }

        function createGhost(col, sz) {
            if(ghostMesh) scene.remove(ghostMesh);
            let mat = currentItemData.light ? new THREE.MeshStandardMaterial({color:col, emissive:col, emissiveIntensity:0.5, transparent:true, opacity:0.6}) 
                                            : new THREE.MeshStandardMaterial({color:col, transparent:true, opacity:0.6});
            ghostMesh = new THREE.Mesh(new THREE.BoxGeometry(sz.x, sz.y, sz.z), mat);
            ghostMesh.position.set(0,-100,0);
            if(currentItemData.type==='floor') ghostMesh.rotation.y = currentRotation;
            scene.add(ghostMesh);
        }

        function rotateItem() { currentRotation += Math.PI/2; if(ghostMesh) { ghostMesh.rotation.y = currentRotation; checkColl(false); } }

        function startMovingOld(m) {
            mode = 'moving_old'; editingObjectOriginalPos=m.position.clone(); editingObjectOriginalQuat=m.quaternion.clone();
            const sz={x:m.geometry.parameters.width, y:m.geometry.parameters.height, z:m.geometry.parameters.depth};
            const col=m.material.color.getHex(); const type=m.userData.type||'floor'; const light=m.userData.hasLight||false;
            currentItemData={size:sz, color:col, type:type, light:light};
            if(type==='floor') currentRotation=m.rotation.y; else currentRotation=0;
            createGhost(col, sz); m.visible=false; updateStatusText("正在移动...");
        }

        function deleteSelected() { if(!selectedObject)return; scene.remove(selectedObject); 
            const i=placedFurniture.indexOf(selectedObject); if(i>-1)placedFurniture.splice(i,1); deselect(); }

        function onMove(e) {
            if(longPressTimer) { if(Math.hypot(e.clientX-startPointer.x, e.clientY-startPointer.y)>5) { clearTimeout(longPressTimer); longPressTimer=null; } }
            pointer.x=(e.clientX/window.innerWidth)*2-1; pointer.y=-(e.clientY/window.innerHeight)*2+1;
            if((mode==='placing_new'||mode==='moving_old') && ghostMesh) {
                raycaster.setFromCamera(pointer, camera);
                if(currentItemData.type==='wall') {
                    const hits = raycaster.intersectObjects(obstacles);
                    if(hits.length>0) {
                        const h=hits[0]; const n=h.face.normal; if(Math.abs(n.y)>0.5) return;
                        const pos=h.point.clone().add(n.clone().multiplyScalar(currentItemData.size.z/2+0.01));
                        if(Math.abs(n.x)>0.5) { pos.y=Math.round(pos.y/0.5)*0.5; pos.z=Math.round(pos.z/0.5)*0.5; }
                        else { pos.x=Math.round(pos.x/0.5)*0.5; pos.y=Math.round(pos.y/0.5)*0.5; }
                        const hh=currentItemData.size.y/2; if(pos.y<hh) pos.y=hh; if(pos.y+hh>3) pos.y=3-hh;
                        ghostMesh.position.copy(pos); ghostMesh.lookAt(pos.clone().add(n)); checkColl(true);
                    }
                } else {
                    const hits = raycaster.intersectObject(floorPlane);
                    if(hits.length>0) {
                        const p=hits[0].point;
                        ghostMesh.position.set(Math.round(p.x/0.5)*0.5, currentItemData.size.y/2, Math.round(p.z/0.5)*0.5);
                        ghostMesh.rotation.set(0, currentRotation, 0); checkColl(false);
                    }
                }
            }
        }

        function checkColl(isWall) {
            ghostMesh.updateMatrixWorld(); const box=new THREE.Box3().setFromObject(ghostMesh); box.expandByScalar(-0.05);
            let col=false;
            if(!isWall) for(let o of obstacles) if(box.intersectsBox(new THREE.Box3().setFromObject(o))) { col=true; break; }
            if(!col) for(let f of placedFurniture) { if(mode==='moving_old'&&f===selectedObject)continue; if(box.intersectsBox(new THREE.Box3().setFromObject(f))) { col=true; break; } }
            if(ghostMesh.position.y<0) col=true;
            if(col) { ghostMesh.material.color.setHex(0xff0000); canPlace=false; updateStatusText("位置冲突", "invalid"); }
            else { ghostMesh.material.color.setHex(currentItemData.color); canPlace=true; updateStatusText("可放置 (点击购买)", "valid"); }
        }

        function confirmPlace() {
            if(mode === 'placing_new') {
                if(heartScore >= currentItemData.price) {
                    updateMoney(-currentItemData.price);
                } else {
                    alert("金钱不足!"); 
                    cancelPlace();
                    return;
                }
            }
            const m = ghostMesh.clone(); m.material=ghostMesh.material.clone(); m.material.transparent=false; m.material.opacity=1;
            m.userData={type:currentItemData.type, hasLight:currentItemData.light||false};
            if(currentItemData.light) {
                m.material.emissiveIntensity=0.8; const sl=new THREE.SpotLight(0xfff0dd,5); sl.position.set(0,0,0); sl.target.position.set(0,0,5);
                m.add(sl); m.add(sl.target);
            } else { m.material.emissive.setHex(0); m.castShadow=true; m.receiveShadow=true; }
            scene.add(m); 
            if(mode==='moving_old') { scene.remove(selectedObject); const i=placedFurniture.indexOf(selectedObject); if(i>-1)placedFurniture.splice(i,1); deselect(); }
            placedFurniture.push(m); playBounce(m);
            if(mode==='moving_old') { mode='idle'; scene.remove(ghostMesh); ghostMesh=null; updateStatusText("移动完成"); }
        }

        function onDown(e) {
            if(e.target!==renderer.domElement) return;
            if(e.button===1 && ghostMesh && currentItemData.type==='floor') { e.preventDefault(); rotateItem(); return; }
            if(e.button===0) {
                startPointer.x=e.clientX; startPointer.y=e.clientY;
                if(mode==='idle') longPressTimer=setTimeout(()=>handleLong(e), 500);
                if((mode==='placing_new'||mode==='moving_old')&&canPlace&&ghostMesh) confirmPlace();
            }
        }
        function onUp() { if(longPressTimer) { clearTimeout(longPressTimer); longPressTimer=null; } }

        function handleLong(e) {
            raycaster.setFromCamera(pointer, camera); const hits=raycaster.intersectObjects(placedFurniture);
            if(hits.length>0) selectObj(hits[0].object, e.clientX, e.clientY); else deselect();
        }

        function selectObj(m,x,y) {
            deselect(); let t=m; while(t.parent&&t.parent!==scene) t=t.parent; selectedObject=t;
            selectionBox=new THREE.BoxHelper(selectedObject, 0xffffff); scene.add(selectionBox);
            showMenu(x,y); updateStatusText("选中: 家具");
        }

        function deselect() { selectedObject=null; if(selectionBox){scene.remove(selectionBox); selectionBox=null;} document.getElementById('context-menu').style.display='none'; }
        function cancelPlace() { if(ghostMesh)scene.remove(ghostMesh); mode='idle'; ghostMesh=null; updateStatusText("浏览中"); }
        function cancelMove() { if(mode==='moving_old'){ if(ghostMesh)scene.remove(ghostMesh); if(selectedObject){ selectedObject.position.copy(editingObjectOriginalPos); selectedObject.quaternion.copy(editingObjectOriginalQuat); selectedObject.visible=true; } } deselect(); mode='idle'; ghostMesh=null; }

        function showMenu(x,y) { const m=document.getElementById('context-menu'); m.style.display='flex'; m.style.left=(x+10)+'px'; m.style.top=(y+10)+'px'; }
        function hideContextMenu() { document.getElementById('context-menu').style.display='none'; }
        function updateStatusText(t,c) { const e=document.getElementById('status-text'); e.innerText=t; e.className=c==='valid'?'status-valid':(c==='invalid'?'status-invalid':''); }
        function playBounce(m) { let f=0; function a(){ if(f<20){const k=f/20; const s=0.1+(0.9)*(Math.sin(k*Math.PI*1.5)*0.2+k); m.scale.set(s,s,s); f++; requestAnimationFrame(a); }else m.scale.set(1,1,1); } a(); }
        function onResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            controls.update();
            if(selectionBox) selectionBox.material.opacity = 0.5 + Math.sin(time*0.005)*0.5;

            for(const cat of cats) {
                cat.update(dt || 0.016);
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>