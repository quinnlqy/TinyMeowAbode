<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light">
    <title>çŒ«å’ªçš„å®¶ - V91 ç»†èŠ‚ç²¾ä¿®ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f7fa; font-family: 'Microsoft YaHei', sans-serif; transition: background-color 1s; }
        canvas { display: block; outline: none; }
        
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s;}
        #loading-text { font-size: 20px; color: #555; margin-bottom: 10px; }
        #progress-bar { width: 200px; height: 5px; background: #ddd; margin-bottom: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #ffaa00; transition: width 0.2s; }
        #force-start-btn { display: none; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-top: 10px;}
        
        #debug-console { 
		position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
		width: 80%; max-height: 150px; overflow-y: auto; 
		background: rgba(0, 0, 0, 0.7); color: #0f0; 
		padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; 
		z-index: 10001; pointer-events: auto; display: none; 
		}
        .log-error { color: #ff5555; font-weight: bold; }
        .log-warn { color: #ffaa00; }

        #debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        /* å¤ç”¨ä¹‹å‰çš„ debug-btn æ ·å¼ï¼Œç¨å¾®è°ƒæ•´ä¸€ä¸‹ */
        .debug-btn {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        .debug-btn:hover { background: rgba(0, 0, 0, 0.8); }


        /* === HUD å®¹å™¨å¸ƒå±€ === */
        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* ç»„ä»¶é—´è· */
            z-index: 50;
            pointer-events: none; /* è®©é¼ æ ‡èƒ½ç‚¹ç©¿ç©ºç™½åŒºåŸŸ */
        }
        #hud-top-left > div {
            pointer-events: auto; /* ç»„ä»¶æœ¬èº«å¯ç‚¹å‡» */
        }

        /* === HUD å®¹å™¨å¸ƒå±€ === */
        #hud-top-left {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px; /* ç¨å¾®ç´§å‡‘ä¸€ç‚¹ */
            z-index: 50;
            pointer-events: none; 
        }
        #hud-top-left > div {
            pointer-events: auto; 
        }

        /* ================= 1. æ—¶é—´ç»„ä»¶ (Time Widget) ================= */
        #time-widget { 
            position: relative; 
            width: 130px; 
            height: 130px; /* è¿™æ˜¯ä¸€ä¸ªæ­£åœ†å½¢åŒºåŸŸ */
            margin-bottom: 5px; /* ç»™ä¸‹é¢ç•™ç‚¹ç©ºéš™ */
        }
        
        #time-bg {
            width: 100%; 
            height: 100%;
            background: url('./assets/ui/time_bg.png') no-repeat center center;
            background-size: contain; 
            
            /* æ–‡å­—å¸ƒå±€ */
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center;
            
            /* æ–‡å­—æ ·å¼ */
            color: #6d4c41; 
            font-family: 'Segoe UI', sans-serif;
            font-weight: 900;
            
            /* [å¾®è°ƒ] æ ¹æ®ä½ çš„åº•å›¾ï¼Œæ–‡å­—æ•´ä½“å¯èƒ½éœ€è¦ç¨å¾®å¾€ä¸Šæˆ–å¾€ä¸‹æä¸€ç‚¹ */
            padding-top: 5px; 
        }
        
        #time-ampm { 
            font-size: 16px; 
            opacity: 0.6; 
            line-height: 1;
            margin-bottom: -2px; /* ç´§è´´æ—¶é—´ */
        }
        #time-text-display { 
            font-size: 32px; 
            line-height: 1; 
            letter-spacing: -1px;
        }

        /* å¤ªé˜³/æœˆäº®å›¾æ ‡å®¹å™¨ (é™„ç€åœ¨å³ä¸Šè§’) */
        #weather-icon-container {
            position: absolute;
            top: 0px; 
            right: 0px; /* æŒ‚åœ¨å³ä¸Šè§’ */
            width: 45px; 
            height: 45px;
            background: url('./assets/ui/weather_bg.png') no-repeat center/contain;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
            z-index: 10; /* åœ¨æœ€ä¸Šå±‚ */
        }
        #weather-icon-container:hover { transform: scale(1.1); }
        #weather-icon-img { 
            /* [ä¿®æ”¹] è®©å›¾ç‰‡æ’‘æ»¡å®¹å™¨ */
            width: 100%; 
            height: 100%; 
            object-fit: cover; /* é“ºæ»¡ */
        }

        /* æ»‘å—æ°”æ³¡ (é»˜è®¤éšè—) */
        #time-popover {
            position: absolute;
            left: 100%; /* åœ¨æ—¶é—´ç»„ä»¶å³ä¾§ */
            top: 10px;
            margin-left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex; align-items: center; gap: 8px;
            transition: all 0.2s;
            pointer-events: auto;
            width: 140px; /* å›ºå®šå®½åº¦é˜²æ­¢æŠ–åŠ¨ */
        }
        #time-popover.hidden { 
            opacity: 0; 
            visibility: hidden; 
            transform: translateX(-10px); /* éšè—æ—¶ç¨å¾®å¾€å·¦ç¼©ä¸€ä¸‹ */
        }
        #time-slider-hud { width: 100px; cursor: pointer; accent-color: #ffaa00; }
        #time-reset-btn {
            background: none; border: none; font-size: 18px; cursor: pointer; color: #999; padding: 0;
        }

/* ================= 2. çˆ±å¿ƒç»„ä»¶ (Heart Widget) ================= */
        #heart-widget { 
            position: relative;
            /* [ä¿®æ”¹] è°ƒæ•´å®½é«˜æ¯”ï¼Œé˜²æ­¢èƒŒæ™¯æ‹‰ä¼¸ */
            /* å‡è®¾èƒŒæ™¯å›¾æ˜¯é•¿æ¡å½¢çš„ï¼Œé«˜åº¦55pxè¶³å¤Ÿäº† */
            width: 200px; 
            height: 65px; 
            margin-top: -15px; 
            z-index: 5; 
        }
        #heart-bg {
            width: 100%; height: 100%;
            background: url('./assets/ui/heart_bar_bg.png') no-repeat left center;
            
            /* [å…³é”®ä¿®å¤] ä½¿ç”¨ contain ä¿æŒåŸå›¾æ¯”ä¾‹ï¼Œç»ä¸æ‹‰ä¼¸ */
            background-size: contain; 
            
            display: flex; align-items: center;
            
            /* [è°ƒæ•´] å› ä¸ºå›¾æ ‡å˜å°äº†ï¼Œå·¦è¾¹è·é€‚å½“å‡å° */
            padding-left: 75px; 
            box-sizing: border-box;
            padding-bottom: 0px; 
        }
        
        /* ç‹¬ç«‹çš„çˆ±å¿ƒå›¾æ ‡ */
        #heart-icon-img { 
            position: absolute;
            left: 14px; 
            top: 15px; /* å‚ç›´å±…ä¸­å¾®è°ƒ */
            
            /* [ç¼©å°] æ”¹å›ç²¾è‡´çš„å¤§å° */
            width: 38px; 
            height: 38px; 
            
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
            z-index: 6;
        }
        #heart-text-display { 
            /* [è°ƒæ•´] å­—ä½“å¤§å°é€‚é…æ–°çš„é«˜åº¦ */
            font-size: 22px; 
            color: #d35400; 
            font-weight: 800; 
        }


        /* 3. çŠ¶æ€çƒç»„ä»¶ */
/* ================= 3. çŠ¶æ€çƒç»„ä»¶ (Status Icons) ================= */
        #status-widget-group { 
            display: flex; 
            flex-direction: row; 
            gap: 8px;            
            margin-left: 5px;    
            margin-top: 5px;
        }
        
        .status-circle {
            width: 65px; height: 65px; 
            position: relative;
            background: none; border: none;
        }

        /* 1. åº•å±‚ Frame */
        .status-frame {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            z-index: 0;
        }

        /* 2. ä¸­é—´ Mask */
        .liquid-mask {
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%; 
            overflow: hidden; 
            z-index: 1; 
            background: transparent; 
        }

        /* æ°´ä½æ§åˆ¶å™¨ */
        .liquid-level {
            position: absolute;
            bottom: 0; left: 0;
            width: 100%;
            height: 100%; /* JS æ§åˆ¶è¿™ä¸ª */
            overflow: hidden; /* å…³é”®ï¼šåˆ‡æ‰ä¸ŠåŠéƒ¨åˆ† */
            transition: height 0.5s ease-out;
        }

        /* 3. æ¶²ä½“çº¹ç† - [æœ¬æ¬¡ä¿®å¤é‡ç‚¹] */
        .liquid-texture {
            position: absolute;
            bottom: 0; left: 0;
            width: 100%; 
            height: 65px; /* [Fixed] å›ºå®šé«˜åº¦ï¼Œæ°¸è¿œä¸ç¼©æ”¾ */
            object-fit: cover;
        }

/* 4. é¡¶å±‚ Icon */
        .status-icon-fg {
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%;
            object-fit: contain; 
            z-index: 2; 
            
            /* [æ”¾å¤§] æ”¾å¤§åˆ° 0.85 */
            /* 65px * 0.85 â‰ˆ 55pxï¼Œè¿™æ ·å°±å’Œä¸Šé¢çš„çˆ±å¿ƒä¸€æ ·å¤§äº† */
            transform: scale(0.85); 
            
            pointer-events: none;
        }

        /* 4. åº•éƒ¨æŒ‰é’® */
        #hud-bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 50%; transform: translateX(-50%);
            display: flex; gap: 40px;
            z-index: 40;
        }
        .hud-btn-container { position: relative; cursor: pointer; transition: transform 0.2s; }
        .hud-btn-container:hover { transform: translateY(-5px); }
        .hud-main-btn { width: 70px; height: 70px; filter: drop-shadow(0 4px 4px rgba(0,0,0,0.3)); }
        
        #diary-red-dot-hud {
            position: absolute; top: 0; right: 0;
            width: 15px; height: 15px; background: red; border-radius: 50%; border: 2px solid white;
            display: none;
        }

/* 5. å•†åº—é¢æ¿åŠ¨ç”» */
/* ================= 5. å•†åº—é¢æ¿ (è½¯æœ¨æ¿é£æ ¼) - æœ€ç»ˆç²¾ä¿®ç‰ˆ ================= */
        #shop-panel-container {
            position: absolute; 
            bottom: 0; left: 50%; 
            
            /* å°ºå¯¸ */
            width: 800px; 
            height: 250px; 
            max-width: 95%;
            
            /* --- [æ ¸å¿ƒä¿®å¤ï¼šä¹å®«æ ¼ä¸æ‹‰ä¼¸] --- */
            /* 1. è®¾ç½®å±å¹•ä¸Šæ˜¾ç¤ºçš„è¾¹æ¡†åšåº¦ (ä¾‹å¦‚ 22px) */
            border: 40px solid transparent; 
            
            /* 2. border-image é…ç½® */
            /* url(...) */
            /* 80: å‡è®¾æºå›¾ä¸­è¾¹æ¡†åšåº¦çº¦80åƒç´  (ä¸å¸¦å•ä½!)ã€‚è¿™ä¿è¯åˆ‡å‡ºæ¥æ˜¯æ­£æ–¹å½¢ */
            /* fill: ä¿ç•™ä¸­é—´å†…å®¹ */
            /* / 22px: å¯¹åº”ä¸Šé¢çš„ border å®½åº¦ */
            /* / 0: ä¸å‘å¤–æ‰©å¼  */
            /* round: [å…³é”®] ä½¿ç”¨å¹³é“ºè€Œä¸æ˜¯æ‹‰ä¼¸ï¼Œé˜²æ­¢æœ¨çº¹å˜å½¢ */
            border-image: url('./assets/ui/shop_bg_board.png') 80 fill / 40px / 0 round;
            /* --------------------------- */
            
            box-shadow: none;
            z-index: 60; 
            padding: 0; 
            
            /* åŠ¨ç”» */
            transform: translateX(-50%); 
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            
            display: flex; flex-direction: column;
            align-items: center;
            box-sizing: border-box; 
        }

        /* éšè—çŠ¶æ€ */
        #shop-panel-container.hidden-bottom {
            transform: translate(-50%, 120%) !important; 
        }

/* æ ‡é¢˜ç‰Œå¾®è°ƒ */
        #shop-title-img {
            position: absolute;
            /* å¾€ä¸Šæï¼Œå› ä¸ºå®ƒç°åœ¨æ˜¯ç›¸å¯¹äº padding box å®šä½çš„ */
            top: -50px; left: 10px; 
            height: 60px;
            z-index: 70;
        }

        /* å…³é—­æŒ‰é’®å¾®è°ƒ */
        #shop-close-btn {
            position: absolute; 
            top: -50px; right: 0px; 
            width: 45px; height: 45px; 
            background: url('./assets/ui/shop_close_btn.png') no-repeat center/contain;
            border: none; cursor: pointer;
            z-index: 70;
        }
        #shop-close-btn:hover { transform: scale(1.1); }

/* === é¡µç­¾æ  (Tabs) === */
        #shop-tabs {
            position: absolute;
            top: -65px; /* å¾€ä¸Šæï¼Œæ”¾åœ¨æ¿å­å¤–é¢ */
            right: 80px; 
            display: flex; gap: 8px;
            z-index: 70; 
        }
        
        .shop-tab {
            position: relative;
            width: 55px; height: 55px; 
            cursor: pointer;
            transition: transform 0.2s;
            /* Flex å±…ä¸­ */
            display: flex; align-items: center; justify-content: center;
        }
        .shop-tab:hover { transform: translateY(-5px); }
        
        /* èƒŒæ™¯æ¡† (Tab Background) */
        .tab-bg {
            position: absolute; 
            /* [ä¿®æ”¹] ç»å¯¹å±…ä¸­å¤§æ³• */
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%); /* å‘å›ç§»åŠ¨è‡ªèº«çš„ä¸€åŠï¼Œå®ç°å®Œç¾å±…ä¸­ */

            width: 110%; height: 110%;
            object-fit: contain;
            
            /* [ä¿®æ”¹] æé«˜å±‚çº§ï¼Œä½†è¦æ¯” icon ä½ */
            z-index: 0; 
            
            /* ç¡®ä¿å¯è§æ€§ */
            display: block; 
            opacity: 1;
        }
        
        /* é€‰ä¸­çŠ¶æ€é€»è¾‘ */
        .shop-tab:not(.active) .tab-bg { 
            /* æœªé€‰ä¸­ï¼šå˜æš— */
            filter: brightness(0.6) grayscale(100%); 
        }
        .shop-tab.active .tab-bg { 
            /* é€‰ä¸­ï¼šåŸæ ·æ˜¾ç¤º */
            filter: none; 
        }
        
        /* å›¾æ ‡ (Icon) */
/* é¡µç­¾å›¾æ ‡ */
        .tab-icon {
            position: absolute;
            
            /* [ä¿®æ”¹] ç»å¯¹å±…ä¸­å¤§æ³• */
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%); /* å‘å›ç§»åŠ¨è‡ªèº«çš„ä¸€åŠï¼Œå®ç°å®Œç¾å±…ä¸­ */
            
            width: 100%; height: 100%;
            object-fit: contain;
            z-index: 1; 
        }

/* === å•†å“æ»šåŠ¨åŒº === */
        #items-scroll {
            margin-top: 0; 
            width: 100%;
            height: 100%;
            
            display: flex; 
            gap: 15px; 
            
            /* [ä¿®æ”¹] åº•éƒ¨ padding å¿…é¡» >= 40px (ç»™çŒ«å¤´ç•™ä½ç½®) */
            padding: 50px 30px 45px 30px; 
            
            /* [ä¿®æ”¹] å…³é”®å±æ€§ï¼šå¼ºåˆ¶åœ¨ x è½´æ˜¾ç¤ºæ»šåŠ¨ */
            overflow-x: scroll; 
            overflow-y: hidden;
            white-space: nowrap;
            scroll-behavior: smooth;
        }

        /* === è‡ªå®šä¹‰æ»šåŠ¨æ¡ (å¼ºåˆ¶æ ·å¼) === */
        
        /* 1. æ•´ä½“è½¨é“ */
        #items-scroll::-webkit-scrollbar {
            height: 40px !important; /* [åŠ å¤§] å¿…é¡»è¶³å¤Ÿé«˜ */
            background-color: transparent;
        }
        
        /* 2. è½¨é“èƒŒæ™¯ (ç»³å­) */
        #items-scroll::-webkit-scrollbar-track {
            background-color: transparent;
            /* å›¾ç‰‡è·¯å¾„ */
            background-image: url('./assets/ui/shop_cat_deco_rope.png');
            background-repeat: repeat-x;
            background-position: center 18px; /* [å¾®è°ƒ] ç»³å­å‚ç›´å±…ä¸­ */
            background-size: auto 12px;       /* ç»³å­é«˜åº¦ */
            
            margin: 0 40px; /* å·¦å³ç¼©è¿› */
            border: none;
        }
        
        /* 3. æ»‘å— (çŒ«å¤´) */
        #items-scroll::-webkit-scrollbar-thumb {
            background-color: transparent;
            /* å›¾ç‰‡è·¯å¾„ */
            background-image: url('./assets/ui/shop_cat_deco.png');
            background-repeat: no-repeat;
            background-position: center bottom; /* æ²‰åº• */
            
            /* [å…³é”®] å¼ºåˆ¶å›¾ç‰‡é€‚åº”å¤§å°ï¼Œé˜²æ­¢åŸå›¾å¤ªå¤§æ˜¾ç¤ºä¸å…¨ */
            background-size: 40px 40px; 
            
            /* æœ€å°å®½åº¦ */
            min-width: 60px; 
            
            /* [å¿…æ€æŠ€] è¿™é‡Œçš„ border æ˜¯ä¸ºäº†è®©æŸäº›æµè§ˆå™¨æ­£ç¡®æ¸²æŸ“é€æ˜èƒŒæ™¯å›¾ç‰‡ */
            border: 2px solid transparent;
            background-clip: content-box; 
        }

        /* 4. éšè—ä¸¤ç«¯æŒ‰é’® (é˜²æ­¢å‡ºç°ä¸‘é™‹çš„ç®­å¤´) */
        #items-scroll::-webkit-scrollbar-button {
            display: none !important;
            width: 0;
            height: 0;
        }
        #items-scroll::-webkit-scrollbar-corner {
            background-color: transparent;
        }

        /* 5. äº¤äº’æ€ */
        #items-scroll::-webkit-scrollbar-thumb:hover {
            filter: brightness(1.1);
        }


        /* === å•†å“å¡ç‰‡ (å±•ç¤ºå°é£æ ¼) === */
        .item-card {
            flex: 0 0 auto;
            width: 100px; height: 130px; 
            position: relative;
            cursor: pointer;
            display: flex; flex-direction: column; align-items: center;
            transition: transform 0.2s;
        }
        .item-card:hover { transform: translateY(-5px); }
        .item-card.disabled { opacity: 0.6; filter: grayscale(100%); cursor: not-allowed; }

        /* å±•ç¤ºå° (Shelf) */
        .shelf-bg {
            position: absolute;
            top: 60px; /* å±•ç¤ºå°åœ¨è„šä¸‹ */
            width: 90px; height: 40px;
            z-index: 1;
        }

        /* å•†å“å›¾æ ‡ */
        .item-icon {
            width: 80px; height: 80px;
            object-fit: contain;
            z-index: 2; /* åœ¨å°å­ä¸Šé¢ */
            margin-top: 10px;
            filter: drop-shadow(0 5px 5px rgba(0,0,0,0.2));
        }
        
        /* å¦‚æœæ²¡æœ‰å›¾ï¼Œæ˜¾ç¤ºçš„å¤‡ç”¨è‰²å— */
        .item-placeholder {
            width: 50px; height: 50px;
            border-radius: 50%;
            margin-top: 25px;
            z-index: 2;
            border: 2px solid rgba(0,0,0,0.1);
        }

        /* ä»·æ ¼åŠç‰Œ - ä¿®å¤å¸ƒå±€ */
        .price-tag-new {
            position: absolute;
            bottom: 15px; 
            width: 70px; height: 30px;
            background: url('./assets/ui/shop_price_tag.png') no-repeat center/contain;
            z-index: 3;
            
            /* Flex å¸ƒå±€è®©çˆ±å¿ƒå’Œæ•°å­—æ°´å¹³å±…ä¸­ */
            display: flex; align-items: center; justify-content: center;
            gap: 4px; /* å›¾æ ‡å’Œæ•°å­—é—´è· */
            
            color: #d35400; font-weight: bold; font-size: 13px;
            padding-top: 4px; /* å¾®è°ƒæ–‡å­—å‚ç›´ä½ç½® */
            padding-left: 2px;
        }
        
        /* ä»·æ ¼æ ‡ç­¾é‡Œçš„å°çˆ±å¿ƒ */
        .price-heart-icon {
            width: 14px; height: 14px;
            object-fit: contain;
            display: block;
        }
        
        /* é€‰ä¸­çŠ¶æ€ */
        .item-card.selected .item-icon {
            transform: scale(1.1);
            filter: drop-shadow(0 0 10px gold);
        }
        /*==========================================================================*/
        
        #clock-wrapper { background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); pointer-events: auto; display: flex; flex-direction: column; gap: 5px; align-items: center; min-width: 140px; }
        /* [æ–°å¢] é‡ç½®æ—¶é—´æŒ‰é’®æ ·å¼ */
        #btn-auto-time {
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999; /* é»˜è®¤ç°è‰² */
            margin-left: 8px;
            padding: 0;
            line-height: 1;
            transition: all 0.3s ease;
        }
        #btn-auto-time:hover {
            color: #333;
            transform: rotate(180deg); /* æ‚¬åœæ—¶æ—‹è½¬ä¸€ä¸‹ */
        }
        /* å½“å¤„äºè‡ªåŠ¨æ¨¡å¼æ—¶ï¼ŒæŒ‰é’®å˜æˆç»¿è‰²ï¼Œè¡¨ç¤ºå½“å‰æ˜¯å®æ—¶åŒæ­¥çŠ¶æ€ */
        #btn-auto-time.is-auto {
            color: #2ecc71; 
        }
        
        #clock-display { font-size: 24px; font-weight: bold; color: #333; display: flex; align-items: center; gap: 8px; }
        #day-icon { font-size: 24px; }
        #time-control { display: flex; align-items: center; gap: 5px; font-size: 10px; color: #666; width: 100%; }
        input[type=range] { flex: 1; cursor: pointer; height: 4px; accent-color: #ffaa00; }

        #heart-panel { background: rgba(255,255,255,0.95); padding: 8px 15px; border-radius: 20px; font-size: 18px; color: #e74c3c; font-weight: bold; display: flex; gap: 10px; align-items: center; pointer-events: auto; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .debug-btn { background: #555; color: white; border: none; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; }

        #tutorial { 
            position: absolute; 
            top: 150px; 
            left: 20px; 
            background: rgba(255,255,255,0.9); 
            padding: 15px; 
            border-radius: 12px; 
            pointer-events: none; 
            z-index: 5; 
            display: none; 
        }
        #context-menu { position: absolute; display: none; background: white; padding: 8px; border-radius: 8px; z-index: 100; flex-direction: column; gap: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); pointer-events: auto; }
        .context-btn { padding: 8px 16px; border: 1px solid #eee; background: #f9f9f9; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-delete { color: red; background: #fff0f0; }
        
        #confirm-dialog {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 20000;
            text-align: center; display: none; width: 280px; font-family: 'Microsoft YaHei', sans-serif;
        }
        #confirm-dialog h3 { margin-top: 0; color: #333; }
        #confirm-dialog p { color: #666; margin-bottom: 20px; }
        .dialog-btns { display: flex; justify-content: space-around; margin-top: 20px; }
        .dialog-btn { padding: 8px 20px; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; transition: transform 0.1s; }
        .btn-yes { background: #ffaa00; color: white; }
        .btn-no { background: #eee; color: #333; }
        .dialog-btn:active { transform: scale(0.95); }

        .status-valid { color: green; font-weight: bold; }
        .status-invalid { color: red; font-weight: bold; }
        .heart-float { position: absolute; color: #e74c3c; font-weight: bold; font-size: 20px; pointer-events: none; animation: floatUp 1.5s ease-out forwards; z-index: 30; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
        .emote-bubble { position: absolute; font-size: 24px; pointer-events: none; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25; }
        @keyframes popUp { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        #shop-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; background: rgba(255, 255, 255, 0.98); border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; user-select: none; z-index: 10; }
        #tabs { display: flex; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; text-align: center; padding: 10px 0; cursor: pointer; font-size: 14px; color: #666; }
        .tab.active { background: #fff; color: #333; font-weight: bold; border-bottom: 3px solid #ffaa00; }
        #items-scroll { display: flex; gap: 12px; padding: 15px; overflow-x: auto; white-space: nowrap; scrollbar-width: thin; }
        .item-btn { flex: 0 0 auto; width: 80px; height: 85px; border: 2px solid #eee; border-radius: 12px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; background: #fff; color: #333; position: relative; transition: all 0.2s; }
        .item-btn.selected { border: 3px solid #ffaa00; background: #fff8e1; transform: translateY(-3px); }
        .item-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; }
        .color-preview { width: 24px; height: 24px; border-radius: 50%; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.1); background-size: cover; }
        .price-tag { margin-top: 4px; font-size: 11px; color: #e74c3c; font-weight: bold; background: #fff0f0; padding: 2px 6px; border-radius: 8px; }

        .bubble { position: absolute; top: -100px; left: -100px; background: white; padding: 8px 15px; border-radius: 20px; border: 2px solid #333; font-size: 20px; pointer-events: none; transform: translate(-50%, -100%); z-index: 1000; opacity: 1; transition: opacity 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .bubble.hidden { opacity: 0; visibility: hidden; }
        .bubble::after { content: ''; position: absolute; bottom: -6px; left: 50%; margin-left: -6px; border-width: 6px 6px 0; border-style: solid; border-color: #333 transparent transparent transparent; }
        
        /* [UIä¿®æ”¹] å¸¸é©»æ˜¾ç¤ºé¢æ¿ï¼Œä½ç½®è°ƒæ•´åˆ°å·¦ä¸‹è§’ */
        .panel { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; /* æ”¾åœ¨å·¦ä¾§ */
            background: rgba(255, 255, 255, 0.95); 
            padding: 15px; 
            border-radius: 12px; 
            width: 160px; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
            font-family: 'Arial', sans-serif; 
            z-index: 900; 
            display: block; /* å¸¸é©»æ˜¾ç¤º */
        }
        .panel.hidden { display: none !important; }
        .panel h3 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .stat-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; }
        .stat-row span { width: 40px; font-weight: bold; color: #555; }
        .progress-bar { flex-grow: 1; background: #e0e0e0; height: 10px; border-radius: 5px; overflow: hidden; margin-left: 5px; border: 1px solid #ccc; }
        #bar-hunger { background: #ff9f43; height: 100%; transition: width 0.3s; }
        #bar-toilet { background: #54a0ff; height: 100%; transition: width 0.3s; }

        /* [æ–°å¢] æ—¥è®°å…¥å£æŒ‰é’® */
        #diary-btn-wrapper {
            position: absolute;
            bottom: 20px;
            left: 200px; /* æ”¾åœ¨çŠ¶æ€é¢æ¿(å®½160px)å³è¾¹ */
            z-index: 20;
        }
        #diary-toggle-btn {
            font-size: 30px;
            background: rgba(255,255,255,0.9);
            border: 2px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        #diary-toggle-btn:hover { transform: scale(1.1); }
        #diary-red-dot {
            position: absolute;
            top: 0; right: 0;
            width: 12px; height: 12px;
            background: #e74c3c;
            border-radius: 50%;
            border: 2px solid #fff;
            display: none; /* é»˜è®¤éšè— */
        }

        /* [æ–°å¢] æ—¥è®°æœ¬å¼¹çª— */
        #diary-modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }
        #diary-modal.hidden { display: none; }

        #diary-paper {

            /* [ä¿®æ”¹] è°ƒæ•´å°ºå¯¸ä¸º B5 é£æ ¼ (æ¯”ä¾‹çº¦ 1:1.4) */
            width: 500px;        /* å®½åº¦å˜å®½ */
            height: 700px;       /* é«˜åº¦å›ºå®šï¼Œä¸å†éšå†…å®¹å˜åŒ– */

            /* é˜²æ­¢å±å¹•å¤ªå°æ—¶æº¢å‡º */
            max-width: 90%;
            max-height: 90%; 

            background: #fffdf2; /* ç±³é»„çº¸è‰² */
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            position: relative;
            font-family: 'Courier New', 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
        }
        #diary-close-btn {
            position: absolute; top: 10px; right: 10px;
            background: none; border: none; font-size: 24px; cursor: pointer; color: #888;
        }
        #diary-title { margin: 0 0 5px 0; color: #5d4037; font-size: 20px; text-align: center; }
        #diary-meta { font-size: 12px; color: #888; text-align: center; margin-bottom: 5px; }
        
        #diary-entries {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            /* æ»šåŠ¨æ¡ç¾åŒ– */
            scrollbar-width: thin;
            scrollbar-color: #dbc2a3 transparent;
        }
        #diary-entries::-webkit-scrollbar { width: 4px; }
        #diary-entries::-webkit-scrollbar-thumb { background: #dbc2a3; border-radius: 2px; }

        .entry { margin-bottom: 15px; border-left: 3px solid #ffaa00; padding-left: 10px; animation: fadeIn 0.3s; }
        .entry-time { font-size: 12px; color: #999; font-weight: bold; margin-bottom: 2px; }
        .entry-text { font-size: 14px; color: #333; line-height: 1.5; }
        .empty-tip { color: #ccc; text-align: center; border: none; font-style: italic; margin-top: 20px; }
        @keyframes fadeIn { from { opacity:0; transform:translateY(5px); } to { opacity:1; transform:translateY(0); } }

        /* [æ–°å¢] å³ä¸Šè§’ Debug å·¥å…·æ æ ·å¼ */
#debug-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
    z-index: 100;
}
.debug-btn {
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: 1px solid rgba(255,255,255,0.3);
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
}
.debug-btn:hover { background: rgba(0, 0, 0, 0.8); }


    </style>
    <script>
        function logToScreen(msg, type = 'info') 
        { 
            const consoleDiv = document.getElementById('debug-console'); 
            if (consoleDiv) { 
                //consoleDiv.style.display = 'block'; 
                const line = document.createElement('div'); 
                line.textContent = `> ${msg}`; 
                if (type === 'error') line.className = 'log-error'; 
                else if (type === 'warn') line.className = 'log-warn'; consoleDiv.appendChild(line); consoleDiv.scrollTop = consoleDiv.scrollHeight; } console.log(msg); }
        window.onerror = function(msg, url, line) { logToScreen(`ERROR: ${msg} (Line ${line})`, 'error'); document.getElementById('force-start-btn').style.display = 'block'; return false; };
    </script>
</head>
<body>

    <div id="debug-console">V91 ç³»ç»Ÿæ—¥å¿—...</div>

    <div id="loading-screen">
        <div id="loading-text">èµ„æºåŠ è½½ä¸­...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <button id="force-start-btn" onclick="window.forceStart()">âš ï¸ å¼ºåˆ¶è¿›å…¥æ¸¸æˆ</button>
    </div>

    <div id="confirm-dialog">
        <h3 id="dialog-title">è¡¥å……çŒ«ç²®?</h3>
        <p id="dialog-msg">éœ€è¦æ¶ˆè€— 10 çˆ±å¿ƒ</p>
        <div class="dialog-btns">
		<button class="dialog-btn btn-no" onclick="closeDialog()">å–æ¶ˆ</button>
		<button class="dialog-btn btn-yes" id="btn-confirm-yes">ç¡®å®š</button>
		</div>
    </div>



    <div id="tutorial">
        <strong>V91 ç»†èŠ‚ç²¾ä¿®ç‰ˆ</strong><br>
        1. ä¿®å¤çŒ«å’ªç¡è§‰"è¸¢è…¿"/æ¥å›èµ°<br>
        2. åƒé¥­å¯¹å‡†/ç«™çŒ«ç ‚ç›†ä¸Š<br>
        3. çŠ¶æ€æ å¸¸é©»å·¦ä¸‹è§’<br>
        <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;"><span id="status-text">åˆå§‹åŒ–...</span></div>
    </div>

    <!-- ================== æ–°ç‰ˆ HUD ================== -->
    
    <!-- 1. å·¦ä¸Šè§’ï¼šæ—¶é—´ä¸çŠ¶æ€ -->
    <div id="hud-top-left">
        <!-- æ—¶é—´ç»„ä»¶ -->
        <div id="time-widget">
            <div id="time-bg">
                <!-- æ˜¾ç¤ºæ—¶é—´ -->
                <span id="time-text-display">12:00</span>
                <span id="time-ampm">PM</span>
            </div>
            <!-- å¤©æ°”/å…‰å½±æ§åˆ¶å…¥å£ -->
            <div id="weather-icon-container" onclick="toggleTimePopover()">
                <img id="weather-icon-img" src="./assets/ui/icon_sun.png">
            </div>
            <!-- éšè—çš„æ»‘å—æ§åˆ¶æ¡ (Popover) -->
            <div id="time-popover" class="hidden">
                <input type="range" id="time-slider-hud" min="0" max="23.99" step="0.01">
                <button id="time-reset-btn" title="é‡ç½®æ—¶é—´">â†»</button>
            </div>
        </div>

        <!-- çˆ±å¿ƒç»„ä»¶ -->
        <div id="heart-widget">
            <!-- å›¾æ ‡æ”¾åœ¨èƒŒæ™¯å¤–é¢ï¼Œæ–¹ä¾¿ç»å¯¹å®šä½ -->
            <img src="./assets/ui/icon_heart.png" id="heart-icon-img">
            <div id="heart-bg">
                <span id="heart-text-display">500</span>
            </div>
        </div>

<!-- ç”Ÿç†çŠ¶æ€ç»„ä»¶ -->
        <div id="status-widget-group">
            <!-- é¥±é£Ÿåº¦ -->
            <div class="status-circle">
                <!-- 1. åº•å±‚ Frame -->
                <img src="./assets/ui/hunger_icon_frame.png" class="status-frame">
                
                <!-- 2. ä¸­é—´ Mask (è´Ÿè´£åˆ‡åœ†è§’) -->
                <div class="liquid-mask">
                    <!-- [æ–°å¢] æ°´ä½å®¹å™¨ (è´Ÿè´£æ§åˆ¶é«˜åº¦) -->
                    <div class="liquid-level" id="level-hunger">
                        <!-- æ¶²ä½“çº¹ç† (é«˜åº¦å›ºå®šï¼Œæ²‰åº•) -->
                        <img src="./assets/ui/hunger_icon_fill.png" class="liquid-texture">
                    </div>
                </div>
                
                <!-- 3. é¡¶å±‚ Icon -->
                <img src="./assets/ui/hunger_icon.png" class="status-icon-fg">
            </div>

            <!-- ä¾¿ä¾¿å€¼ -->
            <div class="status-circle">
                <img src="./assets/ui/toilet_icon_frame.png" class="status-frame">
                <div class="liquid-mask">
                    <div class="liquid-level" id="level-toilet">
                        <img src="./assets/ui/toilet_icon_fill.png" class="liquid-texture">
                    </div>
                </div>
                <img src="./assets/ui/toilet_icon.png" class="status-icon-fg">
            </div>
        </div>

    </div>

    <!-- [æ–°å¢] å³ä¸Šè§’ Debug å·¥å…·æ  HTML -->
<div id="debug-panel">
    <button class="debug-btn" onclick="debugAddMoney()">+$$</button>
    <button class="debug-btn" onclick="debugResetCat()">é‡ç½®çŒ«</button>
    <button class="debug-btn" onclick="toggleDebugGizmos()">çº¿æ¡†</button>
    <button class="debug-btn" onclick="toggleConsole()">ğŸ“œ æ—¥å¿—</button>
    <button class="debug-btn" onclick="window.debugGenDiary()">ğŸ“ ç”Ÿæˆ</button>
    <button class="debug-btn" onclick="window.debugClearDiary()">ğŸ—‘ï¸ æ¸…ç©º</button>
</div>

    <!-- 2. åº•éƒ¨ï¼šåŠŸèƒ½å…¥å£ -->
    <div id="hud-bottom-bar">
        <div class="hud-btn-container" onclick="toggleDiary()">
            <img src="./assets/ui/btn_diary.png" class="hud-main-btn">
            <div id="diary-red-dot-hud"></div>
        </div>
        <div class="hud-btn-container" onclick="toggleShop()">
            <img src="./assets/ui/btn_shop.png" class="hud-main-btn">
        </div>
    </div>

    <!-- 3. å•†åº—é¢æ¿ (ä¿®æ”¹åŸæœ‰ç»“æ„ï¼Œå¢åŠ å…³é—­æŒ‰é’®) -->
<!-- 3. å•†åº—é¢æ¿ (è½¯æœ¨æ¿é£æ ¼) -->
    <div id="shop-panel-container" class="hidden-bottom">
        
        <!-- èƒŒæ™¯æ¿ä¸Šçš„æ ‡é¢˜ç‰Œ -->
        <img src="./assets/ui/shop_title_sign.png" id="shop-title-img">
        
        <!-- å…³é—­æŒ‰é’® -->
        <button id="shop-close-btn" onclick="toggleShop()"></button>

        <!-- é¡µç­¾æ  (å›¾æ ‡åŒ–) -->
        <div id="shop-tabs">
            <!-- å®¶å…· -->
            <div class="shop-tab active" onclick="switchCategory('floor')">
                <img src="./assets/ui/tab_bg_active.png" class="tab-bg">
                <img src="./assets/ui/tab_furniture.png" class="tab-icon">
            </div>
            <!-- å°ç‰© -->
            <div class="shop-tab" onclick="switchCategory('small')">
                <img src="./assets/ui/tab_bg_active.png" class="tab-bg">
                <img src="./assets/ui/tab_small.png" class="tab-icon">
            </div>
            <!-- å¢™å£ -->
            <div class="shop-tab" onclick="switchCategory('wall')">
                <img src="./assets/ui/tab_bg_active.png" class="tab-bg">
                <img src="./assets/ui/tab_wall.png" class="tab-icon">
            </div>
            <!-- è£…ä¿® -->
            <div class="shop-tab" onclick="switchCategory('decor')">
                <img src="./assets/ui/tab_bg_active.png" class="tab-bg">
                <img src="./assets/ui/tab_decor.png" class="tab-icon">
            </div>
        </div>

        <!-- å•†å“åˆ—è¡¨æ»šåŠ¨åŒº -->
        <div id="items-scroll">
            <!-- JS åŠ¨æ€å¡«å…… -->
        </div>
    </div>




    <div id="context-menu"><div class="context-btn" id="btn-move">ç§»åŠ¨ä½ç½®</div><div class="context-btn btn-delete" id="btn-delete">åˆ é™¤å®¶å…·</div><div class="context-btn" id="btn-cancel">å–æ¶ˆé€‰ä¸­</div></div>
    <div id="cat-bubble" class="bubble hidden"><span id="bubble-icon">ğŸŸ</span></div>
    
    <!-- å¸¸é©»çŠ¶æ€é¢æ¿ -->



    <!-- [æ–°å¢] æ—¥è®°æœ¬å¼¹çª— (æ¨¡æ€æ¡†) -->
    <div id="diary-modal" class="hidden">
        <div id="diary-paper">
            <button id="diary-close-btn" onclick="toggleDiary()">Ã—</button>
            <h2 id="diary-title">çŒ«å’ªæ—¥è®°</h2>
            
            <!-- [æ–°å¢] ç¿»é¡µæ§åˆ¶åŒº -->
            <div id="diary-nav" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <button onclick="diaryManager.changePage(-1)" style="cursor:pointer; border:none; background:none; font-size:18px;">â—€</button>
                <span id="diary-date-title" style="font-weight:bold; color:#555;">2023-12-17</span>
                <button onclick="diaryManager.changePage(1)" style="cursor:pointer; border:none; background:none; font-size:18px;">â–¶</button>
            </div>

            <div id="diary-meta">
                <span id="diary-weather">ğŸŒ¤ï¸ å¿ƒæƒ…éšç¬”</span>
            </div>
            <hr style="border: 0; border-top: 1px dashed #ccc; margin: 10px 0;">
            
            <div id="diary-entries">
                <!-- å†…å®¹ -->
            </div>
        </div>
    </div>


    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.160.0", "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
        // === [æ–°å¢] åæœŸå¤„ç†æ¨¡å— (ç›´æ¥å¤åˆ¶è¿™ä¸€æ®µæ”¾åœ¨è¿™é‡Œ) ===
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        setTimeout(() => { const ls = document.getElementById('loading-screen'); if(ls && ls.style.display !== 'none') document.getElementById('force-start-btn').style.display='block'; }, 5000);

        // === 1. å…¨å±€é…ç½®ä¸å˜é‡ ===
        const CAT_CONFIG = { 
            scale: 0.35, rotateX: 0, rotateY: 0, yOffset: 0, 
            anim: {
                sleep: 0,   // Action 1: å€’ä¸‹/ä¾§èºº
                happy: 1,   // Action 2: ä¹è®¨/é«˜å…´
                idle: 2,    // Action 3: å¯»æ‰¾ (ä½œä¸ºå¾…æœº)
                eat: 3,     // Action 4: åƒé¥­
                urgent: 5,  // Action 6: ç€æ€¥ (ä¸Šå•æ‰€)
                hop: 6,     // Action 7: è·³ç€èµ°
                walk: 7     // Action 8: èµ°è·¯
            }
        };
        const SKY_COLORS = { night: new THREE.Color(0x1a1a2e), dawn: new THREE.Color(0xffaa99), day: new THREE.Color(0xe0f7fa), dusk: new THREE.Color(0x6a5acd) };
        const DEFAULT_DECOR = { floor: { color: 0xF5F5DC, texture: null }, wall:  { color: 0xEBE5D1, texture: null } };
        
        let scene, camera, renderer, controls;
        let raycaster, pointer, floorPlane, wallGroup;
        let sunLight, hemiLight;
        let sunMesh, moonMesh, celestialGroup;
        const gameClock = new THREE.Clock(); 
        
        // === [ä¿®æ”¹] æ—¶é—´ç³»ç»Ÿå˜é‡é‡æ„ ===
        // ç§»é™¤åŸæ¥çš„ gameTime å’Œ timeSpeed
        // let gameTime = 8.0; let timeSpeed = 0.2; 
        
        let visualHour = 8.0;     // è§†è§‰æ—¶é—´ (0-24)ï¼Œç”¨äºæ¸²æŸ“å¤©ç©º/å…‰ç…§
        let isTimeAuto = true;    // æ˜¯å¦è‡ªåŠ¨è·Ÿéšç°å®æ—¶é—´
        let lastRealTime = Date.now(); // ä¸Šä¸€å¸§çš„çœŸå®æ—¶é—´

        const moveKeys = { w: false, a: false, s: false, d: false };
        const loadedModels = {}; 
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        
        let mode = 'idle', ghostMesh = null, currentItemData = null, currentRotation = 0, canPlace = false;
        let selectedObject = null, selectionBox = null, editingObjectOriginalPos = null, editingObjectOriginalQuat = null;
        let longPressTimer = null, startPointer = new THREE.Vector2();
        
        const obstacles = []; const placedFurniture = []; const cats = []; 
        let heartScore = 500; let currentCategory = 'floor'; let activeDecorId = { floor: null, wall: null }; let skyPanels = []; 
        let pendingInteraction = null;
        let draggingCat = null; 

        // === [æ–°å¢] æ—¥è®°æ–‡æ¡ˆé…ç½® ===
const DIARY_CONFIG = {

                // [æ–°å¢] æ—¥è®°å¤´éƒ¨ä¿¡æ¯é…ç½®
            diary_meta: {
                weathers: [
                    "â˜€ï¸ é˜³å…‰æ­£å¥½ï¼Œé€‚åˆçƒ¤æ¯›",
                    "â˜ï¸ é˜´å¤©ï¼Œé€‚åˆå†¬çœ ",
                    "ğŸŒ§ï¸ ä¸‹é›¨äº†ï¼Œç¡ä¸ªå›ç¬¼è§‰",
                    "ğŸŒ¬ï¸ æœ‰é£ï¼Œé€‚åˆçª—è¾¹å·¡é€»",
                    "âœ¨ æ˜Ÿå…‰ç’€ç’¨ï¼Œå¤œé‡Œå¾ˆå®‰é™",
                    "ğŸŒ™ æœˆè‰²æœ¦èƒ§ï¼Œé€‚åˆæ‰“ç›¹",
                    "ğŸ”¥ å£ç‚‰å¾ˆæš–ï¼Œä¸æƒ³åŠ¨å¼¹"
                ],
                moods: [
                    "ğŸ˜ å¿ƒæƒ…ä¸€èˆ¬ï¼Œæ‡’å¾—ç†äºº",
                    "ğŸ˜Š å‹‰å¼ºæ»¡æ„ï¼Œèµä¸ªçœ¼ç¥",
                    "ğŸ˜  å……æ»¡æ€æ°”ï¼Œç”Ÿäººå‹¿è¿‘",
                    "ğŸ˜´ å›°æˆä¸€æ»©æ³¥ï¼Œå‹¿æ‰°",
                    "ğŸ˜» å¿ƒæƒ…æ„‰æ‚¦ï¼Œå¯ä»¥è´´è´´",
                    "ğŸ˜¡ æœ‰ç‚¹æš´èºï¼Œæ­£åœ¨æ€è€ƒäººç”Ÿ",
                    "ğŸŸ é¥¿å¾—ä¸¤çœ¼å‘å…‰ï¼Œåªæƒ³ç€é¥­"
                ],
                keywords: [
                    "#é‚£ä¸ªçº¢è‰²çš„å…‰ç‚¹", "#å¿«é€’ç®±", "#éš¾åƒçš„è¯ç‰‡", "#é€—çŒ«æ£’", 
                    "#çª—å¤–éº»é›€", "#æ²™å‘è·‘é…·", "#åˆåå°æ†©", "#äººç±»å¥´æ‰"
                ]
            },

            // [æ–°å¢] ç¦»çº¿äº‹ä»¶æ–‡æ¡ˆ
            offline_events: [
                {
                    weight: 20, // æ™®é€šç¦»çº¿äº‹ä»¶æƒé‡
                    type: 'normal',
                    text: [
                        "ä¸¤è„šå…½æ¶ˆå¤±çš„ç¬¬{hours}ä¸ªå°æ—¶ï¼Œçª—å¤–é‚£åªéº»é›€åˆæŒ‘è¡…äº†æˆ‘ä¸‰æ¬¡ï¼Œä½†é‚£æ˜¯æˆ‘ç•™ç»™æ™šä¸Šçš„æˆ˜æœ¯å‚¨å¤‡ã€‚",
                        "ç‹¬è‡ªåœ¨å®¶ï¼Œæˆ‘å·¡è§†äº†é¢†åœ°äº”æ¬¡ã€‚å—¯ï¼Œä¸€åˆ‡å®‰å¥½ï¼Œé™¤äº†é‚£ä¸ªè«åå…¶å¦™çš„ç¬”åˆæ‰åœ°ä¸Šäº†ã€‚",
                        "ç¡äº†ä¸€ä¸ªæ¼«é•¿çš„åˆè§‰ï¼Œé†’æ¥æ—¶å‘ç°å¤ªé˜³æ¢äº†ä¸ªåœ°æ–¹ï¼Œä¸¤è„šå…½è¿˜æ²¡å›æ¥ã€‚",
                        "æˆ‘å‡è£…åœ¨ç¡è§‰ï¼Œå·å·è§‚å¯Ÿäº†å‘¨å›´çš„ä¸€åˆ‡ã€‚è¿™ä¸ªæˆ¿é—´è—ç€å¾ˆå¤šç§˜å¯†ã€‚"
                    ]
                },
                {
                    weight: 50, // ç ´åäº‹ä»¶æƒé‡è¾ƒé«˜
                    type: 'damage_chance', // ç‰¹æ®Šç±»å‹ï¼Œåç»­å¯è§¦å‘ç ´ååŠ¨ç”»
                    text: [
                        "é‚£ä¸ªç»ç’ƒæ¯ç«™åœ¨æ¡Œè¾¹ç‘Ÿç‘Ÿå‘æŠ–ï¼Œä¸ºäº†å¸®å®ƒè§£è„±ï¼Œæˆ‘æ¨äº†å®ƒä¸€æŠŠã€‚å¬åˆ°äº†æ¸…è„†çš„å“å£°ï¼Œé‡åŠ›å­¦å®šå¾‹å†æ¬¡å¾—åˆ°äº†éªŒè¯ã€‚",
                        "æˆ‘è¯•å›¾ç»™æ²™å‘åšä¸ªæ–°çš„é€ å‹ï¼Œäºæ˜¯å¤šæŒ äº†å‡ ä¸‹ã€‚ä¸¤è„šå…½åº”è¯¥ä¼šå–œæ¬¢æˆ‘çš„æ–°è®¾è®¡ã€‚",
                        "èŠ±ç“¶é‡Œçš„èŠ±å¤ªç¢äº‹äº†ï¼Œæˆ‘å†³å®šå¸®å®ƒä»¬æ¢ä¸ªæ›´èˆ’æœçš„ä½ç½®â€”â€”åœ°æ¿ã€‚"
                    ]
                },
                {
                    weight: 10, // æä½æ¦‚ç‡çš„ç¥ç§˜äº‹ä»¶
                    type: 'mystery',
                    text: [
                        "å¢™è§’é‚£ä¸ªéšå½¢çš„å®¶ä¼™ä»Šå¤©åˆæ¥äº†ï¼Œæˆ‘å’Œå®ƒèŠäº†ä¸€ä¼šå„¿å…³äºé‡å­åŠ›å­¦çš„çœ‹æ³•ã€‚",
                        "å¯¹ç€ç©ºæ°”å«äº†å‡ å£°ï¼Œä¼¼ä¹å¬åˆ°äº†å›åº”ã€‚è¿™ä¸ªæˆ¿å­é‡Œä½ç€åˆ«çš„â€¦â€¦ä¸œè¥¿ï¼Ÿ",
                        "æˆ‘å‘ç°äº†ä¸€ä¸ªæ–°çš„å…‰æ–‘ï¼Œå®ƒåœ¨å¢™ä¸Šè·³èˆã€‚æˆ‘æ•çŒäº†å®ƒåŠå°æ—¶ã€‚"
                    ]
                }
            ],

            // [æ–°å¢] ç‰¹å®šç‰©å“çš„ä¸“ç”¨åæ§½ (key å¯¹åº” furniture ID)
            specific_items: {
                // [æ–°å¢] çŒ«é£Ÿç›†ä¸“ç”¨æ–‡æ¡ˆ
                'food_bowl': [
                    "é¢†åœ°é‡Œå¤šäº†ä¸€ä¸ªé¥­ç›†ã€‚ä½†æˆ‘æ£€æŸ¥è¿‡äº†ï¼Œé‡Œé¢æ˜¯ç©ºçš„ï¼è¿™æ˜¯åœ¨æŒ‘è¡…æˆ‘å—ï¼Ÿ",
                    "æ–°çš„é¥­ç›†ï¼Ÿé€ å‹å‹‰å‹‰å¼ºå¼ºï¼Œå¸Œæœ›èƒ½è£…å¾—ä¸‹æ›´å¤šçš„é«˜çº§ç½å¤´ã€‚",
                    "ä¸¤è„šå…½æ‘†æ”¾äº†ä¸€ä¸ªæ–°çš„ç¥­å›ï¼ˆé¥­ç›†ï¼‰ã€‚æˆ‘ä¼šåœ¨æ—è¾¹å®ˆç€ï¼Œç›´åˆ°ç¥­å“å‡ºç°ã€‚"
                ],

                // [æ–°å¢] çŒ«ç ‚ç›†ä¸“ç”¨æ–‡æ¡ˆ
                'litter_box': [
                    "åˆä¸€ä¸ªå•æ‰€ã€‚ä¸¤è„šå…½å¯¹æ”¶é›†æˆ‘çš„ç²‘ç²‘çœŸçš„å¾ˆæ‰§ç€ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¯¥é…åˆä¸€ä¸‹ï¼Ÿ",
                    "æ–°çš„æ²™ç›†ï¼Œè¸©ä¸Šå»è„šæ„Ÿä¸é”™ã€‚ä»Šæ™šå°±ç»™å®ƒå¼€å…‰ï¼Œç¡®ç«‹æˆ‘çš„é¢†åœŸæƒã€‚",
                    "è¿™æ˜¯æˆ‘çš„æ–°å†¥æƒ³å®¤ã€‚è¯·ä¸¤è„šå…½åœ¨æ¸…ç†ä¹‹å‰ä¿æŒè·ç¦»ã€‚",
                    "æ–°çš„å•æ‰€ï¼Ÿè™½ç„¶é€ å‹ä¸€èˆ¬ï¼Œä½†è„šæ„Ÿè¿˜ç®—å‡‘åˆã€‚å¸Œæœ›ä»–èƒ½ä¿æŒæ¸…ç†é¢‘ç‡ã€‚",
                    "è¿™æ˜¯æˆ‘çš„æ–°åŠå…¬å®¤ã€‚è¯·ä¸è¦åœ¨æˆ‘åŠå…¬ï¼ˆæ‹‰å±ï¼‰çš„æ—¶å€™ç›¯ç€æˆ‘çœ‹ã€‚"
                ],
                'ChrismasTree': [
                    "ä¸¤è„šå…½å¸¦å›äº†ä¸€æ£µå‘å…‰çš„æ ‘ï¼ˆåœ£è¯æ ‘ï¼‰ã€‚ä¸Šé¢çš„çƒçƒçœ‹èµ·æ¥å¾ˆå¥½åƒï¼Œæˆ‘å†³å®šä»Šæ™šçˆ¬ä¸Šå»æ‘˜ä¸€é¢—ã€‚",
                    "é‚£ä¸ªç»¿è‰²çš„å°–åˆºæ€ªç‰©ï¼ˆåœ£è¯æ ‘ï¼‰å é¢†äº†å®¢å…ã€‚æˆ‘è¯•å›¾åœ¨å®ƒè„šä¸‹å°¿å°¿ä»¥ç¤ºä¸»æƒï¼Œä½†è¢«é˜»æ­¢äº†ã€‚"
                ],
                'Television': [
                    "é‚£ä¸ªé»‘è‰²çš„æ¿å­ï¼ˆç”µè§†ï¼‰é‡Œæœ‰äººåœ¨åŠ¨ã€‚æˆ‘ç›¯ç€çœ‹äº†åŠå°æ—¶ï¼Œé‚£æ˜¯å¦ä¸€ä¸ªç»´åº¦çš„å…¥å£å—ï¼Ÿ",
                    "ä¸¤è„šå…½å¯¹ç€é‚£ä¸ªå‘å…‰çš„æ¿å­å‚»ç¬‘ã€‚ä¸ºäº†å”¤é†’ä»–ï¼Œæˆ‘æŒ¡åœ¨äº†å±å¹•æ­£ä¸­é—´ã€‚"
                ],
                'fireplace': [
                    "å¢™å£ä¸Šå¤šäº†ä¸€ä¸ªæ¸©æš–çš„æ´ï¼ˆå£ç‚‰ï¼‰ã€‚è¿™æ˜¯å®¶é‡Œå”¯ä¸€å€¼å¾—ç§°èµçš„è®¾æ–½ï¼Œé€‚åˆçƒ¤æˆ‘çš„è‚‰å«ã€‚",
                    "ç«å…‰åœ¨è·³èˆã€‚æˆ‘ç›¯ç€çœ‹äº†å¾ˆä¹…ï¼Œè§‰å¾—é‚£ä¸ªç«è‹—æ¯”é€—çŒ«æ£’èªæ˜å¤šäº†ã€‚"
                ],
                'cat_tree': [
                    "ç»ˆäºæœ‰ä¸ªèƒ½ä¿¯è§†ä¸¤è„šå…½çš„é«˜å°äº†ã€‚æœ•ç”šæ…°ã€‚",
                    "è¿™ä¸ªé«˜å¡”ï¼ˆçˆ¬æ¶ï¼‰æ˜¯å®¶é‡Œå”¯ä¸€ç¬¦åˆæˆ‘èº«ä»½çš„å®åº§ã€‚è™½ç„¶çˆ¬ä¸Šå»æœ‰ç‚¹ç´¯ã€‚"
                ],
                'window': [
                    "å¢™ä¸Šå¼€äº†ä¸ªæ´ï¼ˆçª—æˆ·ï¼‰ï¼Œä»Šå¤©ä¸Šæ¼”çš„æ˜¯ã€Šéº»é›€çš„è¯±æƒ‘ã€‹ï¼Œå‰§æƒ…å¾ˆç²¾å½©ã€‚",
                    "é‚£ä¸ªæ´ï¼ˆçª—æˆ·ï¼‰æ¼é£ï¼Œä½†ä¹Ÿæ¼è¿›æ¥é˜³å…‰ã€‚æˆ‘å‹‰ä¸ºå…¶éš¾åœ°åœ¨é‚£é‡Œç¡äº†ä¸€ä¸‹åˆã€‚"
                ]
            },
            
            // é€šç”¨å®¶å…· (ä¹°åœ°é¢å¤§ä»¶æ—¶è§¦å‘)
            buy_floor: [
                "é¢†åœ°é‡Œå‡ºç°äº†ä¸€ä¸ªå«ã€{item}ã€‘çš„åºç„¶å¤§ç‰©ã€‚å¥½åœ¨åŒ…è£…å®ƒçš„çº¸ç®±å­å¾ˆæ£’ï¼Œäº”æ˜Ÿå¥½è¯„ã€‚",
                "æ„šè ¢çš„ä¸¤è„šå…½å¸¦å›äº†ã€{item}ã€‘ï¼Œå ç”¨äº†æˆ‘å®è´µçš„è·‘é…·è·¯çº¿ã€‚ä¸è¿‡ç®±å­æˆ‘å¾ç”¨äº†ã€‚",
                "æ–°ç‹åº§ã€{item}ã€‘å‹‰å¼ºèƒ½åï¼Œä½†é‚£ä¸ªå¿«é€’ç®±æ‰æ˜¯æœ¬ä¸–çºªæœ€ä¼Ÿå¤§çš„å‘æ˜ï¼",
                "å®¶é‡Œè¶Šæ¥è¶ŠæŒ¤äº†ï¼Œéƒ½æ˜¯å› ä¸ºã€{item}ã€‘ã€‚å¦‚æœæˆ‘ç»Šå€’äº†ï¼Œéƒ½è¦æ€ªä¸¤è„šå…½ã€‚"
            ],
            // é€šç”¨å°ç‰© (ä¹°æ¡Œä¸Š/å¢™ä¸Šä¸œè¥¿è§¦å‘)
            buy_small: [
                "æ¡Œå­ä¸Šå¤šäº†ä¸ªã€{item}ã€‘ï¼Œç›®æµ‹æ¨ä¸‹å»çš„å£°éŸ³ä¼šå¾ˆæ¸…è„†ã€‚",
                "æ–°è´¡å“ã€{item}ã€‘ï¼Ÿæ‘†æ”¾çš„ä½ç½®æ¯«æ— ç¾æ„Ÿï¼Œä½†æˆ‘æ‡’å¾—çº æ­£ä»–ã€‚",
                "å¢™ä¸ŠæŒ‚äº†ä¸ªå¥‡æ€ªçš„ä¸œè¥¿ã€{item}ã€‘ï¼Œæˆ‘æƒ³è·³èµ·æ¥æŠŠå®ƒæŒ ä¸‹æ¥ï¼Œä»¥æ­¤æµ‹è¯•æˆ‘çš„å¼¹è·³åŠ›ã€‚"
            ],
            // å–‚é£Ÿ
            feed: [
                "è™½ç„¶æˆ‘ä¸é¥¿ï¼Œä½†ä¸ºäº†ä¸è®©ä»–è·ªåœ¨åœ°ä¸Šå“­ï¼Œæˆ‘å‹‰å¼ºåƒäº†ä¸€å£è´¡å“ã€‚",
                "ä»Šå¤©çš„ç½å¤´å¼€å¾—æ™šäº†3ç§’ï¼Œè¿™ç¬”è´¦æˆ‘è®°åœ¨å°æœ¬æœ¬ä¸Šäº†ã€‚",
                "ä¸¤è„šå…½å‘ˆä¸Šäº†å¾¡è†³ã€‚çœ‹åœ¨ä»–è¯šæƒ¶è¯šæçš„ä»½ä¸Šï¼Œèµè„¸åƒä¸€åŠå§ã€‚",
                "åƒé¥­æ˜¯çŒ«ç”Ÿå¤§äº‹ã€‚ä½†ä»–ç«™åœ¨æ—è¾¹çœ‹æˆ‘åƒæ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå˜æ€å—ï¼Ÿ"
            ],
            // é“²å±
            clean: [
                "ä»–åˆåœ¨å·æˆ‘çš„ä¾¿ä¾¿äº†ã€‚äººç±»è¿™ç§æ”¶è—ç™–çœŸæ˜¯ä»¤äººè´¹è§£ã€‚",
                "å•æ‰€ç»ˆäºæ¸…ç†äº†ã€‚ä½œä¸ºå¥–åŠ±ï¼Œæˆ‘ä»Šæ™šä¼šå¤šæ‹‰ä¸€ç‚¹è®©ä»–å¼€å¿ƒã€‚",
                "æ¯å½“ä»–åƒå¯»å®ä¸€æ ·æŒ–æ˜æ²™ç›†æ—¶ï¼Œæˆ‘éƒ½è§‰å¾—è¿™ä¸ªç‰©ç§æ²¡æ•‘äº†ã€‚"
            ],
            // æŠšæ‘¸ (å¿ƒæƒ…å¥½)
            pet_happy: [
                "æŠ€å¸ˆæ‰‹æ³•å°šå¯ï¼Œå…è®¸ä»–å¤šæ‘¸ä¸¤åˆ†é’Ÿã€‚",
                "ä»Šå¤©å¿ƒæƒ…ä¸é”™ï¼Œè®©ä»–æ‘¸ä¸¤ä¸‹ä¹Ÿæ²¡å…³ç³»ï¼Œå°±å½“æ–½èˆäº†ã€‚",
                "ç«Ÿç„¶çŸ¥é“æˆ‘è¦æŒ ä¸‹å·´ï¼Ÿè¿™ä¸ªå¥´æ‰ç»ˆäºå¼€çªäº†ã€‚",
                "å’•å™œå’•å™œâ€¦â€¦è¿™ä¸æ˜¯å› ä¸ºæˆ‘å–œæ¬¢ï¼Œåªæ˜¯å–‰å’™æœ‰ç‚¹ç—’ã€‚"
            ],
            // æŠšæ‘¸ (å¿ƒæƒ…å·®)
            pet_angry: [
                "ç«Ÿç„¶æ•¢åœ¨æˆ‘ä¸çˆ½çš„æ—¶å€™æ‘¸æˆ‘ï¼Ÿç»™äº†ä¸€çˆªå­ã€‚",
                "åˆ«ç¢°æˆ‘ï¼ä»Šå¤©çš„æ¯›å‘é€ å‹ä¸èƒ½ä¹±ï¼",
                "æ— è®ºæ˜¯è°ï¼Œç«Ÿæ•¢åœ¨è¿™ä¸ªæ—¶é—´æ‰“æ‰°æœ¬ç‹ï¼Œåˆ¤å¤„æ­»åˆ‘ï¼"
            ]
        };       
        
        // === 2. æ•°æ®åº“ ===
        const FURNITURE_DB = [
            { 
                id: 'food_bowl', name: 'çŒ«é£Ÿç›†', price: 50, type: 'functional', subType: 'food', color: 0xffffff,
                modelFile: 'FoodBowl_Empty.glb',      
                fullModelFile: 'FoodBowl_Full.glb',   
                modelScale: 0.3, fixBottom: true, size: {x:0.5, y:0.3, z:0.5}
            },
            { 
                id: 'litter_box', name: 'çŒ«ç ‚ç›†', price: 80, type: 'functional', subType: 'toilet', color: 0x888888,
                modelFile: 'LitterBox_Dirty.glb',    
                fullModelFile: 'LitterBox_Clean.glb',
                modelScale: 0.5, fixBottom: true, size: {x:1.0, y:0.4, z:1.0}
            },
            { id: 'rug',      type: 'floor', layer: 0, name: 'åœ†åœ°æ¯¯', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'RoundRug.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'rug_squre',type: 'floor', layer: 0, name: 'æ–¹åœ°æ¯¯', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'rug_squre.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'bed',      type: 'floor', layer: 1, name: 'çŒ«çª',   price: 40,  color: 0xe67e22, size: {x:1, y:0.5, z:0.8}, modelFile: 'bed.glb', modelScale: 0.8, canSleep: true, fixBottom: true },
            { id: 'sofa',     type: 'floor', layer: 1, name: 'å¤§æ²™å‘', price: 150, color: 0xe74c3c, size: {x:3, y:1, z:1},   modelFile: 'sofa.glb', modelScale: 2.0, canSleep: true, fixBottom: true },
            { id: 'ArmChair',     type: 'floor', layer: 1, name: 'æ‰¶æ‰‹æ¤…', price: 150, color: 0xe74c3c, size: {x:1.2, y:1, z:1.2},   modelFile: 'ArmChair.glb', modelScale: 1.0, canSleep: true, fixBottom: true },

            { id: 'cat_tree', type: 'floor', layer: 1, name: 'çŒ«çˆ¬æ¶', price: 100, color: 0x8e44ad, size: {x:1, y:1.8, z:1},   modelFile: 'cat_tree.glb', modelScale: 1.0 , fixBottom: true},
            // [ä¿®å¤] ä¹¦æ¶ï¼šæ·»åŠ  isSurface å’Œé«˜åº¦ (é«˜åº¦è®¾ä¸º2ï¼Œå³æ”¾åœ¨é¡¶ç«¯)
            { id: 'book_shelf', type: 'floor', layer: 1, name: 'ä¹¦æ¶', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'book_shelf.glb', modelScale: 1.0, fixBottom: true, isSurface: true, surfaceHeight: 2.0 },            { id: 'ColorBoxShelf', type: 'floor', layer: 1, name: 'ç›’å­æ¶å­', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'ColorBoxShelf.glb', modelScale: 1.0, fixBottom: true },
            { id: 'CafeTree', type: 'floor', layer: 1, name: 'å¤§ç›†æ ½', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'CafeTree.glb', modelScale: 1.0, fixBottom: true },
            { id: 'PottedGreenPlant', type: 'floor', layer: 1, name: 'å¤§ç›†æ ½', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'PottedGreenPlant.glb', modelScale: 1.0, fixBottom: true },
            { id: 'GreenPlant', type: 'floor', layer: 1, name: 'ç›†æ ½', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'GreenPlant.glb', modelScale: 1.0, fixBottom: true },
         
            { id: 'Television', type: 'floor', layer: 1, name: 'ç”µè§†', price: 100, color: 0x8e44ad, size: {x:1.9, y:1.5, z:0.8},   modelFile: 'Television.glb', modelScale: 1.0, fixBottom: true },
            { id: 'table',    type: 'floor', layer: 1, isSurface: true, surfaceHeight: 0.8, name: 'æœ¨æ¡Œ', price: 60,  color: 0x8d6e63, size: {x:1.5, y:0.6, z:1.5}, modelFile: 'table.glb', modelScale: 1.0, fixBottom: true },
{ 
                id: 'ChrismasTree',    
                type: 'floor', 
                layer: 1, 
                name: 'åœ£è¯æ ‘', 
                price: 100,  
                color: 0x8d6e63, 
                size: {x:1.5, y:2, z:1.5}, 
                modelFile: 'ChrismasTree2.glb', 
                modelScale: 1.5, 
                fixBottom: true,
                
                // [æ–°å¢] å…‰ç…§å±æ€§
                light: true, 
                lightType: 'point', 
                // å…‰æºä½ç½®ï¼šx=0, y=1.8(æ ‘é¡¶), z=0
                lightOffset: { x: 0, y: 1.8, z: 0 } 
            },            
            { id: 'fireplace',    type: 'floor', layer: 1, name: 'å£ç‚‰', price: 100,  color: 0x8d6e63, size: {x:1.5, y:1.5, z:1}, modelFile: 'fireplace.glb', modelScale: 1.8, fixBottom: true },
            { id: 'frigerator',    type: 'floor', layer: 1, name: 'å†°ç®±', price: 100,  color: 0x8d6e63, size: {x:1.5, y:1.5, z:1}, modelFile: 'frigerator.glb', modelScale: 1.0, fixBottom: true },

            { id: 'mug',      type: 'small', layer: 2, name: 'é©¬å…‹æ¯', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'mug.glb', modelScale: 0.2, fixBottom: true },
            { id: 'DalMug',      type: 'small', layer: 2, name: 'é©¬å…‹æ¯è“', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'DalMug.glb', modelScale: 0.8, fixBottom: true },
            { id: 'CoffeeCup',      type: 'small', layer: 2, name: 'å’–å•¡æ¯', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'CoffeeCup.glb', modelScale: 0.8, fixBottom: true },
            { 
                id: 'ChrismasTree_Small',      
                type: 'small', 
                layer: 2, 
                name: 'å°åœ£è¯æ ‘', 
                price: 5,   
                color: 0xffffff, 
                size: {x:0.3, y:0.3, z:0.3}, 
                modelFile: 'ChrismasTree_Small.glb', 
                modelScale: 1.0, 
                fixBottom: true,
                
                // [æ–°å¢] åŠ ä¸Šç‚¹å…‰æºï¼Œè®©å®ƒç…§äº®æ¡Œé¢
                light: true, 
                lightType: 'point', 
                // åç§»é‡æ ¹æ® size å¾®è°ƒï¼Œy=0.25 å¤§æ¦‚åœ¨æ ‘ä¸­é—´
                lightOffset: { x: 0, y: 0.25, z: 0 } 
            },
          
            { id: 'lamp',     type: 'small', layer: 2, name: 'å°ç¯',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'lamp.glb', modelScale: 1.0, fixBottom: true },
            { id: 'tiffany_lamp',     type: 'small', layer: 2, name: 'å°ç¯2',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'tiffany_lamp.glb', modelScale: 0.4, fixBottom: true },

            { id: 'floor_lamp',     type: 'small', layer: 2, name: 'è½åœ°ç¯',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'floor_lamp.glb', modelScale: 0.3, fixBottom: true, lightOffset: { x: 0, y: 1.8, z: 0 }  },
            { id: 'cutelamp',     type: 'small', layer: 2, name: 'è½åœ°ç¯2',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'cutelamp.glb', modelScale: 1.0, fixBottom: true, lightOffset: { x: 0, y: 1.8, z: 0 }  },
           
            { id: 'books',     type: 'small', layer: 2, name: 'ä¹¦',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4},  modelFile: 'books.glb', modelScale: 5.0, fixBottom: true },
            { id: 'wall_plant',    type: 'wall',  layer: 1, name: 'å£æŒ‚è—¤', price: 20,  color: 0x2ecc71, size: {x:2, y:0.5, z:0.5}, modelFile: 'wall_plant.glb', modelScale: 0.8 },
            { id: 'painting', type: 'wall',  layer: 1, name: 'é£æ™¯ç”»', price: 50,  color: 0xFFD700, size: {x:1, y:1, z:0.1}, modelFile: 'painting.glb', modelScale: 1.0 },
            { id: 'curtain', type: 'wall', layer: 1, name: 'çª—å¸˜', price: 80, color: 0xFFFFFF, size: {x:2.0, y:2.0, z:0.5}, modelFile: 'curtain.glb', modelScale: 1.5, autoCenter: true, allowOverlap: true },
            { id: 'wall_star', type: 'wall', layer: 1, name: 'æ˜Ÿæ˜ŸæŒ‚é¥°', price: 30, color: 0xFFFF00, size: {x:0.5, y:0.5, z:0.5}, modelFile: 'WallDecorate_Star.glb', modelScale: 1.0, autoCenter: true, allowOverlap: true },
            { id: 'ChrismaxSock', type: 'wall', layer: 1, name: 'åœ£è¯è¢œ', price: 30, color: 0xFFFF00, size: {x:0.5, y:0.5, z:0.5}, modelFile: 'ChrismaxSock.glb', modelScale: 1.0, autoCenter: true, allowOverlap: true },
            { id: 'CorkBorad', type: 'wall', layer: 1, name: 'å¢™å£è£…é¥°', price: 30, color: 0xFFFF00, size: {x:0.5, y:0.5, z:0.5}, modelFile: 'CorkBorad.glb', modelScale: 1.0, autoCenter: true, allowOverlap: true },
          
            { id: 'window',   type: 'wall',  layer: 1, name: 'å¤§çª—', price: 120, color: 0x87CEEB, size: {x:1.8, y:1.8, z:0.2}, light: true, lightType: 'spot', modelFile: 'window_large.glb', autoCenter: true, modelScale: 1, manualOffset: { x: 0, y: 0, z: 0 } },
            { id: 'window2', type: 'wall',  layer: 1, name: 'çª—2', price: 120, color: 0x87CEEB, size: {x:1.8, y:2, z:0.2}, light: true, lightType: 'spot', modelFile: 'Window2.glb', modelScale: 1, autoCenter: true },
            { id: 'floor_wood', type: 'decor', name: 'æœ¨çº¹åœ°æ¿', price: 50, color: 0x8d6e63, decorType: 'floor', textureFile: 'WoodenFloor.jpg' }, 
            { id: 'floor_tile', type: 'decor', name: 'ç™½ç“·ç –',   price: 50, color: 0xdbc2a3, decorType: 'floor' },
            { id: 'wall_pink',  type: 'decor', name: 'æ¸©é¦¨ç²‰å¢™', price: 50, color: 0xc9a2a6, decorType: 'wall' },
            { id: 'wall_blue',  type: 'decor', name: 'æ¸…çˆ½è“å¢™', price: 50, color: 0xb3e5fc, decorType: 'wall' },
            { id: 'wall_blueWooden',  type: 'decor', name: 'è“è‰²æœ¨å¢™', price: 50, color: 0xc9a2a6, decorType: 'wall',  textureFile: 'BlueWooden.jpg' },
            { id: 'MintWallpaper',  type: 'decor', name: 'è–„è·å¢™çº¸', price: 50, color: 0xc9a2a6, decorType: 'wall',  textureFile: 'MintWallpaper.jpg' },
            { id: 'floor_default', type: 'decor', name: 'ç»å…¸ç±³è‰²', price: 0, color: 0xF5F5DC, decorType: 'floor' },
            { id: 'wall_default',  type: 'decor', name: 'ç»å…¸æš–ç°', price: 0, color: 0xEBE5D1, decorType: 'wall' },
        ];

        // === 3. è¾…åŠ©å‡½æ•° ===
        function setDomText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; else console.warn(`Element #${id} not found`); }
        window.closeDialog = function() { document.getElementById('confirm-dialog').style.display = 'none'; pendingInteraction = null; }
        
        function showConfirmDialog(title, msg, onYes) {
            setDomText('dialog-title', title); setDomText('dialog-msg', msg);
            document.getElementById('confirm-dialog').style.display = 'block';
            const yesBtn = document.getElementById('btn-confirm-yes'); const newBtn = yesBtn.cloneNode(true); yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.onclick = () => { onYes(); window.closeDialog(); };
        }

        // [ä¿®æ”¹] çŠ¶æ€æ›´æ–°å‡½æ•°ï¼šä¸å†æ˜¾ç¤ºåœ¨å±å¹•å·¦ä¾§ï¼Œè€Œæ˜¯å‘é€åˆ°ç³»ç»Ÿæ—¥å¿—
        function updateStatusText(text, type) {
            // 1. å®šä¹‰æ—¥å¿—ç±»å‹é¢œè‰²
            let logType = 'info';
            if (type === 'invalid') logType = 'error'; // çº¢å­—
            else if (type === 'valid') logType = 'warn'; // é»„å­—/ç»¿å­—

            // 2. è°ƒç”¨å…¨å±€çš„æ—¥å¿—å‡½æ•° (å®šä¹‰åœ¨ head é‡Œçš„é‚£ä¸ª)
            // è¿™æ · "èµ„æºåŠ è½½å®Œæ¯•" å’Œ "è°ƒè¯•æ¨¡å¼: å¼€å¯" éƒ½ä¼šè¿›å…¥æ—¥å¿—é¢æ¿
            if (typeof window.logToScreen === 'function') {
                logToScreen(text, logType);
            } else {
                console.log(text);
            }
        }

        function updateMoney(amt) { 
            heartScore += amt; 
            setDomText('heart-text-display', heartScore); // ä¿®æ”¹ID
            refreshShopState();
            gameSaveManager.saveGame(); 
        }

        function refreshShopState() { 
            // é‡æ–°éå†æ‰€æœ‰å¡ç‰‡ï¼Œæ›´æ–° disabled çŠ¶æ€
            const cards = document.querySelectorAll('.item-card');
            // è¿™é‡Œæ¯”è¾ƒéº»çƒ¦ï¼Œå› ä¸º DOM é‡Œæ²¡å­˜ priceã€‚
            // ç®€å•ç²—æš´ç‚¹ï¼šç›´æ¥é‡ç»˜æ•´ä¸ªåˆ—è¡¨
            renderShopItems(currentCategory);
        }
       
        function spawnHeart(pos) { const v=pos.clone(); v.y+=1; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='heart-float'; e.innerText='â¤ +5'; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); updateMoney(5); setTimeout(()=>e.remove(),1500); }
        function showEmote(pos,t) { const v=pos.clone(); v.y+=1.2; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='emote-bubble'; e.innerText=t; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); setTimeout(()=>e.remove(),1000); }

        // [å‡çº§ç‰ˆ] æè´¨ä¼˜åŒ–å‡½æ•°ï¼šèµ‹äºˆæ¨¡å‹"åŠ¨æ£®"èˆ¬çš„ç£¨ç ‚è´¨æ„Ÿ
        function sanitizeMaterial(child) {
            if (child.isMesh) {
                child.castShadow = true; 
                child.receiveShadow = true;

                if (child.material.map) child.material.map.colorSpace = THREE.SRGBColorSpace;
                
                // ç‰¹æ®Šå¤„ç†ç»ç’ƒ/çª—æˆ·
                const isGlass = child.name.toLowerCase().includes('glass') || child.name.toLowerCase().includes('window');
                
                child.material.metalness = 0.0; // å‡ ä¹æ— é‡‘å±æ„Ÿï¼ˆåƒç²˜åœŸ/å¡‘æ–™ï¼‰
                child.material.roughness = 0.7; // é«˜ç²—ç³™åº¦ï¼Œå‡å°‘é”åˆ©åå…‰ï¼Œå¢åŠ æŸ”å’Œæ„Ÿ

                if (isGlass) { 
                    child.material.transparent = true; 
                    child.material.opacity = 0.3; 
                    child.material.color.setHex(0x88ccff); 
                    child.material.roughness = 0.1; // ç»ç’ƒå…‰æ»‘
                    child.material.metalness = 0.8; 
                } else { 
                    child.material.transparent = false; 
                    child.material.opacity = 1.0; 
                }
                child.material.needsUpdate = true;
            }
        }

        function loadAssets(callback) {
            const files = [];
            files.push({ key: 'cat', path: './assets/models/cat.glb' });
            files.push({ key: 'box', path: './assets/models/cardboardBoxOpen.glb' });
            FURNITURE_DB.forEach(i => { 
                if(i.modelFile) files.push({ key: i.id, path: './assets/models/'+i.modelFile }); 
                if(i.fullModelFile) files.push({ key: i.fullModelFile, path: './assets/models/'+i.fullModelFile });
            });

            if(files.length===0) { callback(); return; }
            let count = 0;
            const progressFill = document.getElementById('progress-fill');
            const loadingScreen = document.getElementById('loading-screen');
            logToScreen(`Start loading ${files.length} assets...`);
            
            files.forEach(f => {
                const isObj = f.path.toLowerCase().endsWith('.obj');
                const l = isObj ? objLoader : gltfLoader;
                l.load(f.path, (data) => {
                    const sceneData = isObj ? data : data.scene;
                    const anims = isObj ? [] : data.animations;
                    sceneData.traverse(sanitizeMaterial);
                    loadedModels[f.key] = { scene: sceneData, animations: anims };
                    count++; check();
                }, undefined, (err)=>{ 
                    console.warn("Missing asset:", f.path); 
                    logToScreen(`Failed to load: ${f.path}`, 'warn'); 
                    count++; check(); 
                });
            });
            function check() {
                if(progressFill) progressFill.style.width = Math.floor((count/files.length)*100)+'%';
                if(count===files.length) { 
                    logToScreen("Assets loading finished.");
                    setTimeout(()=>{ if(loadingScreen) loadingScreen.remove(); callback(); }, 500); 
                }
            }
        }

        // [ä¿®å¤] è¡¥å› Decor å‡½æ•°
        function applyDecorVisuals(item) {
            const setMaterial = (mesh, config) => {
                if (config.textureFile) {
                    textureLoader.load('./assets/textures/' + config.textureFile, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace; tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                        if (config.decorType === 'floor') tex.repeat.set(4, 4); else tex.repeat.set(2, 1);
                        mesh.material.map = tex; mesh.material.color.setHex(0xffffff); mesh.material.needsUpdate = true;
                    }, undefined, (err) => {console.error("Failed to load texture:", config.textureFile, err);});
                } else { mesh.material.map = null; mesh.material.color.setHex(config.color); mesh.material.needsUpdate = true; }
            };
            if (item.decorType === 'floor') setMaterial(floorPlane, item);
            else if (item.decorType === 'wall') wallGroup.forEach(wall => setMaterial(wall, item));
        }
        function restoreDecorState(type) { const currentId = activeDecorId[type]; if (currentId) { const item = FURNITURE_DB.find(i => i.id === currentId); if (item) applyDecorVisuals(item); } else { const def = DEFAULT_DECOR[type]; applyDecorVisuals({ decorType: type, color: def.color, textureFile: def.texture }); } }



        function prepareModel(item) {
            let sceneData = null;
            if (loadedModels[item.id]) sceneData = loadedModels[item.id].scene;
            else if (item.modelFile && loadedModels[item.modelFile]) sceneData = loadedModels[item.modelFile].scene;

            if (!sceneData) return null;

            const raw = sceneData.clone();
            raw.traverse(sanitizeMaterial);
            if (item.fixBottom) { const box = new THREE.Box3().setFromObject(raw); raw.position.y = -box.min.y; }
            if (item.autoCenter) { const box = new THREE.Box3().setFromObject(raw); const c = new THREE.Vector3(); box.getCenter(c); raw.position.x -= c.x; raw.position.y -= c.y; raw.position.z -= c.z; }
            if (item.manualOffset) { raw.position.x += (item.manualOffset.x || 0); raw.position.y += (item.manualOffset.y || 0); raw.position.z += (item.manualOffset.z || 0); }
            
            raw.scale.set(1,1,1); 

            const group = new THREE.Group();
            group.add(raw);



            const s = item.modelScale || 1.0; 
            group.scale.set(s, s, s);

            // === [æ–°å¢] åœ£è¯æ ‘ä¸“å±ï¼šè®©è£…é¥°å“å‘å…‰ ===
// === [ä¿®å¤] åœ£è¯æ ‘å‘å…‰é€»è¾‘ (å¤§æ ‘+å°æ ‘) ===
            if (item.id === 'ChrismasTree' || item.id === 'ChrismasTree_Small') {
                group.traverse((child) => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();

                        // å…³é”®è¯åŒ¹é…ï¼šæ˜Ÿæ˜Ÿã€ç¯ã€å½©å¸¦ã€é“ƒé“›ã€çƒã€ç¤¼ç‰©
                        let isDecoration = (
                            name.includes('star') || 
                            name.includes('light') || 
                            name.includes('ribbon') || 
                            name.includes('bell') ||
                            name.includes('ball') ||
                            name.includes('present') ||
                            name.includes('dec')
                        );

                        // [æ–°å¢] ç‰¹æ®Šè¡¥ä¸ï¼šå°åœ£è¯æ ‘çš„åå­—å« "Bowl"ï¼Œå¼ºåˆ¶è®©å®ƒä¹Ÿç®—ä½œè£…é¥°
                        if (item.id === 'ChrismasTree_Small' && name.includes('bowl')) {
                            isDecoration = true;
                        }

                        // æ’é™¤é€»è¾‘ï¼šæ ‘å¹²æ ‘å¶ä¸å‘å…‰ (é’ˆå¯¹å¤§æ ‘)
                        const isTreeParts = (
                            name.includes('leaf') || 
                            name.includes('tree') || 
                            name.includes('bark') ||
                            name.includes('trunk')
                        );

                        if (isDecoration && !isTreeParts) {
                            child.material.emissive = new THREE.Color(0xffffff);
                            
                            // ç»§æ‰¿è´´å›¾é¢œè‰² (é‡‘æ˜Ÿå‘é‡‘å…‰ï¼Œç»¿å¶å‘ç»¿å…‰)
                            if (child.material.map) {
                                child.material.emissiveMap = child.material.map;
                            } else {
                                child.material.emissive = child.material.color;
                            }

                            child.material.emissiveIntensity = 0.75; 
                            child.material.toneMapped = false; 
                        } else {
                            child.material.emissiveIntensity = 0;
                            child.material.toneMapped = true;
                        }
                    }
                });
            }
            // ==========================================




            return group;
        }

        // === 4. ç®±å­é€»è¾‘ ===
        // [ä¿®å¤] ç®±å­ç”Ÿæˆé€»è¾‘ï¼šä½¿ç”¨ Box3 è¿›è¡Œä¸¥æ ¼ç¢°æ’æ£€æµ‹
        function spawnMysteryBox(sourceItem) {
            let x, z, attempts = 0;
            const boxSize = 0.6; // ç®±å­å¤§æ¦‚å°ºå¯¸
            
            do {
                x = (Math.random() - 0.5) * 8; // æ‰©å¤§ä¸€ç‚¹èŒƒå›´
                z = (Math.random() - 0.5) * 8; 
                attempts++;

                // åˆ›å»ºå€™é€‰ç®±å­çš„åŒ…å›´ç›’
                const candidateBox = new THREE.Box3();
                candidateBox.min.set(x - boxSize/2, 0, z - boxSize/2);
                candidateBox.max.set(x + boxSize/2, 1, z + boxSize/2);

                // æ£€æµ‹ä¸ç°æœ‰å®¶å…·çš„ç¢°æ’
                var collision = placedFurniture.some(f => {
                    const fBox = new THREE.Box3().setFromObject(f);
                    //ç¨å¾®ç¼©å°å®¶å…·åˆ¤å®šèŒƒå›´(expandByScalar(-0.1))ï¼Œå…è®¸ç´§è´´ä½†é‡å 
                    return candidateBox.intersectsBox(fBox.expandByScalar(-0.1));
                });

            } while (collision && attempts < 50);

            if (collision) {
                 // å¦‚æœå°è¯•50æ¬¡éƒ½æ‰¾ä¸åˆ°ç©ºåœ°ï¼Œå°±ä¸ç”Ÿæˆäº†ï¼Œé¿å…å¡æ­»
                 return; 
            }

            let boxMesh; let isTall = false; let realHeight = 0.5;
            if (loadedModels['box']) {
                const raw = loadedModels['box'].scene.clone(); raw.traverse(sanitizeMaterial);
                const box3_raw = new THREE.Box3().setFromObject(raw); const center = new THREE.Vector3(); box3_raw.getCenter(center); raw.position.sub(center); 
                boxMesh = new THREE.Group(); boxMesh.add(raw);
                let sx = 0.5, sy = 0.5, sz = 0.5;
                // æ ¹æ®æ¥æºå®¶å…·è°ƒæ•´ç®±å­å¤§å°
                if (sourceItem && sourceItem.size) {
                    // ç¨å¾®æŠŠç®±å­åšå¤§ä¸€ç‚¹ç‚¹
                    let tx = Math.max(0.6, sourceItem.size.x * 1.0); 
                    let ty = Math.max(0.4, sourceItem.size.y * 1.0); 
                    let tz = Math.max(0.6, sourceItem.size.z * 1.0);
                    if (sourceItem.id.includes('rug')) ty = 0.3;
                    
                    const box3 = new THREE.Box3().setFromObject(raw); const baseSize = new THREE.Vector3(); box3.getSize(baseSize);
                    sx = baseSize.x > 0.01 ? tx / baseSize.x : 1; sy = baseSize.y > 0.01 ? ty / baseSize.y : 1; sz = baseSize.z > 0.01 ? tz / baseSize.z : 1;
                }
                raw.scale.set(sx, sy, sz); isTall = sy > sx * 1.5 || sy > sz * 1.5; if (isTall) raw.rotation.x = Math.PI / 2; raw.updateMatrix(); 
                const finalBox = new THREE.Box3().setFromObject(raw); raw.position.y -= finalBox.min.y; realHeight = finalBox.max.y - finalBox.min.y;
            } else {
                let size = { x: 0.6, y: 0.5, z: 0.6 }; const boxGeo = new THREE.BoxGeometry(size.x, size.y, size.z); const boxMat = new THREE.MeshStandardMaterial({ color: 0xcd853f });
                boxMesh = new THREE.Mesh(boxGeo, boxMat); boxMesh.position.y = size.y / 2; realHeight = size.y;
            }
            boxMesh.position.set(x, 0, z); boxMesh.rotation.y = Math.random() * Math.PI * 2;
            boxMesh.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            scene.add(boxMesh); 
            const boxDbItem = { id: 'mystery_box', name: "å¿«é€’ç®±", price: 0, type: 'floor', layer: 1 };
            const boxFurnitureInstance = new Furniture(boxMesh, boxDbItem); boxFurnitureInstance.isBox = true; boxFurnitureInstance.isTipped = isTall; boxFurnitureInstance.boxHeight = realHeight;
            placedFurniture.push(boxMesh); showEmote(boxMesh.position, 'ğŸ“¦');
        }

        // === 5. ç¯å¢ƒä¸ç±» ===
        function addSkyBacking(mesh, size) {
            const width = size.x * 0.85; const height = size.y * 0.85;
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({ color: 0xe0f7fa }));
            const zPos = -size.z / 2 + 0.05; plane.position.set(0, 0, zPos); plane.rotation.set(0, 0, 0); plane.userData = { isSky: true };
            mesh.add(plane); skyPanels.push(plane);
        }

        // [ä¿®æ”¹] å¤©ç©ºé¢œè‰²é€»è¾‘ï¼šå»¶é•¿æ—¥å‡ºå’Œæ—¥è½çš„è¿‡æ¸¡æ—¶é—´
        function getSkyColor(gameTime) {
            // å®šä¹‰é¢œè‰²
            const nightColor = SKY_COLORS.night;
            const dawnColor = SKY_COLORS.dawn;
            const dayColor = SKY_COLORS.day;
            const duskColor = SKY_COLORS.dusk;

            // 1. æ·±å¤œ (20:00 - 05:00)
            if (gameTime >= 20 || gameTime < 5) {
                return nightColor;
            }
            // 2. æœé˜³è¿‡æ¸¡æœŸ (05:00 - 09:00, æŒç»­4å°æ—¶)
            else if (gameTime >= 5 && gameTime < 9) {
                const ratio = (gameTime - 5) / 4; // 0.0 ~ 1.0
                return nightColor.clone().lerp(dawnColor, ratio);
            }
            // 3. æ—©ä¸Šè¿‡æ¸¡åˆ°ç™½å¤© (09:00 - 10:00, å¿«é€Ÿè¿‡æ¸¡ï¼Œé˜²æ­¢ç™½å¤©å¤ªç²‰)
            else if (gameTime >= 9 && gameTime < 10) {
                 const ratio = (gameTime - 9) / 1;
                 return dawnColor.clone().lerp(dayColor, ratio);
            }
            // 4. æ­£åˆç™½å¤© (10:00 - 15:00)
            else if (gameTime >= 10 && gameTime < 15) {
                return dayColor;
            }
            // 5. ç™½å¤©è¿‡æ¸¡åˆ°å¤•é˜³ (15:00 - 17:00)
            else if (gameTime >= 15 && gameTime < 17) {
                 const ratio = (gameTime - 15) / 2;
                 return dayColor.clone().lerp(duskColor, ratio);
            }
            // 6. å¤•é˜³æ™šéœ (17:00 - 20:00, æŒç»­3å°æ—¶)
            else if (gameTime >= 17 && gameTime < 20) {
                const ratio = (gameTime - 17) / 3;
                return duskColor.clone().lerp(nightColor, ratio);
            }
            
            return nightColor; // Fallback
        }

        // [ä¿®å¤] ç¯å¢ƒæ›´æ–°å‡½æ•°ï¼šåªè´Ÿè´£æ›´æ–°æ•°æ®å’ŒUIï¼Œä¸ç»‘å®šäº‹ä»¶
        function updateEnvironment(dt) {
            const now = new Date();
            
            // 1. è·å–çœŸå®æ—¶é—´
            const realHour = now.getHours();
            const realMin = now.getMinutes();
            
            // 2. ç¡®å®šè§†è§‰æ—¶é—´ (visualHour)
            if (isTimeAuto) {
                // è‡ªåŠ¨æ¨¡å¼ï¼šè§†è§‰æ—¶é—´ = çœŸå®æ—¶é—´
                visualHour = realHour + realMin / 60.0;
                
                // åŒæ­¥ HUD æ»‘å—
                const hudSlider = document.getElementById('time-slider-hud');
                if (hudSlider && document.activeElement !== hudSlider) hudSlider.value = visualHour;
            } 

                        // 3. [ä¿®æ”¹] æ›´æ–°æ–°ç‰ˆ HUD UI
            const displayH = realHour;
            
            // æ ¼å¼åŒ– 12å°æ—¶åˆ¶ AM/PM
            const ampm = displayH >= 12 ? 'PM' : 'AM';
            const hour12 = displayH % 12 || 12; 
            
            setDomText('time-text-display', `${hour12}:${realMin.toString().padStart(2,'0')}`);
            setDomText('time-ampm', ampm);
            
            // æ›´æ–°å¤©æ°”å›¾æ ‡ (åˆ‡æ¢ src)
            const weatherIcon = document.getElementById('weather-icon-img');
            if(weatherIcon) {
                const isDay = (displayH >= 6 && displayH < 18);
                // å‡è®¾ä½ æœ‰ icon_sun.png å’Œ icon_moon.png
                const targetIcon = isDay ? './assets/ui/icon_sun.png' : './assets/ui/icon_moon.png';
                if (!weatherIcon.src.includes(targetIcon)) weatherIcon.src = targetIcon;
            }

            // 4. æ¸²æŸ“å¤©ç©ºä¸å…‰ç…§ (ä¿æŒä¸å˜)
            const skyColor = getSkyColor(visualHour); 
            scene.background = skyColor; 
            document.body.style.backgroundColor = `rgb(${skyColor.r*255},${skyColor.g*255},${skyColor.b*255})`;
            skyPanels.forEach(panel => { panel.material.color.copy(skyColor); });
            
            const angle = (visualHour - 12) / 12 * Math.PI; 
            const radius = 80; 
            const sunX = Math.sin(angle) * radius; 
            const sunY = Math.cos(angle) * radius;
            
            if (sunMesh && moonMesh) { 
                sunMesh.position.set(sunX, sunY, -20); 
                moonMesh.position.set(-sunX, -sunY, -20); 
                sunMesh.visible = true; moonMesh.visible = true; 
            }
            
            // å…‰ç…§å¼ºåº¦é€»è¾‘ (å¤ç”¨ Phase 1.0 çš„é€»è¾‘)
            const isDaytime = (visualHour >= 6 && visualHour < 18);

            if (isDaytime) { 
                let intensityFactor = 1.0;
                if (visualHour < 9) intensityFactor = (visualHour - 6) / 3; 
                else if (visualHour > 15) intensityFactor = (18 - visualHour) / 3;
                
                if (intensityFactor < 0.1) intensityFactor = 0.1;

                sunLight.intensity = 3.5 * intensityFactor; 
                sunLight.position.set(sunX, sunY, 10); 
                hemiLight.intensity = 0.5 + (1.0 * intensityFactor); 
                
                placedFurniture.forEach(f => { const light = f.children.find(c => c.isLight); if (light) light.visible = false; }); 
            } else { 
                sunLight.intensity = 0; 
                hemiLight.intensity = 0.6; 
                placedFurniture.forEach(f => { const light = f.children.find(c => c.isLight); if (light) light.visible = true; }); 
            }
        }

        // === [æ–°å¢] åæœŸå¤„ç†é€»è¾‘ ===
        let composer;

        function initPostProcessing() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            composer = new EffectComposer(renderer);
            
            // 1. åŸºç¡€åœºæ™¯æ¸²æŸ“
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // 2. SSAO (ç¯å¢ƒå…‰é®è”½) - å¢åŠ è§’è½é˜´å½±å’Œç«‹ä½“æ„Ÿ
            // å®ƒæ˜¯ Zelda/åŠ¨æ£®é£æ ¼çš„å…³é”®ï¼Œè®©ç‰©ä½“"è½åœ°"è€Œä¸æ˜¯é£˜ç€
            const saoPass = new SAOPass(scene, camera, false, true);
            saoPass.params.output = 0; 
            saoPass.params.saoBias = 0.5;
            saoPass.params.saoIntensity = 0.05; // é˜´å½±å¼ºåº¦ï¼Œè¶Šå¤§çº¦é»‘
            saoPass.params.saoScale = 100;
            saoPass.params.saoKernelRadius = 30;
            composer.addPass(saoPass);

            // 3. Bloom (è¾‰å…‰) - è®©ç¯å…‰å’Œçª—æˆ·æœ‰æŸ”å’Œå…‰æ™•
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.95; // æé«˜é˜ˆå€¼ï¼šåªæœ‰çœŸæ­£çš„ç¯æ³¡ã€çª—æˆ·é«˜å…‰æ‰ä¼šå‘å…‰ï¼Œåœ°æ¿ä¸å‘å…‰
            bloomPass.strength = 0.15;  // é™ä½å¼ºåº¦ï¼šé˜²æ­¢ç”»é¢å¤ªâ€œä»™â€ï¼Œå˜å¾—æ¸…æ™°
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            // 4. SMAA (æŠ—é”¯é½¿) - æ¶ˆé™¤é”¯é½¿è¾¹ç¼˜
            const smaaPass = new SMAAPass(width, height);
            composer.addPass(smaaPass);

            // 5. Output (è‰²å½©è¾“å‡º) - ç¡®ä¿è‰²å½©ç©ºé—´æ­£ç¡®
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        // === [æ–°å¢] åæœŸå¤„ç†é€»è¾‘ç»“æŸ ===

        class Furniture {
            constructor(mesh, dbItem) {
                this.mesh = mesh; this.dbItem = dbItem; this.mesh.userData.parentClass = this; 
                this.functionalState = null; this.isBox = false; this.modelEmpty = null; this.modelFull = null;
                if (this.dbItem.type === 'functional') { this.initFunctionalState(); }
            }

            initFunctionalState() {
                if (this.mesh.children.length > 0) { this.modelEmpty = this.mesh.children[0]; }
                if (this.dbItem.fullModelFile) {
                    const fullItemConfig = { ...this.dbItem, id: this.dbItem.id + '_full', modelFile: this.dbItem.fullModelFile };
                    const fullGroup = prepareModel(fullItemConfig);
                    if (fullGroup) {
                        this.modelFull = fullGroup.children[0]; 
                        this.mesh.add(this.modelFull); 
                    } else {
                        logToScreen(`Warning: Full model missing: ${this.dbItem.fullModelFile}`, 'error');
                    }
                }
                
                if (this.dbItem.subType === 'food') this.functionalState = 'full';
                else if (this.dbItem.subType === 'toilet') this.functionalState = 'clean';
                
                this.updateVisuals();
            }

            updateVisuals() {
                if (!this.modelEmpty) return;
                const setVis = (emptyVis, fullVis) => {
                    this.modelEmpty.visible = emptyVis;
                    if(this.modelFull) this.modelFull.visible = fullVis;
                }
                if (this.dbItem.subType === 'food') {
                    this.functionalState === 'full' ? setVis(false, true) : setVis(true, false);
                } else if (this.dbItem.subType === 'toilet') {
                    this.functionalState === 'clean' ? setVis(false, true) : setVis(true, false);
                }
            }

            interact() {
                const needsRefill = (this.dbItem.subType === 'food' && this.functionalState === 'empty') || 
                                    (this.dbItem.subType === 'toilet' && this.functionalState === 'dirty');

                if (needsRefill) {
                    let title = this.dbItem.subType === 'food' ? "è¡¥å……çŒ«ç²®?" : "æ¸…ç†çŒ«ç ‚?";
                    showConfirmDialog(title, "éœ€è¦æ¶ˆè€— 10 çˆ±å¿ƒ", () => {
                        this.confirmRefill();
                    });
                    return true;
                }
                return false;
            }

            confirmRefill() {
                if (heartScore >= 10) {
                    updateMoney(-10);


                    if (this.dbItem.subType === 'food') {
                        this.functionalState = 'full'; 
                        showEmote(this.mesh.position, 'ğŸš'); 
                        updateStatusText("çŒ«ç²®å·²åŠ æ»¡");
                        diaryManager.logEvent('feed', {}, 50); 

                    } else {
                        this.functionalState = 'clean'; 
                        showEmote(this.mesh.position, 'âœ¨'); 
                        updateStatusText("çŒ«ç ‚ç›†å·²æ¸…ç†");
                        // [ä¿®æ”¹] è°ƒç”¨ logEventï¼Œç»™é“²å±ä¸€ä¸ªæƒé‡
                        diaryManager.logEvent('clean', {}, 50); 
                    }
                    this.updateVisuals();
                    gameSaveManager.saveGame(); // ä¹Ÿè¦å­˜ç›˜

                } else {
                    alert("çˆ±å¿ƒä¸è¶³ï¼");
                }
                gameSaveManager.saveGame();


            }

            useByCat() {
                if (this.dbItem.subType === 'food' && this.functionalState === 'full') {
                    this.functionalState = 'empty'; this.updateVisuals(); showEmote(this.mesh.position, 'ğŸ˜‹');
                } else if (this.dbItem.subType === 'toilet' && this.functionalState === 'clean') {
                    this.functionalState = 'dirty'; this.updateVisuals(); showEmote(this.mesh.position, 'ğŸ’©');
                }

                gameSaveManager.saveGame();
            }
        }

        // [é‡æ„] æ—¥è®°ç®¡ç†å™¨ï¼šåŠ å…¥ç¦»çº¿äº‹ä»¶ä¸æƒé‡ç­›é€‰
        class DiaryManager {
            constructor() {
                this.storageKey = 'cat_game_diary_v1';
                this.entries = {}; // ç»“æ„: { "YYYY-MM-DD": { meta: {}, events: [] } }
                this.eventCooldowns = {};
                this.viewingDate = new Date();
                
                this.MAX_ENTRIES_PER_DAY = 10; // [æ–°å¢] æ¯æ—¥æ—¥è®°ä¸Šé™

                this.load();
                this.init(); // [æ–°å¢] åœ¨æ„é€ å‡½æ•°ä¸­è°ƒç”¨åˆå§‹åŒ–ï¼Œå¤„ç†ç¦»çº¿äº‹ä»¶
            }

            // [æ–°å¢] åˆå§‹åŒ–é€»è¾‘ï¼šå¤„ç†ç¦»çº¿äº‹ä»¶
            init() {
                const now = Date.now();
                const lastLogin = localStorage.getItem('last_login_time');
                
                if (lastLogin) {
                    const lastLoginTime = parseInt(lastLogin);
                    const offlineDurationHours = (now - lastLoginTime) / (1000 * 60 * 60);

                    if (offlineDurationHours >= 1) { // è‡³å°‘ç¦»çº¿1å°æ—¶æ‰è¡¥ç®—
                        // [æ–°å¢] ç¦»çº¿äº‹ä»¶è¡¥ç®—
                        this.generateOfflineEvents(offlineDurationHours);
                    }
                }
                localStorage.setItem('last_login_time', now.toString()); // æ›´æ–°ä¸Šæ¬¡ç™»å½•æ—¶é—´
            }

            formatDateKey(date) {
                return `${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2,'0')}-${date.getDate().toString().padStart(2,'0')}`;
            }

            // [è¡¥å›ç¼ºå¤±çš„å‡½æ•°]
            getTodayKey() { 
                return this.formatDateKey(new Date()); 
            }

            getTimeString() {
                const now = new Date();
                return `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
            }

            // [ä¿®å¤] è¯»å–å­˜æ¡£ (å¢åŠ æ—§æ•°æ®å…¼å®¹)
            load() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try { 
                        this.entries = JSON.parse(saved); 
                        
                        // æ£€æŸ¥æ•°æ®æ ¼å¼æ˜¯å¦ä¸º V4 æ–°ç‰ˆç»“æ„
                        // å¦‚æœ entries çš„æŸä¸ª value æ˜¯æ•°ç»„ï¼ˆæ—§ç‰ˆï¼‰ï¼Œåˆ™å¼ºåˆ¶é‡ç½®æˆ–å‡çº§
                        // è¿™é‡Œç®€å•ç²—æš´ï¼šå¦‚æœå‘ç°æ—§æ•°æ®ï¼Œç›´æ¥æ¸…ç©ºï¼ˆåæ­£è¿˜åœ¨å¼€å‘é˜¶æ®µï¼‰
                        const keys = Object.keys(this.entries);
                        if (keys.length > 0) {
                            const firstVal = this.entries[keys[0]];
                            if (Array.isArray(firstVal)) { // æ—§ç‰ˆç»“æ„æ˜¯æ•°ç»„
                                console.warn("Detected old diary format, resetting...");
                                this.entries = {}; // æ¸…ç©ºæ—§æ•°æ®ï¼Œé˜²æ­¢æŠ¥é”™
                            }
                        }
                    } 
                    catch(e) { console.error("Diary load failed", e); this.entries = {}; }
                }
            }

            save() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.entries));
            }

            // [æ–°å¢] æ·»åŠ åŸå§‹äº‹ä»¶åˆ°â€œå¾…å¤„ç†æ± â€ï¼Œä¸ç›´æ¥å†™å…¥
            // äº‹ä»¶æƒé‡ï¼šæåº¦ä¸æ»¡100, å·¨å¤§æˆå°±80, ç‰¹æ®Šäº’åŠ¨60, æ—¥å¸¸20, ç¥ç§˜10
            pendingEvents = []; // æš‚å­˜æ± 

            logEvent(eventType, params = {}, weight = 20) { // é»˜è®¤æƒé‡ 20
                // 1. å†·å´æ£€æŸ¥
                const cooldownTime = eventType.startsWith('pet') ? 10 * 60 * 1000 : 60 * 1000;
                const now = Date.now();
                if (this.eventCooldowns[eventType] && (now - this.eventCooldowns[eventType] < cooldownTime)) return;
                this.eventCooldowns[eventType] = now;

                // 2. ç”Ÿæˆæ–‡æ¡ˆ (ä¾ç„¶æ”¯æŒç‰¹å®šID)
                let text = '';
                if (params.id && DIARY_CONFIG.specific_items[params.id]) {
                    const specifics = DIARY_CONFIG.specific_items[params.id];
                    text = specifics[Math.floor(Math.random() * specifics.length)];
                    weight = Math.max(weight, 60); // ç‰¹å®šç‰©å“äº‹ä»¶æƒé‡æ›´é«˜
                } else {
                    const templates = DIARY_CONFIG[eventType];
                    if (!templates || templates.length === 0) return;
                    text = templates[Math.floor(Math.random() * templates.length)];
                    if (params.item) text = text.replace('{item}', params.item);
                }

                // 3. å°†äº‹ä»¶æ¨å…¥å¾…å¤„ç†æ± 
                this.pendingEvents.push({
                    time: this.getTimeString(),
                    type: 'interaction', // é»˜è®¤ä¸ºäº¤äº’äº‹ä»¶
                    text: text,
                    weight: weight,
                    rawType: eventType // è®°å½•åŸå§‹ç±»å‹ç”¨äºåç»­å¤„ç†
                });
            }

            // [æ–°å¢] ç¦»çº¿äº‹ä»¶ç”Ÿæˆé€»è¾‘
            generateOfflineEvents(offlineDurationHours) {
                const numEvents = Math.min(3, Math.floor(offlineDurationHours / 2)); // æ¯2å°æ—¶ç”Ÿæˆ1ä¸ªï¼Œæœ€å¤š3ä¸ª
                if (numEvents === 0) return;

                updateStatusText(`æ£€æµ‹åˆ°ç¦»çº¿ ${offlineDurationHours.toFixed(1)} å°æ—¶ï¼Œæ­£åœ¨ç”Ÿæˆæ—¥è®°...`);
                
                for (let i = 0; i < numEvents; i++) {
                    let eventPool = DIARY_CONFIG.offline_events;
                    
                    // éšæœºæŠ½å–äº‹ä»¶ (å¸¦æƒé‡)
                    let totalWeight = eventPool.reduce((sum, e) => sum + e.weight, 0);
                    let randomPoint = Math.random() * totalWeight;
                    
                    let chosenEvent = null;
                    for (const event of eventPool) {
                        randomPoint -= event.weight;
                        if (randomPoint <= 0) {
                            chosenEvent = event;
                            break;
                        }
                    }

                    if (chosenEvent) {
                        const text = chosenEvent.text[Math.floor(Math.random() * chosenEvent.text.length)];
                        // æ›¿æ¢ç¦»çº¿æ—¶é•¿
                        const final_text = text.replace('{hours}', offlineDurationHours.toFixed(1));
                        
                        this.pendingEvents.push({
                            time: this.getTimeString(), // ç¦»çº¿äº‹ä»¶æ—¶é—´æˆ³ç”¨å½“å‰ç™»å½•æ—¶é—´
                            type: 'offline',
                            text: final_text,
                            weight: chosenEvent.weight,
                            rawType: 'offline_event'
                        });
                    }
                }
            }


            // [æ–°å¢] å°†å¾…å¤„ç†äº‹ä»¶å†™å…¥æ¯æ—¥æ—¥è®°ï¼ˆå¸¦æƒé‡ç­›é€‰å’Œä¸Šé™ï¼‰
            flushPendingEvents() {
                if (this.pendingEvents.length === 0) return;

                const key = this.getTodayKey();
                if (!this.entries[key]) {
                    this.entries[key] = {
                        meta: this.generateDailyMeta(), // ç”Ÿæˆæ—¥è®°å¤´éƒ¨å…ƒæ•°æ®
                        events: []
                    };
                }
                
                let currentDayEntries = this.entries[key].events;
                
                // 1. åˆå¹¶å¾…å¤„ç†äº‹ä»¶åˆ°å½“å‰æ—¥æœŸçš„äº‹ä»¶åˆ—è¡¨ä¸­
                // æˆ‘ä»¬ä¸ç›´æ¥æ¸…ç©º pendingEventsï¼Œè€Œæ˜¯æ¯æ¬¡éƒ½é‡æ–°ç­›é€‰ä¸€éæ‰€æœ‰äº‹ä»¶
                // è¿™æ ·å¯ä»¥ç¡®ä¿ä¼˜å…ˆçº§æœ€é«˜çš„äº‹ä»¶æ°¸è¿œè¢«è®°å½•
                
                currentDayEntries.push(...this.pendingEvents);
                this.pendingEvents = []; // æ¸…ç©ºå¾…å¤„ç†æ± 

                // 2. æŒ‰æƒé‡æ’åº
                currentDayEntries.sort((a, b) => b.weight - a.weight);

                // 3. å»é‡ (æ›´æ™ºèƒ½çš„å»é‡ï¼ŒåŸºäºå†…å®¹)
                const uniqueEntries = [];
                const seenTexts = new Set();
                for (const entry of currentDayEntries) {
                    if (!seenTexts.has(entry.text)) {
                        uniqueEntries.push(entry);
                        seenTexts.add(entry.text);
                    }
                }
                currentDayEntries = uniqueEntries;

                // 4. è£å‰ªåˆ°æœ€å¤§æ¡ç›®æ•°
                if (currentDayEntries.length > this.MAX_ENTRIES_PER_DAY) {
                    currentDayEntries = currentDayEntries.slice(0, this.MAX_ENTRIES_PER_DAY);
                }
                
                this.entries[key].events = currentDayEntries; // æ›´æ–°æ—¥è®°
                this.save();
                this.updateUIHint(true);
            }

            // [æ–°å¢] ç”Ÿæˆæ¯æ—¥å…ƒæ•°æ® (å¤©æ°”ã€å¿ƒæƒ…ã€å…³é”®è¯)
            generateDailyMeta() {
                const metaConfig = DIARY_CONFIG.diary_meta;
                return {
                    weather: metaConfig.weathers[Math.floor(Math.random() * metaConfig.weathers.length)],
                    mood: metaConfig.moods[Math.floor(Math.random() * metaConfig.moods.length)],
                    keyword: metaConfig.keywords[Math.floor(Math.random() * metaConfig.keywords.length)]
                };
            }


            // [ä¿®æ”¹] æ¸²æŸ“å½“å‰æŸ¥çœ‹é¡µé¢çš„æ—¥è®°
            renderPage() {
                const container = document.getElementById('diary-entries');
                const dateTitle = document.getElementById('diary-date-title'); 
                const weatherMeta = document.getElementById('diary-weather');
                const moodMeta = document.getElementById('diary-mood');

                const key = this.formatDateKey(this.viewingDate);
                const dayEntry = this.entries[key];
                const list = dayEntry ? dayEntry.events : [];

                // [ä¿®å¤] å¢åŠ å¯¹ meta æ˜¯å¦å­˜åœ¨çš„æ£€æŸ¥
                if (dateTitle) dateTitle.innerText = key;
                
                // æ£€æŸ¥ dayEntry.meta æ˜¯å¦å­˜åœ¨ï¼Œé˜²æ­¢æŠ¥é”™
                const hasMeta = dayEntry && dayEntry.meta;
                if (weatherMeta) weatherMeta.innerText = hasMeta ? dayEntry.meta.weather : 'æš‚æ— è®°å½•';
                if (moodMeta) moodMeta.innerText = hasMeta ? dayEntry.meta.mood : 'å¿ƒæƒ…éšç¬”';

                container.innerHTML = ''; 

                if (list.length === 0) {
                    container.innerHTML = '<div class="entry empty-tip">è¿™ä¸€å¤©çŒ«å’ªå¾ˆæ‡’ï¼Œæ²¡æœ‰ç•™ä¸‹è®°å½•...</div>';
                    return;
                }

                list.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'entry';
                    div.innerHTML = `<div class="entry-time">${item.time}</div><div class="entry-text">${item.text}</div>`;
                    container.appendChild(div);
                });
            }
            // [è¡¥å›ç¼ºå¤±çš„å‡½æ•°]
            updateUIHint(hasNew) {
                const dot = document.getElementById('diary-red-dot-hud'); // ä¿®æ”¹ID
                if(dot) dot.style.display = hasNew ? 'block' : 'none';
            }
            
            clearAll() {
                this.entries = {};
                this.save();
                // å¦‚æœå½“å‰æ­£å¥½å¼€ç€æ—¥è®°ï¼Œåˆ·æ–°ä¸€ä¸‹é¡µé¢
                const modal = document.getElementById('diary-modal');
                if (modal && !modal.classList.contains('hidden')) {
                    this.renderPage();
                }
            }
        }


        // === [æ–°å¢] æ¸¸æˆå­˜æ¡£ç®¡ç†å™¨ ===
        class GameSaveManager {
            constructor() {
                this.saveKey = 'cat_game_save_v1';
                // è‡ªåŠ¨ä¿å­˜é—´éš” (30ç§’)
                setInterval(() => this.saveGame(), 30000);
            }

            // æ”¶é›†å½“å‰æ¸¸æˆæ•°æ®å¹¶ä¿å­˜
            saveGame() {
                if (!cats[0]) return; // è¿˜æ²¡åˆå§‹åŒ–å¥½

                const saveData = {
                    // 1. åŸºç¡€æ•°æ®
                    heartScore: heartScore,
                    activeDecor: activeDecorId, // è£…ä¿®çŠ¶æ€
                    
                    // 2. çŒ«å’ªçŠ¶æ€ (åªå­˜ä¸€åª)
                    catStats: {
                        hunger: cats[0].stats.hunger,
                        toilet: cats[0].stats.toilet,
                        // ç”šè‡³å¯ä»¥å­˜ä½ç½®ï¼Œä½†ä¸ºäº†ç®€å•ï¼Œä¸‹æ¬¡ç™»å½•é‡ç½®ä½ç½®æ¯”è¾ƒå®‰å…¨
                    },

                    // 3. å®¶å…·åˆ—è¡¨
                    furniture: placedFurniture.map(f => {
                        const p = f.userData.parentClass;
                        return {
                            id: p.dbItem.id, // æ ¸å¿ƒID
                            pos: { x: f.position.x, y: f.position.y, z: f.position.z },
                            rot: { y: f.rotation.y },
                            // å¦‚æœæ˜¯åŠŸèƒ½æ€§å®¶å…·ï¼Œå­˜çŠ¶æ€ (full/empty)
                            funcState: p.functionalState, 
                            // æ ‡è®°æ˜¯å¦æ˜¯ç®±å­ (è™½ç„¶ç®±å­ä¸€èˆ¬ä¸å­˜ï¼Œä½†å¦‚æœä¸ºäº†ä¿ç•™ä¹Ÿè¦å­˜)
                            isBox: p.isBox,
                            isTipped: p.isTipped,
                            boxHeight: p.boxHeight
                        };
                    })
                };

                localStorage.setItem(this.saveKey, JSON.stringify(saveData));
                console.log("Game Saved:", saveData);
            }

            // è¯»å–å¹¶æ¢å¤æ¸¸æˆ
            loadGame() {
                const json = localStorage.getItem(this.saveKey);
                if (!json) return false; // æ²¡æœ‰å­˜æ¡£

                try {
                    const data = JSON.parse(json);
                    
                    // 1. æ¢å¤é‡‘é’±
                    if (data.heartScore !== undefined) {
                        heartScore = data.heartScore;
                        setDomText('heart-text-display', heartScore);
                    }

                    // 2. æ¢å¤è£…ä¿® (åœ°æ¿/å¢™å£)
                    if (data.activeDecor) {
                        activeDecorId = data.activeDecor;
                        if (activeDecorId.floor) {
                            const item = FURNITURE_DB.find(i => i.id === activeDecorId.floor);
                            if (item) applyDecorVisuals(item);
                        }
                        if (activeDecorId.wall) {
                            const item = FURNITURE_DB.find(i => i.id === activeDecorId.wall);
                            if (item) applyDecorVisuals(item);
                        }
                    }

                    // 3. æ¢å¤çŒ«å’ªçŠ¶æ€ (éœ€è¦ç­‰çŒ«ç”Ÿæˆåè°ƒç”¨ï¼Œè¿™é‡Œå…ˆå­˜ä¸ªä¸´æ—¶å˜é‡ï¼Œæˆ–è€…æ‰‹åŠ¨èµ‹å€¼)
                    // æ›´å¥½çš„æ–¹å¼æ˜¯ï¼šloadGame è¿”å›æ•°æ®ï¼Œç”± startGame åˆ†å‘
                    return data;

                } catch (e) {
                    console.error("Save file corrupted", e);
                    return false;
                }
            }
        }
        
        const gameSaveManager = new GameSaveManager();

        class Cat {
            constructor(scene, color) {
                this.scene = scene; 
                this.state = 'idle'; 
                this.stats = { hunger: 80, toilet: 80 };
                this.targetFurniture = null; this.nextAction = null; 
                this.bubbleEl = document.getElementById('cat-bubble'); this.bubbleIcon = document.getElementById('bubble-icon');
                this.targetPos = new THREE.Vector3(); this.stopPos = new THREE.Vector3(); 
                this.jumpStart = new THREE.Vector3(); this.jumpEnd = new THREE.Vector3();   
                this.interactTarget = null; this.timer = 0; this.mixer = null; this.actions = {}; this.isAnimated = false;
                this.petCount = 0; this.patience = 5 + Math.floor(Math.random() * 6); this.angryTime = 0; 
                this.sleepMinDuration = 0; 

                this.mesh = new THREE.Group(); this.scene.add(this.mesh); 
                this.downRay = new THREE.Raycaster(); this.downRay.ray.direction.set(0,-1,0); 
                this.forwardRay = new THREE.Raycaster();

                try {
                    if (loadedModels['cat']) {
                        const model = SkeletonUtils.clone(loadedModels['cat'].scene);
                        model.scale.set(CAT_CONFIG.scale, CAT_CONFIG.scale, CAT_CONFIG.scale);
                        model.position.y = CAT_CONFIG.yOffset; model.rotation.x = CAT_CONFIG.rotateX; model.rotation.y = CAT_CONFIG.rotateY;
                        this.mesh.add(model);
                        if (loadedModels['cat'].animations.length > 0) {
                            this.isAnimated = true; this.mixer = new THREE.AnimationMixer(model);
                            const anims = loadedModels['cat'].animations; 
                            const getAnim = (idx) => anims[idx] || anims[0];
                            this.actions['sleep'] = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.sleep));
                            this.actions['happy'] = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.happy));
                            this.actions['idle']  = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.idle));
                            this.actions['eat']   = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.eat));
                            this.actions['urgent']= this.mixer.clipAction(getAnim(CAT_CONFIG.anim.urgent));
                            this.actions['walk']  = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.walk));
                            this.actions['sleep'].setLoop(THREE.LoopOnce); 
                            this.actions['sleep'].clampWhenFinished = true;
                            this.playAction('idle');
                            
                            logToScreen(`Cat loaded with ${anims.length} animations.`);
                            if (anims.length < 8) logToScreen("Warning: Cat model has fewer than 8 animations!", 'warn');
                        }
                    } else { this.mesh.add(this.createBlockCat(color)); }
                } catch (e) { console.error("Cat error:", e); this.mesh.add(this.createBlockCat(color)); }
                this.mesh.position.set(0, 0, 0); this.chooseNewAction(); 
            }
            createBlockCat(color) { const g=new THREE.Group(); const m=new THREE.MeshStandardMaterial({color:color}); const b=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.6),m); b.position.y=0.15; g.add(b); const h=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.3,0.3),m); h.position.set(0,0.4,0.4); g.add(h); return g; }
            showBubble(icon) { if (!this.bubbleEl || !this.bubbleIcon) return; this.bubbleIcon.innerText = icon; this.bubbleEl.classList.remove('hidden'); }
            hideBubble() { if (!this.bubbleEl) return; this.bubbleEl.classList.add('hidden'); }
            updateBubblePosition() { if (!this.bubbleEl || this.bubbleEl.classList.contains('hidden')) return; const pos = this.mesh.position.clone(); pos.y += 1.2; pos.project(camera); const x = (pos.x * .5 + .5) * window.innerWidth; const y = (-(pos.y * .5) + .5) * window.innerHeight; this.bubbleEl.style.left = `${x}px`; this.bubbleEl.style.top = `${y}px`; }
updateUI() { 
                // [ä¿®æ”¹] é€‚é…æ–°ç‰ˆ HUD (å®¹å™¨è£å‰ªæ³•)
                const hungerLevel = document.getElementById('level-hunger');
                const toiletLevel = document.getElementById('level-toilet');
                
                // ç›´æ¥ç”¨ height ç™¾åˆ†æ¯”
                // 100% = æ»¡ (å®¹å™¨é«˜åº¦å æ»¡ Mask)
                // 0%   = ç©º (å®¹å™¨é«˜åº¦ä¸º0ï¼Œå›¾ç‰‡çœ‹ä¸è§)
                if(hungerLevel) {
                    hungerLevel.style.height = this.stats.hunger + '%';
                }
                if(toiletLevel) {
                    toiletLevel.style.height = this.stats.toilet + '%';
                }
            }
            
            playAction(name) { 
                if(this.isAnimated && this.actions[name] && this.currentAction !== this.actions[name]) { 
                    if(this.currentAction) this.currentAction.fadeOut(0.2); 
                    this.actions[name].reset().fadeIn(0.2).play(); 
                    this.currentAction = this.actions[name]; 
                } 
            }

            // [ä¿®æ”¹] Update (åœ¨é†’æ¥æ—¶è®°å½• lastInteractTargetï¼Œå¹¶æ”¯æŒæ‹–æ‹½çŠ¶æ€)
            update(dt) {
                if(this.isAnimated && this.mixer) this.mixer.update(dt);
                this.decayStats(dt); this.updateBubblePosition(); this.updateUI();

                // [æ–°å¢] æ‹–æ‹½çŠ¶æ€ï¼šä»€ä¹ˆéƒ½ä¸åšï¼Œä½ç½®ç”±é¼ æ ‡æ§åˆ¶
                if (this.state === 'dragged') {
                    return;
                }

                if (this.state === 'sleeping') {
                    this.sleepMinDuration -= dt;
                    if ((this.stats.hunger < 5 || this.stats.toilet < 5) || this.sleepMinDuration <= 0) {
                         
                         // [æ–°å¢] é†’æ¥æ—¶ï¼Œè®°å½•è¿™å¼ åºŠï¼Œä¸‹æ¬¡åˆ«é©¬ä¸Šç¡å®ƒ
                         this.lastInteractTarget = this.interactTarget;

                         this.state = 'idle'; this.sleepMinDuration = 0;
                         this.hideBubble(); 
                         this.resetModelOffset(); 
                         this.trySpawnHeart(); // ä½¿ç”¨æ–°æ–¹æ³•

                         this.chooseNewAction(); 
                    }
                    return; 
                }

                // ... ä»¥ä¸‹ä¿æŒåŸæœ‰çš„ç‰©ç†ä¸ç§»åŠ¨é€»è¾‘ ...
                if (this.state !== 'jumping') {
                    const rayOrigin = this.mesh.position.clone(); rayOrigin.y = 5; this.downRay.set(rayOrigin, new THREE.Vector3(0,-1,0));
                    const hitCandidates = [floorPlane, ...placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem && f.userData.parentClass.dbItem.layer === 1 && !f.userData.parentClass.isBox)];
                    const hits = this.downRay.intersectObjects(hitCandidates, true); let targetY = 0; if(hits.length > 0) targetY = hits[0].point.y;
                    this.mesh.position.y += (targetY - this.mesh.position.y) * 0.2;
                }
                
                if(this.interactTarget && (!placedFurniture.includes(this.interactTarget) || !this.interactTarget.visible)) { this.interrupt(); return; }
                if (this.state === 'angry') { if (Date.now() > this.angryTime) { this.state = 'idle'; this.patience = 5 + Math.floor(Math.random() * 6); this.petCount = 0; updateStatusText("çŒ«å’ªæ°”æ¶ˆäº†"); } }
                
                if(this.state === 'walking') { this.handleWalkingLogic(dt); } 
                else if (this.state === 'jumping') { this.updateJumping(dt); } 
                else if(this.state === 'idle') { this.handleIdleLogic(dt); } 
                else if(this.state === 'interacting') { this.handleInteractingLogic(dt); } 
                else if(this.state === 'petting') { this.playAction('happy'); } 
                else if (this.state === 'begging') { 
                    this.playAction('happy'); 
                    this.checkIfNeedsSatisfied(); 
                    this.mesh.lookAt(camera.position.x, this.mesh.position.y, camera.position.z); 
                }
            }

            handleIdleLogic(dt) {
                this.playAction('idle'); 
                if (this.stats.hunger < 30) 
                { 
                    const foodBowl = this.findAvailableFurniture('food', 'full'); 
                    if (foodBowl) 
                    { 
                        this.targetFurniture = foodBowl; 
                        this.setPath(foodBowl.userData.parentClass.mesh.position, 0.95); 
                        this.state = 'walking'; 
                        this.nextAction = 'EAT'; this.hideBubble(); return; } else { this.showBubble('ğŸŸ'); this.state = 'begging'; return; } }
                if (this.stats.toilet < 40) { const litterBox = this.findAvailableFurniture('toilet', 'clean'); if (litterBox) { this.targetFurniture = litterBox; this.setPath(litterBox.userData.parentClass.mesh.position); this.state = 'walking'; this.nextAction = 'POOP'; this.hideBubble(); return; } else { this.showBubble('ğŸ’©'); this.state = 'begging'; return; } }
                this.timer -= dt; if(this.timer <= 0) this.chooseNewAction();
            }

            handleWalkingLogic(dt) {
                this.playAction('walk'); 
                const dir = new THREE.Vector3().subVectors(this.stopPos, this.mesh.position); 
                dir.y = 0; 
                const dist = dir.length();
                
                // 1. ç¢°æ’æ£€æµ‹
                if (dist > 0.5) { 
                    const forwardDir = dir.clone().normalize(); 
                    this.forwardRay.set(this.mesh.position.clone().add(new THREE.Vector3(0,0.3,0)), forwardDir); 
                    
                    const obstacleMeshes = placedFurniture.filter(f => {
                        // å…³é”®ï¼šè¡Œèµ°æ—¶ï¼Œç»å¯¹ä¸è¦æŠŠè‡ªå·±è¦å»çš„ç›®æ ‡å½“æˆéšœç¢ç‰©ï¼
                        // å¦åˆ™çŒ«ä¼šè¿˜æ²¡èµ°åˆ°ï¼Œå°±æ£€æµ‹åˆ°é¥­ç›†çš„ç¢°æ’ç›’ï¼Œç„¶ååœä¸‹æ¥
                        const isInteractTarget = (this.interactTarget && f === this.interactTarget);
                        const isFoodTarget = (this.targetFurniture && f === this.targetFurniture);
                        const isDecor = (f.userData.parentClass && f.userData.parentClass.dbItem.layer === 0);
                        return !isInteractTarget && !isFoodTarget && !isDecor;
                    });

                    const cols = this.forwardRay.intersectObjects(obstacleMeshes, true); 
                    // å¢åŠ åˆ¤å®šè·ç¦»ï¼Œé¿å…è¿‡äºæ•æ„Ÿ
                    if(cols.length > 0 && cols[0].distance < 0.4) { 
                        this.chooseNewAction(); 
                        return; 
                    } 
                }

                // 2. åˆ°è¾¾æ£€æµ‹
                if (dist < 0.1) { 
                    // [æ–°å¢] å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœç¦»ç›®æ ‡å®¶å…·çš„å®é™…ä¸­å¿ƒè¿˜å¾ˆè¿œï¼Œè¯´æ˜æ˜¯"å‡åˆ°è¾¾" (å¯èƒ½æ˜¯StopPosè®¡ç®—é”™äº†)
                    if (this.targetFurniture) {
                        const distToRealTarget = new THREE.Vector3().subVectors(this.targetFurniture.position, this.mesh.position);
                        distToRealTarget.y = 0;
                        // å¦‚æœç¦»ä¸­å¿ƒç‚¹è¶…è¿‡ 1.5ç±³ï¼Œè¯´æ˜åœå¾—å¤ªè¿œäº†ï¼Œå¯èƒ½æ˜¯è¢«å¡ä½äº†æˆ–è€…è®¡ç®—é”™è¯¯
                        // è¿™ç§æƒ…å†µä¸‹ï¼Œå¼ºåˆ¶ç¬ç§»è¿‡å» (æˆ–è€…ç»§ç»­èµ°)
                        if (distToRealTarget.length() > 1.5) {
                            // å¼ºåˆ¶ä¿®æ­£ä½ç½®åˆ°åœæ­¢ç‚¹ (ç¬ç§»ä¿®å¤)
                            this.mesh.position.x = this.stopPos.x;
                            this.mesh.position.z = this.stopPos.z;
                        }
                    }
                    this.onArriveDest(); 
                } else { 
                    dir.normalize(); 
                    this.mesh.position.add(dir.multiplyScalar(2.0 * dt)); 
                    this.mesh.lookAt(this.stopPos.x, this.mesh.position.y, this.stopPos.z); 
                }
            }

            // [æ–°å¢] è¾…åŠ©ï¼šæ¢å¤æ¨¡å‹é»˜è®¤ä½ç½®ï¼ˆç”¨äºä¿®æ­£ç¡è§‰åç§»ï¼‰
            resetModelOffset() {
                if(this.mesh.children.length > 0) {
                    this.mesh.children[0].position.x = 0; // å‡è®¾é»˜è®¤æ˜¯0
                    // ä¿æŒYè½´ (CAT_CONFIG.yOffset å¯èƒ½ä¼šç”¨åˆ°ï¼Œè¿™é‡Œç®€å•å‡è®¾å½’é›¶æˆ–ä¿ç•™åŸé€»è¾‘)
                    // å¦‚æœåŸæ¨¡å‹æœ‰ç‰¹å®šyOffsetï¼Œæœ€å¥½åœ¨è¿™é‡Œè¯»å– CAT_CONFIG.yOffset
                    // æ ¹æ®ä»£ç ä¸Šä¸‹æ–‡: model.position.y = CAT_CONFIG.yOffset
                    this.mesh.children[0].position.y = CAT_CONFIG.yOffset || 0;
                    this.mesh.children[0].position.z = 0;
                }
            }


            // [ä¿®æ”¹] äº¤äº’é€»è¾‘ (ä¹Ÿä½¿ç”¨ trySpawnHeart)
            handleInteractingLogic(dt) {
                const isInsideBox = this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox && !this.interactTarget.userData.parentClass.isTipped;
                if (isInsideBox) { this.playAction('sleep'); } else { this.playAction('idle'); } 
                
                this.timer -= dt; 
                
                if(this.timer <= 0) { 
                    // [æ–°å¢] è®°å½•åˆšæ‰ç©è¿‡çš„ä¸œè¥¿
                    this.lastInteractTarget = this.interactTarget;

                    // ä½¿ç”¨æ–°æ–¹æ³•
                    this.trySpawnHeart();

                    if (isInsideBox) { this.mesh.position.copy(this.jumpStart); this.mesh.position.y = 0; } 
                    this.leaveInteraction(); 
                }
            }


            startJump() { this.state = 'jumping'; this.playAction('idle'); this.jumpTimer = 0; this.jumpDuration = 0.6; this.jumpStart.copy(this.mesh.position); this.jumpEnd.copy(this.interactTarget.position); let h = this.interactTarget.userData.parentClass.boxHeight || 0.5; this.jumpEnd.y = h * 0.5; if (this.jumpEnd.y < 0.2) this.jumpEnd.y = 0.2; }
            updateJumping(dt) {
                this.jumpTimer += dt; let t = this.jumpTimer / this.jumpDuration; if (t > 1) t = 1;
                this.mesh.position.x = THREE.MathUtils.lerp(this.jumpStart.x, this.jumpEnd.x, t); this.mesh.position.z = THREE.MathUtils.lerp(this.jumpStart.z, this.jumpEnd.z, t);
                const height = this.jumpEnd.y + 0.5; const yBase = THREE.MathUtils.lerp(this.jumpStart.y, this.jumpEnd.y, t); const yArc = Math.sin(t * Math.PI) * height; this.mesh.position.y = yBase + yArc; this.mesh.lookAt(this.jumpEnd.x, this.mesh.position.y, this.jumpEnd.z);
                if (t >= 1) { this.mesh.rotation.x = 0; this.mesh.rotation.z = 0; this.enterInteraction(); }
            }

            // [æ–°å¢] æ£€æŸ¥å¹¶äº§ç”Ÿçˆ±å¿ƒ (è§£å†³é—®é¢˜3)
            trySpawnHeart() {
                // å¦‚æœé¥¿æ­»æˆ–æ†‹åäº†ï¼Œå°±ä¸ç»™çˆ±å¿ƒ
                if (this.stats.hunger <= 0 || this.stats.toilet <= 0) {
                    showEmote(this.mesh.position, 'ğŸš«'); // æç¤ºç©å®¶
                    return;
                }
                spawnHeart(this.mesh.position);
            }

            // [æ–°å¢] è®¾ç½®æ‹–æ‹½çŠ¶æ€ (è§£å†³é—®é¢˜2)
            setDragged(isDragged) {
                if (isDragged) {
                    this.state = 'dragged';
                    this.interactTarget = null;
                    this.targetFurniture = null;
                    this.hideBubble();
                    this.resetModelOffset();
                    // æ’­æ”¾åŠ¨ä½œ 5 (Urgent/Struggle)
                    // ç¡®ä¿æ˜ å°„æ­£ç¡®ï¼šAction 5 å¯¹åº” Urgent
                    this.playAction('urgent'); 
                } else {
                    // æ”¾ä¸‹åï¼Œé‡ç½®ä¸º idleï¼Œå¹¶è®©å®ƒè‡ªå·±å†³å®šä¸‹ä¸€æ­¥
                    this.state = 'idle';
                    this.playAction('idle');
                    // ç¨å¾®ç»™ç‚¹å»¶è¿Ÿå†æ€è€ƒï¼Œé¿å…ç¬é—´ä¹±è·‘
                    this.timer = 1.0; 
                }
            }

            pet() { 
                // æ‹–æ‹½ä¸­ä¸å¤„ç†
                if (this.state === 'dragged') return; 

                // çŠ¶æ€æ£€æŸ¥
                if (this.state === 'angry') { showEmote(this.mesh.position, 'ğŸ’¢'); return; } 
                
                // [æ–°å¢] å¦‚æœå¤ªé¥¿æˆ–æƒ³ä¸Šå•æ‰€ï¼Œæ‹’ç»æŠšæ‘¸ï¼Œå¹¶æç¤ºéœ€æ±‚
                if (this.stats.hunger < 30) { 
                    showEmote(this.mesh.position, 'ğŸŸ'); 
                    diaryManager.logEvent('pet_angry'); // <--- è®°å½•ï¼šé¥¿äº†ä¸ç»™æ‘¸
                    return; 
                }
                if (this.stats.toilet < 30) { 
                    showEmote(this.mesh.position, 'ğŸ’©'); 
                    diaryManager.logEvent('pet_angry'); // <--- è®°å½•ï¼šæ€¥ç€ä¸Šå•æ‰€ä¸ç»™æ‘¸
                    return; 
                }

                this.hideBubble(); 
                this.resetModelOffset();

                if (this.petCount >= this.patience) { 
                    showEmote(this.mesh.position, 'ğŸ’¢'); 
                    this.state = 'angry'; 
                    this.angryTime = Date.now() + 15 * 60 * 1000; 
                    this.chooseNewAction(); 
                    updateStatusText("çŒ«å’ªç”Ÿæ°”äº† (15m CD)");
                    diaryManager.logEvent('pet_angry', {}, 100); // æ„¤æ€’æŠšæ‘¸æƒé‡é«˜ä¸€ç‚¹
                } 
                else { 
                    this.petCount++; 
                    this.trySpawnHeart(); 
                    showEmote(this.mesh.position, 'ğŸ˜»'); 
                    this.state = 'petting'; 

                    // [æ–°å¢] æˆåŠŸæŠšæ‘¸æ—¥è®°
                    // åªæœ‰å½“ petCount ç´¯ç§¯åˆ°ä¸€å®šç¨‹åº¦(æ¯”å¦‚3æ¬¡)æˆ–è€…éšæœºæ¦‚ç‡è®°å½•ï¼Œé¿å…åˆ·å±
                    // è¿™é‡Œæˆ‘ä»¬åˆ©ç”¨ DiaryManager è‡ªå¸¦çš„é‡å¤æ–‡æœ¬è¿‡æ»¤ï¼Œç›´æ¥è°ƒç”¨
                    diaryManager.logEvent('pet_happy', {}, 20); // å‹å¥½æŠšæ‘¸æƒé‡ 

                    if (this.resetTimer) clearTimeout(this.resetTimer); 
                    this.resetTimer = setTimeout(() => { 
                        if (this.state === 'petting') this.state = 'idle'; 
                    }, 2000); 
                } 
            }

            resetCooldown() 
            { 
                this.angryTime = 0; this.state = 'idle'; this.petCount = 0; this.patience = 10; showEmote(this.mesh.position, 'â¤ï¸'); }
            
            // [ä¿®æ”¹] ä¸­æ–­è¡Œä¸ºï¼šå¢åŠ  hideBubble å’Œ resetOffset
            interrupt() { 
                showEmote(this.mesh.position,'â“'); 
                this.state='idle'; 
                this.interactTarget=null; 
                this.timer=1; 
                this.hideBubble();     // ä¿®å¤ï¼šå¿…é¡»éšè—æ°”æ³¡
                this.resetModelOffset(); // ä¿®å¤ï¼šæ¢å¤æ¨¡å‹åç§»
            }

            leaveInteraction() { this.state = 'idle'; this.interactTarget = null; this.timer = 1; }

            // [ä¿®æ”¹] è¡Œä¸ºé€‰æ‹© (è§£å†³é—®é¢˜1ï¼šé¿å…é‡å¤é€‰æ‹©åŒä¸€å®¶å…·)
            // [ä¿®å¤] è¡Œä¸ºé€‰æ‹©ï¼šé€‚é…æ–°çš„æ—¶é—´å˜é‡ visualHour
            chooseNewAction() {
                // åŸæ¥æ˜¯ gameTimeï¼Œç°åœ¨æ”¹ä¸º visualHour
                const isDay = (visualHour >= 6 && visualHour < 18);
                
                const boxes = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.isBox);
                const sleepers = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem.canSleep);
                const others = placedFurniture.filter(f => f.userData.parentClass && !f.userData.parentClass.isBox && !f.userData.parentClass.dbItem.canSleep && f.userData.parentClass.dbItem.layer === 1);

                // [æ–°å¢] è¿‡æ»¤æ‰ä¸Šä¸€æ¬¡åˆšäº’åŠ¨è¿‡çš„å¯¹è±¡ (é˜²æ­¢åŸåœ°ç¡è§‰å¾ªç¯)
                const filterLast = (arr) => arr.filter(item => item !== this.lastInteractTarget);

                let rnd = Math.random();
                let target = null;
                
                // ä¼˜å…ˆæ£€æŸ¥ç›’å­
                const availBoxes = filterLast(boxes);
                if (availBoxes.length > 0 && rnd < 0.6) { 
                    target = availBoxes[Math.floor(Math.random() * availBoxes.length)]; 
                }
                else {
                    let sleepRnd = Math.random();
                    // æ ¹æ®ç™½å¤©é»‘å¤œè°ƒæ•´ç¡è§‰æ¦‚ç‡
                    let wantSleep = isDay ? (sleepRnd < 0.7) : (sleepRnd < 0.3); 
                    
                    const availSleepers = filterLast(sleepers);
                    if (wantSleep && availSleepers.length > 0) { 
                        target = availSleepers[Math.floor(Math.random() * availSleepers.length)]; 
                    } 
                    else { 
                        const availOthers = filterLast(others);
                        if (availOthers.length > 0 && Math.random() < 0.5) { 
                            target = availOthers[Math.floor(Math.random() * availOthers.length)]; 
                        } else { 
                            target = null; 
                        } 
                    }
                }

                if(target) { 
                    this.interactTarget = target; 
                    const dist = (target.userData.parentClass.dbItem.canSleep) ? 0.5 : 0.7;
                    this.setPath(target.position, dist); 
                    this.state = 'walking'; 
                } 
                else { 
                    this.lastInteractTarget = null;
                    this.interactTarget = null; 
                    const randPos = new THREE.Vector3((Math.random()-0.5)*8, 0, (Math.random()-0.5)*8); 
                    this.setPath(randPos); 
                    this.state = 'walking'; 
                }
            }

            // [ä¿®å¤] è¿›å…¥äº¤äº’ï¼šæ™ºèƒ½å¯¹é½å®¶å…·æ–¹å‘ï¼Œé˜²æ­¢ç©¿æ¨¡
            enterInteraction() { 
                if (this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.dbItem.canSleep) {
                    this.state = 'sleeping';
                    this.sleepMinDuration = 10.0 + Math.random() * 10.0;
                    this.playAction('sleep'); 
                    this.showBubble('ğŸ’¤');

                    // 1. ä½ç½®å½’ä½ï¼šå…ˆç§»åˆ°å®¶å…·ä¸­å¿ƒ
                    this.mesh.position.copy(this.interactTarget.position);

                    // 2. æ—‹è½¬å¯¹é½ï¼šè·å–å®¶å…·çš„æ—‹è½¬è§’åº¦
                    const furnRotation = this.interactTarget.rotation.y;
                    
                    // è®©çŒ«å’ªçš„æœå‘ä¸å®¶å…·ä¸€è‡´ (æˆ–è€…è½¬90åº¦ï¼Œçœ‹æ¨¡å‹æƒ…å†µ)
                    // å‡è®¾çŒ«å’ªé»˜è®¤æœå‘æ˜¯Zè½´ï¼Œæˆ‘ä»¬è®©å®ƒå’Œå®¶å…·æ–¹å‘ä¸€è‡´ï¼Œè¿™æ ·åæ ‡ç³»å°±ç»Ÿä¸€äº†
                    this.mesh.rotation.y = furnRotation; 

                    // 3. å±€éƒ¨åç§»è®¡ç®—ï¼šè§£å†³ç©¿æ¨¡ä¸é èƒŒé—®é¢˜
                    // ç°åœ¨çš„ Z æ˜¯ç›¸å¯¹äºå®¶å…·çš„â€œæ­£å‰æ–¹â€çš„
                    // å¦‚æœé èƒŒåœ¨å®¶å…·çš„ -Z (å±€éƒ¨)ï¼Œæˆ‘ä»¬å°±è¦å¾€ +Z ç§»
                    // ä½¿ç”¨ Vector3.applyAxisAngle æ¥è®¡ç®—ä¸–ç•Œåæ ‡ä¸‹çš„åç§»
                    const localOffset = new THREE.Vector3(0, 0, 0.25); // å¾€â€œå‰â€æŒª 0.25
                    
                    // æœ‰äº›é•¿æ¡å½¢å®¶å…·ï¼ˆå¦‚åºŠ/æ²™å‘ï¼‰ï¼Œå¯èƒ½éœ€è¦æ²¿ç€ X è½´ç¨å¾®éšæœºä¸€ç‚¹ï¼Œä¸è¦æ¯æ¬¡éƒ½ç¡æ­£ä¸­é—´
                    const randomX = (Math.random() - 0.5) * 0.4; 
                    localOffset.x += randomX;

                    // å°†å±€éƒ¨åç§»è½¬æ¢ä¸ºä¸–ç•Œåç§»å¹¶åº”ç”¨
                    localOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), furnRotation);
                    this.mesh.position.add(localOffset);

                    // 4. é«˜åº¦ä¿®æ­£
                    const itemSize = this.interactTarget.userData.parentClass.dbItem.size;
                    if(itemSize) {
                        this.mesh.position.y += (itemSize.y * 0.5) + 0.3;
                    }

                    // 5. æ¨¡å‹å†…éƒ¨å¾®è°ƒ (æ¨¡å‹æœ¬èº«çš„é‡å¿ƒåå·®ä¿®æ­£)
                    if(this.mesh.children.length > 0) {
                        // ç¨å¾®å‘å³ä¸€ç‚¹ï¼ŒæŠµæ¶ˆå€’ä¸‹åŠ¨ç”»çš„ä½ç§»
                        this.mesh.children[0].position.set(0.2, CAT_CONFIG.yOffset || 0, 0); 
                    }
                    return;
                }

                // ... å…¶ä»–äº¤äº’é€»è¾‘ (ç©ç®±å­ç­‰) ä¿æŒä¸å˜ ...
                this.state = 'interacting'; 
                this.timer = 5 + Math.random() * 5; 
                if (this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox) { this.timer = 8; showEmote(this.mesh.position, 'ğŸ“¦'); }
                if(this.interactTarget) { 
                    const isInsideBox = this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox && !this.interactTarget.userData.parentClass.isTipped; 
                    if (!isInsideBox) { this.mesh.rotation.y = Math.random() * Math.PI * 2; } 
                }
            }

// [ä¿®å¤] è®¾ç½®è·¯å¾„ï¼šé’ˆå¯¹åƒé¥­è¡Œä¸ºï¼Œç¼©å°åœæ­¢è·ç¦»ï¼Œå¹¶å¼ºåˆ¶æ›´æ–°çŠ¶æ€
            setPath(targetPosition, stopDist = 0.7) { 
                this.targetPos.copy(targetPosition); 
                
                // è®¡ç®—æ–¹å‘ï¼šä»ç›®æ ‡æŒ‡å‘çŒ« (ä¸ºäº†åå‘æ¨ç®—åœæ­¢ç‚¹)
                const vec = new THREE.Vector3().subVectors(this.mesh.position, targetPosition); 
                vec.y = 0; // å¿½ç•¥é«˜åº¦å·®
                vec.normalize(); 
                
                // [é’ˆå¯¹åƒé¥­çš„ä¿®æ­£]
                // æ£€æŸ¥ interactTarget æˆ– targetFurniture æ˜¯å¦æ˜¯é£Ÿç‰©
                // æ³¨æ„ï¼šchooseNewAction è®¾ç½® interactTargetï¼Œä½† handleIdleLogic è®¾ç½® targetFurniture
                let isFood = false;
                if (this.targetFurniture && this.targetFurniture.userData.parentClass && this.targetFurniture.userData.parentClass.dbItem.subType === 'food') {
                    isFood = true;
                }

                if (isFood) {
                    stopDist = 0.5; // ç¦»é¥­ç›†æ›´è¿‘
                }

                // è®¡ç®—åœæ­¢ç‚¹ï¼šç›®æ ‡ç‚¹ + æ–¹å‘ * è·ç¦»
                this.stopPos.copy(targetPosition).add(vec.multiplyScalar(stopDist));
            }

            // [ä¿®æ”¹] ç”Ÿç†éœ€æ±‚è¡°å‡ï¼šè°ƒæ•´æ¯”ä¾‹ä¸º 3åƒ : 2æ‹‰
            decayStats(dt) { 
                // é¥¥é¥¿åŠ å¿« (0.5 -> 0.6)ï¼Œå¦‚å•å˜æ…¢ (0.4 -> 0.3)
                this.stats.hunger -= 0.6 * dt; 
                this.stats.toilet -= 0.3 * dt; 
                
                if(this.stats.hunger < 0) this.stats.hunger = 0; 
                if(this.stats.toilet < 0) this.stats.toilet = 0; 
            }
            findAvailableFurniture(subType, requiredState) { return placedFurniture.find(f => f.userData.parentClass && f.userData.parentClass.dbItem.subType === subType && f.userData.parentClass.functionalState === requiredState); }
            checkIfNeedsSatisfied() { this.playAction('idle'); if (this.stats.hunger < 30) { const food = this.findAvailableFurniture('food', 'full'); if (food || this.stats.hunger > 90) { this.state = 'idle'; this.hideBubble(); } } if (this.stats.toilet < 40) { const box = this.findAvailableFurniture('toilet', 'clean'); if (box || this.stats.toilet > 90) { this.state = 'idle'; this.hideBubble(); } } }
            

// [ä¿®æ”¹] åˆ°è¾¾é€»è¾‘ï¼šä¿®å¤çŒ«ç ‚ç›†é«˜åº¦ & ç¦»å¼€æ—¶è·³å‡º
            onArriveDest() {
                if (!this.targetFurniture) { 
                    this.enterInteraction(); 
                    this.nextAction = null; 
                    this.targetFurniture = null;
                    return;
                }
                
                const parent = this.targetFurniture.userData.parentClass;
                if (parent && parent.isBox && !parent.isTipped) { this.startJump(); return; }
                
                if (this.nextAction === 'EAT') { 
                    this.state = 'eating'; 
                    this.playAction('eat'); 
                    if(this.targetFurniture.position) this.mesh.lookAt(this.targetFurniture.position.x, this.mesh.position.y, this.targetFurniture.position.z); 
                    setTimeout(() => { 
                        if(this.state !== 'eating') return; 
                        this.stats.hunger = 100; 
                        if(this.targetFurniture && this.targetFurniture.userData.parentClass) this.targetFurniture.userData.parentClass.useByCat(); 
                        this.state = 'idle'; this.timer = 2; this.trySpawnHeart(); 
                        this.targetFurniture = null; 
                    }, 5000); 
                } 
                else if (this.nextAction === 'POOP') { 
                    this.state = 'pooping'; 
                    
                    this.mesh.position.copy(this.targetFurniture.position);
                    // [ä¿®å¤] é«˜åº¦å¢åŠ ï¼šä» 0.35 -> 0.55ï¼Œé˜²æ­¢è¢«åŸ‹
                    this.mesh.position.y += 0.55; 

                    this.playAction('urgent'); 
                    this.mesh.rotation.y = Math.random() * Math.PI * 2;
                    
                    setTimeout(() => { 
                        if(this.state !== 'pooping') return; 
                        
                        this.stats.toilet = 100; 
                        if(this.targetFurniture && this.targetFurniture.userData.parentClass) this.targetFurniture.userData.parentClass.useByCat(); 
                        
                        // [æ–°å¢] ç¦»å¼€çŒ«ç ‚ç›†ï¼šè·³å›è¿›å…¥å‰çš„ä½ç½® (stopPos)
                        // è¿™æ ·å°±é¿å…äº†è¢«å›°åœ¨çŒ«ç ‚ç›†æ¨¡å‹é‡Œé¢
                        this.mesh.position.copy(this.stopPos);
                        // é‡ç½®é«˜åº¦ä¸ºåœ°é¢
                        this.mesh.position.y = 0; 

                        this.state = 'idle'; this.timer = 2; this.trySpawnHeart(); 
                        this.targetFurniture = null; 
                    }, 4000); 
                }
            }
        }

        // === 6. äº¤äº’ä¸æ¸²æŸ“ ===
        window.switchCategory = function(cat) {
            currentCategory = cat;
            
            // [ä¿®æ”¹] åˆ‡æ¢ Tab çš„ active æ ·å¼
            const tabs = document.querySelectorAll('.shop-tab');
            const catMap = { 'floor': 0, 'small': 1, 'wall': 2, 'decor': 3 };
            
            tabs.forEach(t => t.classList.remove('active'));
            if (tabs[catMap[cat]]) tabs[catMap[cat]].classList.add('active');
            
            renderShopItems(cat);
        };
        
        window.forceStart = function() { const ls = document.getElementById('loading-screen'); if(ls) ls.style.display = 'none'; if(!scene) startGame(); }
        window.debugAddMoney = function() { updateMoney(100); };
        window.debugResetCat = function() { cats.forEach(c => c.resetCooldown()); updateStatusText("çŒ«å’ªä¸å†ç”Ÿæ°”äº†"); };

        let debugGizmosVisible = false;
        let debugHelpers = [];
        window.toggleDebugGizmos = function() {
            debugGizmosVisible = !debugGizmosVisible;
            
            // 1. æ¸…é™¤æ—§çš„çº¿æ¡†
            debugHelpers.forEach(h => scene.remove(h));
            debugHelpers = [];

            if (!debugGizmosVisible) {
                updateStatusText("è°ƒè¯•æ¨¡å¼: å…³é—­");
                return;
            }

            // 2. ç”Ÿæˆæ–°çš„çº¿æ¡†
            placedFurniture.forEach(f => {
                if (!f.userData.parentClass) return;
                const db = f.userData.parentClass.dbItem;
                
                // çº¢è‰²ï¼šå®é™…æ¨¡å‹åŒ…å›´ç›’ (BoxHelper) - è¿™æ˜¯çœŸå®çš„ç‰©ç†è¾¹ç¼˜
                const meshHelper = new THREE.BoxHelper(f, 0xff0000);
                scene.add(meshHelper);
                debugHelpers.push(meshHelper);

                // ç»¿è‰²ï¼šé€»è¾‘æ•°æ®åŒ…å›´ç›’ (Based on DB Size)
                if (db.size) {
                    const geo = new THREE.BoxGeometry(db.size.x, db.size.y, db.size.z);
                    const edges = new THREE.EdgesGeometry(geo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    
                    line.position.copy(f.position);
                    line.rotation.copy(f.rotation);
                    
                    // [ä¿®å¤] åªæœ‰éå¢™å£ç±»å®¶å…·ï¼Œæ‰éœ€è¦æŠ¬é«˜çº¿æ¡†
                    // å¢™å£ç±»å®¶å…· (type === 'wall') é€šå¸¸åŸç‚¹å°±åœ¨ä¸­å¿ƒï¼Œä¸éœ€è¦æŠ¬é«˜
                    if (db.type !== 'wall' && db.fixBottom !== false) {
                        line.position.y += db.size.y / 2;
                    }

                    scene.add(line);
                    debugHelpers.push(line);
                }
            });
            updateStatusText("è°ƒè¯•æ¨¡å¼: å¼€å¯ - çº¢:æ¨¡å‹ ç»¿:é€»è¾‘");
        }

        // [æ–°å¢] åˆ‡æ¢æ—¥å¿—æ˜¾ç¤º/éšè—
        window.toggleConsole = function() {
            const consoleDiv = document.getElementById('debug-console');
            if (consoleDiv) {
                // å¦‚æœå½“å‰æ˜¯éšè—çš„ï¼Œå°±æ˜¾ç¤ºï¼›å¦‚æœæ˜¯æ˜¾ç¤ºçš„ï¼Œå°±éšè—
                if (consoleDiv.style.display === 'none' || consoleDiv.style.display === '') {
                    consoleDiv.style.display = 'block';
                } else {
                    consoleDiv.style.display = 'none';
                }
            }
        };

function renderShopItems(cat) {
            const c = document.getElementById('items-scroll'); 
            c.innerHTML = ''; 
            
            let typeFilter = cat; 
            FURNITURE_DB.filter(i => (i.type === typeFilter || (typeFilter === 'floor' && i.type === 'functional'))).forEach(item => {
                
                // åˆ›å»ºå®¹å™¨
                const card = document.createElement('div');
                card.className = 'item-card';
                if (heartScore < item.price) card.classList.add('disabled');
                if (item.type === 'decor' && activeDecorId[item.decorType] === item.id) card.classList.add('selected');

                // ç‚¹å‡»äº‹ä»¶
                card.onclick = (e) => { 
                    e.stopPropagation(); 
                    if (!card.classList.contains('disabled')) { 
                        startNewPlacement(item.id); 
                    } 
                };
                // è£…é¥°é¢„è§ˆäº‹ä»¶
                if (item.type === 'decor') { 
                    card.onmouseenter = () => applyDecorVisuals(item); 
                    card.onmouseleave = () => restoreDecorState(item.decorType); 
                }

                // 1. å±•ç¤ºå°èƒŒæ™¯ (Shelf) - ä»…éè£…é¥°ç±»æ˜¾ç¤ºå°å­ï¼Œæˆ–è€…éƒ½æ˜¾ç¤ºï¼Œçœ‹ä½ å–œå¥½
                // å‡è®¾å¢™çº¸ä¹Ÿæ”¾åœ¨å°å­ä¸Šå–
                const shelf = document.createElement('img');
                shelf.src = './assets/ui/shop_shelf.png';
                shelf.className = 'shelf-bg';
                card.appendChild(shelf);

                // 2. å•†å“å›¾æ ‡ (Icon)
                // æ£€æŸ¥æ˜¯å¦æœ‰ iconFile å®šä¹‰ï¼Œæˆ–è€…æ‹¼å‡‘è·¯å¾„ assets/ui/items/icon_{id}.png
                const iconPath = `./assets/ui/items/icon_${item.id}.png`;
                
                const iconImg = document.createElement('img');
                iconImg.className = 'item-icon';
                iconImg.src = iconPath;
                
                // [å¤‡ç”¨æ–¹æ¡ˆ] å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶ï¼Œæ˜¾ç¤ºè‰²å—
                iconImg.onerror = function() {
                    this.style.display = 'none'; // éšè—ç ´å›¾
                    const placeholder = document.createElement('div');
                    placeholder.className = 'item-placeholder';
                    
                    // å¦‚æœæœ‰çº¹ç†ç”¨çº¹ç†ï¼Œæ²¡çº¹ç†ç”¨é¢œè‰²
                    if (item.textureFile) {
                        placeholder.style.backgroundImage = `url(./assets/textures/${item.textureFile})`;
                        placeholder.style.backgroundSize = 'cover';
                    } else {
                        const colorVal = item.color !== undefined ? item.color : 0xcccccc;
                        placeholder.style.background = '#' + colorVal.toString(16).padStart(6, '0');
                    }
                    card.insertBefore(placeholder, shelf.nextSibling); // æ’åœ¨å°å­ä¸Šé¢
                };
                
                card.appendChild(iconImg);

                // 3. ä»·æ ¼åŠç‰Œ (Tag)
                const tag = document.createElement('div');
                tag.className = 'price-tag-new';
                
                // [ä¿®å¤] æ’å…¥çˆ±å¿ƒå°å›¾æ ‡å’Œä»·æ ¼
                const priceText = item.price > 0 ? item.price : 'Free';
                // è¿™é‡Œå¤ç”¨çˆ±å¿ƒç»„ä»¶çš„é‚£ä¸ªå›¾æ ‡ï¼Œç¨å¾®ç¼©å°ä¸€ç‚¹
                tag.innerHTML = `<img src="./assets/ui/icon_heart.png" class="price-heart-icon"><span>${priceText}</span>`;
                
                card.appendChild(tag);

                c.appendChild(card);
            }); 
            // ä¸éœ€è¦ refreshShopState äº†ï¼Œå› ä¸ºä¸Šé¢åˆ›å»ºæ—¶å·²ç»åˆ¤æ–­äº† disabled
        }

        window.startNewPlacement = function(id) {
            const item = FURNITURE_DB.find(i => i.id === id);
            if (heartScore < item.price && !activeDecorId[item.decorType]) { alert("é‡‘é’±ä¸è¶³"); return; } 
            if (item.type === 'decor') { handleDecorClick(item); return; }
            deselect(); mode = 'placing_new'; currentItemData = item; currentRotation = 0; createGhost(); updateStatusText("æ”¾ç½®: " + item.name); document.querySelectorAll('.item-btn').forEach(b => b.classList.remove('selected'));
        }

        function handleDecorClick(item) {
            const type = item.decorType;
            if (activeDecorId[type] === item.id) { activeDecorId[type] = null; restoreDecorState(type); updateStatusText("å·²æ¢å¤é»˜è®¤æ ·å¼"); } 
            else { if (heartScore >= item.price) { updateMoney(-item.price); activeDecorId[type] = item.id; applyDecorVisuals(item); updateStatusText("å·²è£…ä¿®: " + item.name); } else { alert("é‡‘é’±ä¸è¶³ï¼"); } }
            renderShopItems('decor'); 
        }

        function createGhost() {
            if (ghostMesh) scene.remove(ghostMesh);
            const item = currentItemData; const modelGroup = prepareModel(item);
            if (modelGroup) { ghostMesh = modelGroup; } else { let mat = new THREE.MeshStandardMaterial({ color: item.color, transparent: true, opacity: 0.6 }); let geo = new THREE.BoxGeometry(item.size?.x || 1, item.size?.y || 1, item.size?.z || 1); ghostMesh = new THREE.Mesh(geo, mat); }
            ghostMesh.traverse((c) => { if (c.isMesh) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.5; } });
            ghostMesh.position.set(0, -100, 0); if (item.type !== 'wall') ghostMesh.rotation.y = currentRotation; scene.add(ghostMesh);
        }

        function checkColl(isWall) {
            ghostMesh.updateMatrixWorld();
            const box = new THREE.Box3().setFromObject(ghostMesh);
            if (currentItemData.layer === 0) { 
                 box.min.x += 0.1; box.max.x -= 0.1;
                 box.min.z += 0.1; box.max.z -= 0.1;
            } else {
                 box.expandByScalar(-0.1);
            }

            let col = false;
            // 1. Wall structure collision
            if (!isWall) {
                for (let o of obstacles) {
                    if (box.intersectsBox(new THREE.Box3().setFromObject(o))) { col = true; break; }
                }
            }

            // 2. Furniture collision
            if (!col) {
                for (let f of placedFurniture) {
                    if (mode === 'moving_old' && f === selectedObject) continue;

                    // [ä¿®å¤] å±‚çº§åˆ¤æ–­é€»è¾‘
                    const myL = currentItemData.layer;
                    const otherL = f.userData.parentClass ? f.userData.parentClass.dbItem.layer : 1;

                    // Layer 0 (Rugs) ignores everything and is ignored by everything
                    if (myL === 0 || otherL === 0) continue;

                    // Layer 2 vs Layer 1 collision rules (simplified: ignore vertical stacking collision for horizontal placement)
                    if ((myL === 2 && otherL === 1) || (myL === 1 && otherL === 2)) continue;

                    // Overlap property
                    if (currentItemData.allowOverlap && f.userData.parentClass && f.userData.parentClass.dbItem.type === 'wall') continue;

                    if (box.intersectsBox(new THREE.Box3().setFromObject(f))) { col = true; break; }
                }
            }
            if (ghostMesh.position.y < 0 && currentItemData.layer !== 0) col = true;
            
            if (col) {
                ghostMesh.traverse(c => { if (c.isMesh) c.material.color.setHex(0xff0000) });
                canPlace = false;
                updateStatusText("ä½ç½®å†²çª", "invalid");
            } else {
                ghostMesh.traverse(c => { if (c.isMesh) c.material.color.setHex(0xffffff) });
                canPlace = true;
                updateStatusText("å¯æ”¾ç½®", "valid");
            }
        }

        function confirmPlace() {
            if (mode === 'placing_new') { 
                if (heartScore >= currentItemData.price) 
                updateMoney(-currentItemData.price); 
            else { alert("é‡‘é’±ä¸è¶³!"); 
            cancelPlace(); 
            gameSaveManager.saveGame();
            return; } 
        }
            
            let m = ghostMesh.clone();
            m.traverse(c => { 
                if (c.isMesh) { 
                    c.material.opacity = 1.0; 
                    c.material.transparent = false; 
                    if (!currentItemData.modelFile) c.material.color.setHex(currentItemData.color || 0xffffff); 
                } 
            });
            
            const newFurniture = new Furniture(m, currentItemData);
            scene.add(m); 
            placedFurniture.push(m);

            // [æ–°å¢] æ—¥è®°åŸ‹ç‚¹ï¼šè´­ä¹°å®¶å…·
            if (mode === 'placing_new') {
                const typeKey = (currentItemData.type === 'floor') ? 'buy_floor' : 'buy_small';
                
                // [å…³é”®ä¿®å¤] å¿…é¡»ä¼ å…¥ id: currentItemData.id
                // è¿™æ · logEvent æ‰èƒ½å» specific_items é‡ŒæŸ¥æ‰¾æœ‰æ²¡æœ‰ 'ChrismasTree' çš„ä¸“ç”¨åæ§½
                // [ä¿®æ”¹] è°ƒç”¨ logEventï¼Œç»™è´­ä¹°äº‹ä»¶ä¸€ä¸ªæƒé‡
                diaryManager.logEvent(typeKey, {
                    item: currentItemData.name, 
                    id: currentItemData.id 
                }, 60); // è´­ä¹°äº‹ä»¶æƒé‡é«˜ä¸€ç‚¹
            }


            if(currentItemData.light) {
                if (currentItemData.lightType === 'point') { 
                    const bulb = new THREE.PointLight(0xffaa00, 0.8, 5); 
                    let lx = 0, ly = 0.3, lz = 0;
                    if (currentItemData.lightOffset) { lx = currentItemData.lightOffset.x || 0; ly = currentItemData.lightOffset.y || 0; lz = currentItemData.lightOffset.z || 0; }
                    bulb.position.set(lx, ly, lz); bulb.castShadow = true; m.add(bulb); 
                } else { 
                    const sl = new THREE.SpotLight(0xfff0dd, 5); sl.position.set(0,0,0); sl.target.position.set(0,0,5); sl.angle = Math.PI / 3; sl.penumbra = 0.5; sl.castShadow = true; m.add(sl); m.add(sl.target); 
                }
            }
            
            // [ä¿®å¤] å¤©ç©ºèƒŒæ™¯
            if(currentItemData.light && currentItemData.type === 'wall') { 
                 addSkyBacking(m, currentItemData.size); 
            }

            if (mode === 'placing_new' && currentItemData.layer === 1) { const savedItem = currentItemData; setTimeout(() => spawnMysteryBox(savedItem), 1000); }
            if (mode === 'moving_old') { scene.remove(selectedObject); const i = placedFurniture.indexOf(selectedObject); if (i > -1) placedFurniture.splice(i, 1); deselect(); }
            cancelPlace(); playBounce(m);

            gameSaveManager.saveGame(); // ä¹Ÿè¦å­˜ç›˜
        }

        function onDown(e) {
            if (e.target !== renderer.domElement) return;
            startPointer.x = e.clientX; startPointer.y = e.clientY;
            
            if (mode === 'idle' && e.button === 0) {
                raycaster.setFromCamera(pointer, camera);
                
                // 1. ä¼˜å…ˆæ£€æµ‹çŒ«å’ª
                let catHit = null;
                for(let cat of cats) { 
                    const hits = raycaster.intersectObject(cat.mesh, true); 
                    if(hits.length > 0) { catHit = cat; break; } 
                }

                if (catHit) {
                    // ç‚¹å‡»åˆ°çŒ«å’ªï¼Œå…ˆæš‚æ—¶é”å®šè§†è§’æ—‹è½¬ï¼Œé˜²æ­¢é•¿æŒ‰æ—¶è¯¯è§¦
                    controls.enabled = false; 

                    longPressTimer = setTimeout(() => {
                        // é•¿æŒ‰è§¦å‘ï¼šå¼€å§‹æ‹–æ‹½
                        draggingCat = catHit;
                        draggingCat.setDragged(true); 
                        updateStatusText("æ‹èµ·çŒ«å’ª");
                    }, 500);
                    return; 
                }

                // 2. æ£€æµ‹å®¶å…·
                const hits = raycaster.intersectObjects(placedFurniture, true);
                if (hits.length > 0) {
                    let root = hits[0].object; while (root.parent && root.parent !== scene) root = root.parent;
                    
                    if (root.userData.isBox) { 
                        scene.remove(root); 
                        const i = placedFurniture.indexOf(root); 
                        if (i > -1) placedFurniture.splice(i, 1); 
                        updateMoney(10); spawnHeart(root.position); updateStatusText("å›æ”¶çº¸ç®±+10"); 
                        return; 
                    }
                    if (root.userData.parentClass) {
                        const didInteract = root.userData.parentClass.interact(); if (didInteract) return;
                        if (root.userData.parentClass.isBox) { scene.remove(root); const i = placedFurniture.indexOf(root); if (i > -1) placedFurniture.splice(i, 1); updateMoney(10); spawnHeart(root.position); updateStatusText("å›æ”¶çº¸ç®±+10"); return; }
                    }
                    longPressTimer = setTimeout(() => selectObj(root, e.clientX, e.clientY), 500);
                }
            }
            if (e.button === 1 && ghostMesh && currentItemData.type !== 'wall') { e.preventDefault(); rotateItem(); return; }
            if (e.button === 0 && (mode === 'placing_new' || mode === 'moving_old') && canPlace && ghostMesh) confirmPlace();
        }

        function onUp() { 
            // æ¢å¤è§†è§’æ§åˆ¶
            controls.enabled = true;

            if (draggingCat) {
                draggingCat.setDragged(false);
                draggingCat = null;
                updateStatusText("æ”¾ç½®çŒ«å’ª");
            }
            else if (longPressTimer) { 
                clearTimeout(longPressTimer); 
                longPressTimer = null; 
                raycaster.setFromCamera(pointer, camera);
                for(let cat of cats) { 
                    const hits = raycaster.intersectObject(cat.mesh, true); 
                    if(hits.length > 0) { cat.pet(); return; } 
                }
            } 
        }  

        function selectObj(m, x, y) { deselect(); selectedObject = m; selectionBox = new THREE.BoxHelper(selectedObject, 0xffffff); scene.add(selectionBox); const menu = document.getElementById('context-menu'); menu.style.display = 'flex'; let px = x + 10, py = y + 10; if (px + 100 > window.innerWidth) px = window.innerWidth - 110; if (py + 100 > window.innerHeight) py = window.innerHeight - 110; menu.style.left = px + 'px'; menu.style.top = py + 'px'; updateStatusText("é€‰ä¸­: å®¶å…·"); }
        function deselect() { selectedObject = null; if (selectionBox) { scene.remove(selectionBox); selectionBox = null; } document.getElementById('context-menu').style.display = 'none'; }
        function cancelPlace() { if (ghostMesh) scene.remove(ghostMesh); mode = 'idle'; ghostMesh = null; currentItemData = null; updateStatusText("æµè§ˆä¸­"); }
        function cancelMove() { if(mode==='moving_old'){if(ghostMesh)scene.remove(ghostMesh);if(selectedObject){selectedObject.position.copy(editingObjectOriginalPos);selectedObject.quaternion.copy(editingObjectOriginalQuat);selectedObject.visible=true;}} deselect(); mode='idle'; ghostMesh=null; }
        function showMenu(x,y) { const m=document.getElementById('context-menu'); m.style.display='flex'; let px=x+10, py=y+10; if(px+100>window.innerWidth)px=window.innerWidth-110; if(py+100>window.innerHeight)py=window.innerHeight-110; m.style.left=px+'px'; m.style.top=py+'px'; }
        function hideContextMenu() { document.getElementById('context-menu').style.display='none'; }
         
        
        
        function startMovingOld(m) { mode = 'moving_old'; m.visible = false; editingObjectOriginalPos = m.position.clone(); editingObjectOriginalQuat = m.quaternion.clone(); currentItemData = m.userData.parentClass ? m.userData.parentClass.dbItem : FURNITURE_DB[0]; currentRotation = m.rotation.y; createGhost(); updateStatusText("æ­£åœ¨ç§»åŠ¨..."); }
        function deleteSelected() { if (!selectedObject) return; scene.remove(selectedObject); const i = placedFurniture.indexOf(selectedObject); if (i > -1) placedFurniture.splice(i, 1); deselect(); }
        
        // === æ›¿æ¢ onMove (å¢åŠ æ‹–æ‹½é€»è¾‘) ===
        function onMove(e) {
            if (longPressTimer && !draggingCat) { 
                // å¦‚æœç§»åŠ¨è·ç¦»è¿‡å¤§ï¼Œå–æ¶ˆé•¿æŒ‰åˆ¤å®šï¼ˆé˜²æ­¢è¯¯è§¦ï¼‰
                if (Math.hypot(e.clientX - startPointer.x, e.clientY - startPointer.y) > 5) { 
                    clearTimeout(longPressTimer); longPressTimer = null; 
                } 
            }
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1; pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // [æ–°å¢] çŒ«å’ªæ‹–æ‹½é€»è¾‘
            if (draggingCat) {
                raycaster.setFromCamera(pointer, camera);
                // å°„çº¿æ£€æµ‹ï¼šåœ°æ¿ + æ‰€æœ‰å®¶å…· (è®©çŒ«èƒ½è¢«æ”¾åœ¨æ¡Œå­/æ²™å‘ä¸Š)
                const checkList = [floorPlane, ...placedFurniture];
                const hits = raycaster.intersectObjects(checkList, true);
                
                if (hits.length > 0) {
                    const hit = hits[0];
                    // è·å–ç‚¹å‡»ç‚¹çš„é«˜åº¦
                    let targetY = hit.point.y;
                    
                    // å¦‚æœæ˜¯æ”¾åœ¨å®¶å…·ä¸Šï¼Œç¨å¾®å¤„ç†ä¸€ä¸‹ï¼Œé¿å…ç©¿æ¨¡å¤ªæ·±
                    // è¿™é‡Œç®€å•å¤„ç†ï¼šç›´æ¥å¸é™„åˆ°å°„çº¿å‡»ä¸­ç‚¹
                    draggingCat.mesh.position.set(hit.point.x, targetY, hit.point.z);
                }
                return;
            }

            // ... åŸæœ‰çš„å®¶å…·ç§»åŠ¨é€»è¾‘ ...
            if ((mode === 'placing_new' || mode === 'moving_old') && ghostMesh) {
                raycaster.setFromCamera(pointer, camera); 
                if (currentItemData.type === 'wall') {
                    const hits = raycaster.intersectObjects(obstacles);
                    if (hits.length > 0) {
                        const h = hits[0]; const n = h.face.normal;
                        if (Math.abs(n.y) > 0.5) return; 
                        const offset = currentItemData.size.z / 2 + 0.01;
                        const pos = h.point.clone().add(n.clone().multiplyScalar(offset));
                        if (Math.abs(n.x) > 0.5) { pos.y = Math.round(pos.y / 0.5) * 0.5; pos.z = Math.round(pos.z / 0.5) * 0.5; } 
                        else { pos.x = Math.round(pos.x / 0.5) * 0.5; pos.y = Math.round(pos.y / 0.5) * 0.5; }
                        const hh = currentItemData.size.y / 2; if (pos.y < hh) pos.y = hh; if (pos.y + hh > 3) pos.y = 3 - hh;
                        ghostMesh.position.copy(pos); ghostMesh.lookAt(pos.clone().add(n)); checkColl(true);
                    }
                    return;
                }
                let onTable = false;
                if (currentItemData.layer === 2) {
                    const surfaceMeshes = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem && f.userData.parentClass.dbItem.isSurface);
                    const hits = raycaster.intersectObjects(surfaceMeshes, true);
                    if (hits.length > 0) {
                        const hit = hits[0]; let targetY = hit.point.y;
                        if (hit.object.parent && hit.object.parent.userData.parentClass && hit.object.parent.userData.parentClass.dbItem.surfaceHeight) {
                            targetY = hit.object.parent.position.y + hit.object.parent.userData.parentClass.dbItem.surfaceHeight;
                        }
                        if (currentItemData.yFix) targetY += currentItemData.yFix;
                        ghostMesh.position.set(hit.point.x, targetY, hit.point.z); ghostMesh.rotation.set(0, currentRotation, 0); checkColl(false); onTable = true;
                    }
                }
                if (!onTable) {
                    const hits = raycaster.intersectObject(floorPlane);
                    if (hits.length > 0) {
                        const p = hits[0].point; let targetY = 0; if (currentItemData.id.includes('rug')) targetY = 0.01;
                        ghostMesh.position.set(Math.round(p.x / 0.5) * 0.5, targetY, Math.round(p.z / 0.5) * 0.5);
                        ghostMesh.rotation.set(0, currentRotation, 0); checkColl(false);
                    }
                }
            }
        }

        function rotateItem() { currentRotation += Math.PI / 2; if (ghostMesh) { ghostMesh.rotation.y = currentRotation; checkColl(false); } }
        function playBounce(m) { let f=0; const baseScale = m.userData.parentClass.dbItem.modelScale || 1; function a(){ if(f<20){const k=f/20; const s=0.1+(0.9)*(Math.sin(k*Math.PI*1.5)*0.2+k); m.scale.set(baseScale*s, baseScale*s, baseScale*s); f++; requestAnimationFrame(a); }else m.scale.set(baseScale, baseScale, baseScale); } a(); }
        function onWindowResize() { 
            const aspect = window.innerWidth / window.innerHeight; 
            const d = 12; 
            camera.left = -d * aspect; camera.right = d * aspect; camera.top = d; camera.bottom = -d; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // [æ–°å¢] çª—å£å˜åŒ–æ—¶æ›´æ–°åæœŸå¤„ç†å°ºå¯¸
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        }


        function updateCameraMovement(dt) {
            if (!(moveKeys.w || moveKeys.a || moveKeys.s || moveKeys.d)) return;
            const moveSpeed = 10.0 * dt;
            const displacement = new THREE.Vector3();
            const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
            const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
            if (moveKeys.w) displacement.add(forward.multiplyScalar(moveSpeed));
            if (moveKeys.s) displacement.sub(forward.multiplyScalar(moveSpeed));
            if (moveKeys.d) displacement.add(right.multiplyScalar(moveSpeed));
            if (moveKeys.a) displacement.sub(right.multiplyScalar(moveSpeed));
            camera.position.add(displacement); controls.target.add(displacement);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = gameClock.getDelta(); 
            updateCameraMovement(dt);
            controls.update();
            updateEnvironment(dt);
            cats.forEach(c => c.update(dt)); 
            if(selectionBox) selectionBox.update();
            
            // [ä¿®æ”¹] ä½¿ç”¨ composer æ›¿ä»£ renderer
            // renderer.render(scene, camera);  <-- åˆ æ‰æˆ–æ³¨é‡Šè¿™è¡Œ
            if (composer) composer.render();    // <-- æ”¹ç”¨è¿™è¡Œ
            else renderer.render(scene, camera); // é™çº§å…¼å®¹
        }

        function startGame() {
            try {
                logToScreen("Initializing Renderer & Scene...");
                setDomText('heart-text-display', heartScore);
                window.switchCategory('floor'); 
                
                renderer = new THREE.WebGLRenderer({ 
                    antialias: false, // å…³é—­è‡ªå¸¦æŠ—é”¯é½¿ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨åæœŸå¤„ç†(SMAA)æ¥æŠ—é”¯é½¿ï¼Œæ€§èƒ½æ›´å¥½ä¸”å…¼å®¹AO
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true
                }); 
                renderer.setSize(window.innerWidth, window.innerHeight); 
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±å¡é¡¿

                renderer.shadowMap.enabled = true; 
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

                // 3. è‰²å½©ç©ºé—´ä¸è‰²è°ƒæ˜ å°„ (å…³é”®ï¼)
                renderer.outputColorSpace = THREE.SRGBColorSpace; // ç¡®ä¿çº¹ç†å’Œå…‰ç…§é¢œè‰²å‡†ç¡®
                renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒ
                renderer.toneMappingExposure = 1.2; // æ›å…‰åº¦ï¼Œé…åˆå…‰ç…§å¼ºåº¦è°ƒæ•´

                document.body.appendChild(renderer.domElement);

                scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0f7fa);
                const aspect=window.innerWidth/window.innerHeight; const d=12; camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000); camera.position.set(20, 20, 20); camera.lookAt(0,0,0);
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2.1;

                // === [æ–°ç‰ˆ UI é€‚é…] ç»‘å®šæ—¶é—´æ»‘å—ä¸é‡ç½®æŒ‰é’® ===
                const hudSlider = document.getElementById('time-slider-hud'); // æ–°çš„ID
                const timeResetBtn = document.getElementById('time-reset-btn'); // æ–°çš„ID

                // 1. æ»‘å—æ‹–åŠ¨ï¼šåˆ‡æ¢åˆ°æ‰‹åŠ¨æ¨¡å¼
                if (hudSlider) {
                    hudSlider.addEventListener('input', (e) => {
                        isTimeAuto = false; 
                        visualHour = parseFloat(e.target.value);
                        // å˜ç°ï¼Œè¡¨ç¤ºç¦»å¼€äº†è‡ªåŠ¨æ¨¡å¼
                        if(timeResetBtn) timeResetBtn.style.color = '#999'; 
                    });
                }

                // 2. é‡ç½®æŒ‰é’®ç‚¹å‡»ï¼šæ¢å¤è‡ªåŠ¨æ¨¡å¼
                if (timeResetBtn) {
                    timeResetBtn.onclick = () => {
                        isTimeAuto = true;
                        // å˜ç»¿ï¼Œè¡¨ç¤ºæ­£åœ¨åŒæ­¥
                        timeResetBtn.style.color = '#2ecc71'; 
                        updateStatusText("æ—¶é—´å·²åŒæ­¥ç°å®");
                        
                        // ç«‹å³åŒæ­¥æ»‘å—ä½ç½®ï¼Œé˜²æ­¢è§†è§‰è·³å˜
                        const now = new Date();
                        const vH = now.getHours() + now.getMinutes() / 60.0;
                        if(hudSlider) hudSlider.value = vH;
                    };
                }

                // [æ–°å¢] æ—¥å¿—è°ƒè¯•å‡½æ•°çš„ç©ºå£³ (é˜²æ­¢æŠ¥é”™)
                //window.debugGenDiary = function() { console.log("å¾…å®ç°: ç”Ÿæˆæ—¥è®°"); updateStatusText("Debug: ç”Ÿæˆæ—¥è®° (å¾…å®ç°)"); };
                //window.debugClearDiary = function() { console.log("å¾…å®ç°: æ¸…ç©ºæ—¥è®°"); updateStatusText("Debug: æ¸…ç©ºæ—¥è®° (å¾…å®ç°)"); };


                window.addEventListener('keydown', (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    const key = e.key.toLowerCase();
                    if (key === 'r' && ghostMesh && currentItemData.type !== 'wall') { rotateItem(); }
                    switch (key) { case 'w': moveKeys.w = true; break; case 'a': moveKeys.a = true; break; case 's': moveKeys.s = true; break; case 'd': moveKeys.d = true; break; }
                });
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    switch (key) { case 'w': moveKeys.w = false; break; case 'a': moveKeys.a = false; break; case 's': moveKeys.s = false; break; case 'd': moveKeys.d = false; break; }
                });
                
                hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 2.0); 
                scene.add(hemiLight);

                const al = new THREE.AmbientLight(0xffffff, 0.5); 
                scene.add(al);
                
                sunLight = new THREE.DirectionalLight(0xffdfba, 3.0); // å¼ºåº¦æé«˜
                sunLight.position.set(15,25,10); 
                sunLight.castShadow=true; 
                
                // ä¼˜åŒ–é˜´å½±å‚æ•°
                sunLight.shadow.mapSize.width=2048; 
                sunLight.shadow.mapSize.height=2048; 
                sunLight.shadow.bias = -0.0001; 
                sunLight.shadow.normalBias = 0.02; 
                sunLight.shadow.camera.left=-20; sunLight.shadow.camera.right=20; sunLight.shadow.camera.top=20; sunLight.shadow.camera.bottom=-20; 
                scene.add(sunLight);
                
                celestialGroup = new THREE.Group(); scene.add(celestialGroup);
                sunMesh = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color:0xffff00})); celestialGroup.add(sunMesh);
                moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,16,16), new THREE.MeshStandardMaterial({color:0xffffff,emissive:0x222222})); celestialGroup.add(moonMesh);
                sunMesh.visible = false; moonMesh.visible = false;
                
                raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();
                const fg=new THREE.PlaneGeometry(12,12); const fm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.floor.color}); floorPlane=new THREE.Mesh(fg, fm); floorPlane.rotation.x=-Math.PI/2; floorPlane.receiveShadow=true; scene.add(floorPlane);
                //æ˜¾ç¤ºç½‘æ ¼
                //const gh=new THREE.GridHelper(12,24,0xffffff,0xffffff); gh.position.y=0.01; gh.material.opacity=0.2; gh.material.transparent=true; scene.add(gh);
                
                const wm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.wall.color});
                const w1=new THREE.Mesh(new THREE.BoxGeometry(10,3,0.5), wm); w1.position.set(0,1.5,-5.25); w1.receiveShadow=true; w1.castShadow=true; scene.add(w1); obstacles.push(w1);
                const w2=new THREE.Mesh(new THREE.BoxGeometry(0.5,3,10), wm); w2.position.set(-5.25,1.5,0); w2.receiveShadow=true; w2.castShadow=true; scene.add(w2); obstacles.push(w2);
                wallGroup = [w1, w2];
                
                logToScreen("Spawning Cat...");
                
                // [ä¿®å¤] å¿…é¡»å…ˆå®šä¹‰ newCat å˜é‡ï¼Œä¸‹é¢æ¢å¤å­˜æ¡£æ—¶æ‰èƒ½ç”¨
                const newCat = new Cat(scene, 0xffa502); 
                cats.push(newCat);

                // === [å…³é”®ä¿®æ”¹] è¯»å–å­˜æ¡£å¹¶æ¢å¤åœºæ™¯ ===
                const savedData = gameSaveManager.loadGame();

                if (savedData) {
                    updateStatusText("æ£€æµ‹åˆ°å­˜æ¡£ï¼Œæ­£åœ¨æ¢å¤...");
                    
                    // 1. æ¢å¤çŒ«å’ªå±æ€§ (ç°åœ¨ newCat å­˜åœ¨äº†ï¼Œå°±ä¸ä¼šæŠ¥é”™äº†)
                    if (savedData.catStats) {
                        newCat.stats.hunger = savedData.catStats.hunger;
                        newCat.stats.toilet = savedData.catStats.toilet;
                    }

                    // 2. æ¢å¤å®¶å…·
                    if (savedData.furniture && savedData.furniture.length > 0) {
                        savedData.furniture.forEach(fData => {
                            // æŸ¥æ‰¾æ•°æ®åº“é…ç½®
                            // æ³¨æ„ï¼šå¦‚æœæ˜¯ mystery_boxï¼Œå®ƒä¸åœ¨ DB é‡Œï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œæˆ–è€…æˆ‘ä»¬åœ¨ DB é‡ŒåŠ ä¸Š mystery_box çš„å®šä¹‰
                            // ä½ çš„ä»£ç ä¹‹å‰å†™äº† const boxDbItem = { id: 'mystery_box'... }ï¼Œè¿™é‡Œæˆ‘ä»¬ç®€å•å¤„ç†ï¼Œæš‚ä¸æ¢å¤ç®±å­ï¼Œæˆ–è€…åªæ¢å¤æ™®é€šå®¶å…·
                            // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬æš‚æ—¶åªæ¢å¤ DB é‡Œæœ‰çš„å®¶å…·ã€‚ç®±å­å› ä¸ºæ˜¯éšæœºç”Ÿæˆçš„ï¼Œä¸¢äº†å°±ä¸¢äº†ï¼ˆæˆ–è€…ä½ éœ€è¦æŠŠ mystery_box åŠ å…¥ FURNITURE_DBï¼‰
                            
                            let itemConfig = FURNITURE_DB.find(i => i.id === fData.id);
                            
                            // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯ç¥ç§˜ç®±å­
                            if (fData.id === 'mystery_box') {
                                // é‡æ–°ç”Ÿæˆç®±å­æ¯”è¾ƒéº»çƒ¦ï¼Œè¿™é‡Œæš‚æ—¶è·³è¿‡ç®±å­çš„æ¢å¤ï¼Œé¿å…å¤æ‚
                                // å¦‚æœéå¸¸éœ€è¦æ¢å¤ç®±å­ï¼Œéœ€è¦æŠŠ spawnMysteryBox é€»è¾‘æ‹†åˆ†
                                return; 
                            }

                            if (itemConfig) {
                                const modelGroup = prepareModel(itemConfig);
                                if (modelGroup) {
                                    modelGroup.position.set(fData.pos.x, fData.pos.y, fData.pos.z);
                                    modelGroup.rotation.y = fData.rot.y;
                                    
                                    // å®ä¾‹åŒ–ç±»
                                    const furnClass = new Furniture(modelGroup, itemConfig);
                                    
                                    // æ¢å¤åŠŸèƒ½çŠ¶æ€ (æ»¡/ç©º)
                                    if (fData.funcState && furnClass.functionalState) {
                                        furnClass.functionalState = fData.funcState;
                                        furnClass.updateVisuals();
                                    }
                                    
                                    // æ·»åŠ å…‰ç…§é€»è¾‘ (å¤åˆ¶ confirmPlace é‡Œçš„å…‰ç…§ä»£ç )
                                    if(itemConfig.light) {
                                        if (itemConfig.lightType === 'point') { 
                                            const bulb = new THREE.PointLight(0xffaa00, 0.8, 5); 
                                            let lx = 0, ly = 0.3, lz = 0;
                                            if (itemConfig.lightOffset) { lx = itemConfig.lightOffset.x || 0; ly = itemConfig.lightOffset.y || 0; lz = itemConfig.lightOffset.z || 0; }
                                            bulb.position.set(lx, ly, lz); bulb.castShadow = true; modelGroup.add(bulb); 
                                        } else { 
                                            const sl = new THREE.SpotLight(0xfff0dd, 5); sl.position.set(0,0,0); sl.target.position.set(0,0,5); sl.angle = Math.PI / 3; sl.penumbra = 0.5; sl.castShadow = true; modelGroup.add(sl); modelGroup.add(sl.target); 
                                        }
                                        if(itemConfig.type === 'wall') addSkyBacking(modelGroup, itemConfig.size);
                                    }

                                    scene.add(modelGroup);
                                    placedFurniture.push(modelGroup);
                                }
                            }
                        });
                    }
                } else {
                    updateStatusText("æ–°æ¸¸æˆï¼Œæ— å­˜æ¡£");
                    // åªæœ‰åœ¨æ–°æ¸¸æˆæ—¶ï¼Œæ‰éœ€è¦ç‰¹æ®Šçš„åˆå§‹åŒ–ï¼ˆå¦‚æœä»¥åæœ‰å¼•å¯¼æµç¨‹çš„è¯ï¼‰
                }




                window.addEventListener('resize', onWindowResize); window.addEventListener('pointermove', onMove); window.addEventListener('pointerdown', onDown); window.addEventListener('pointerup', onUp);
                window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode==='placing_new') cancelPlace(); else if(mode==='moving_old') cancelMove(); else deselect(); });
                
                document.getElementById('btn-move').onclick=()=>{if(selectedObject)startMovingOld(selectedObject);hideContextMenu();}
                document.getElementById('btn-delete').onclick=()=>{if(selectedObject)deleteSelected();hideContextMenu();}
                document.getElementById('btn-cancel').onclick=()=>{deselect();hideContextMenu();}

                // === [æ–°å¢] åœ¨ startGame åº•éƒ¨è°ƒç”¨åæœŸå¤„ç†åˆå§‹åŒ– ===
                initPostProcessing();

                logToScreen("Game Loop Starting...");
                animate();
            } catch(e) {
                console.error(e);
                logToScreen("STARTGAME CRASH: " + e.message, 'error');
            }
        }

        // === [æ–°å¢] å…¨å±€æ—¥è®°å®ä¾‹ä¸äº¤äº’å‡½æ•° ===
        const diaryManager = new DiaryManager();

        // [æ–°å¢] å…³é”®ä¿®å¤ï¼šæŠŠå®ä¾‹æŒ‚è½½åˆ° windowï¼Œè®© HTML é‡Œçš„ onclick èƒ½æ‰¾åˆ°å®ƒ
        window.diaryManager = diaryManager; 

        // [ä¿®æ”¹] window.toggleDiary: æ‰“å¼€æ—¶è§¦å‘ flushPendingEvents
        window.toggleDiary = function() {
            const modal = document.getElementById('diary-modal');
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                
                // [ä¿®æ”¹] æ‰“å¼€æ—¥è®°å‰ï¼Œå…ˆå¤„ç†æ‰€æœ‰å¾…å†™å…¥çš„äº‹ä»¶
                diaryManager.flushPendingEvents(); 

                diaryManager.viewingDate = new Date(); 
                diaryManager.renderPage();
                
                diaryManager.updateUIHint(false);
            } else {
                modal.classList.add('hidden');
            }
        };

        // [ä¿®æ”¹] debugGenDiary: ç›´æ¥è°ƒç”¨ logEvent
        window.debugGenDiary = function() {
            const msgs = [
                "ä¸¤è„šå…½ä»Šå¤©ä¸€ç›´åœ¨å±å¹•å‰å‘å‘†ï¼ŒçœŸè®©äººæ‹…å¿ƒã€‚",
                "åˆšåˆšé‚£åªèšŠå­é£å¾—å¥½æ…¢ï¼Œä½†æˆ‘æ‡’å¾—åŠ¨ã€‚",
                "æƒ³åƒé«˜çº§ç½å¤´ï¼Œç°åœ¨çš„çŒ«ç²®å£æ„Ÿä¸€èˆ¬ã€‚",
                "åœ¨æ²™å‘åº•ä¸‹å‘ç°äº†ä¸€ä¸ªä¸¢å¤±å·²ä¹…çš„ç“¶ç›–ï¼"
            ];
            const randomMsg = msgs[Math.floor(Math.random() * msgs.length)];
            
            // [ä¿®æ”¹] è°ƒç”¨ logEventï¼Œä¼šè¿›å…¥ pendingEvents
            diaryManager.logEvent('debug_event', { item: randomMsg }, 50); // èµ‹äºˆä¸€ä¸ªä¸­ç­‰æƒé‡
            updateStatusText("Debug: å·²ç”Ÿæˆä¸€æ¡æµ‹è¯•äº‹ä»¶");
        };
        // debugClearDiary ä¿æŒä¸å˜

        window.debugClearDiary = function() {
            diaryManager.clearAll();
            updateStatusText("æ—¥è®°å·²æ¸…ç©º");
        };

        // [æ–°å¢] UI äº¤äº’å‡½æ•°
        window.toggleTimePopover = function() {
            const pop = document.getElementById('time-popover');
            if (pop) pop.classList.toggle('hidden');
        };

window.toggleShop = function() {
            const shop = document.getElementById('shop-panel-container');
            if (shop.classList.contains('hidden-bottom')) {
                shop.classList.remove('hidden-bottom'); 
                
                const scrollDiv = document.getElementById('items-scroll');
                if(scrollDiv) {
                    scrollDiv.scrollLeft = 0;
                    // [è°ƒè¯•] çœ‹çœ‹å®é™…å®½åº¦
                    console.log(`ScrollWidth: ${scrollDiv.scrollWidth}, ClientWidth: ${scrollDiv.clientWidth}`);
                    // å¦‚æœ ScrollWidth <= ClientWidthï¼Œè¯´æ˜å†…å®¹ä¸å¤Ÿå¤šï¼Œä¸éœ€è¦æ»šåŠ¨ï¼Œè‡ªç„¶æ²¡æœ‰æ»šåŠ¨æ¡
                }
            } else {
                shop.classList.add('hidden-bottom'); 
            }
        };

        function init() { try { loadAssets(() => { updateStatusText("èµ„æºåŠ è½½å®Œæ¯•"); const ls = document.getElementById('loading-screen'); if(ls) ls.style.display = 'none'; if(!scene) startGame(); }); } catch(e) { console.error(e); alert("Init Error: " + e.message); } }
        
        init();
    </script>
</body>
</html>
