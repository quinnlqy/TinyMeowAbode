<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŒ«å’ªçš„å®¶ - é˜¶æ®µ46: è¯Šæ–­ä¿®å¤ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f7fa; font-family: 'Microsoft YaHei', sans-serif; transition: background-color 1s; }
        canvas { display: block; outline: none; }
        
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s;}
        #loading-text { font-size: 20px; color: #555; margin-bottom: 10px; }
        #progress-bar { width: 200px; height: 5px; background: #ddd; margin-bottom: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #ffaa00; transition: width 0.2s; }
        #force-start-btn { display: none; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-top: 10px;}
        
        /* å±å¹•é”™è¯¯æ—¥å¿— (é»‘åŒ£å­) */
        #debug-console { 
            position: absolute; bottom: 0; left: 0; width: 300px; max-height: 200px; 
            background: rgba(0,0,0,0.8); color: #ff5555; font-family: monospace; font-size: 12px; 
            overflow-y: auto; padding: 10px; z-index: 99999; pointer-events: none;
            display: none; /* é»˜è®¤éšè—ï¼Œæœ‰é”™æ‰æ˜¾ */
        }

        #top-ui { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 20; }
        #clock-panel { background: rgba(255,255,255,0.9); padding: 10px 20px; border-radius: 20px; font-size: 24px; font-weight: bold; color: #333; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 10px; pointer-events: auto; }
        #day-icon { font-size: 28px; }
        #heart-panel { background: rgba(255,255,255,0.95); padding: 8px 15px; border-radius: 20px; font-size: 18px; color: #e74c3c; font-weight: bold; display: flex; gap: 10px; align-items: center; pointer-events: auto; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        
        .debug-btn { background: #555; color: white; border: none; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; }
        .debug-btn:hover { background: #333; }

        #tutorial { position: absolute; top: 80px; left: 20px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; pointer-events: none; z-index: 5; }
        #context-menu { position: absolute; display: none; background: white; padding: 8px; border-radius: 8px; z-index: 100; flex-direction: column; gap: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); pointer-events: auto; }
        .context-btn { padding: 8px 16px; border: 1px solid #eee; background: #f9f9f9; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-delete { color: red; background: #fff0f0; }
        
        .status-valid { color: green; font-weight: bold; }
        .status-invalid { color: red; font-weight: bold; }
        .heart-float { position: absolute; color: #e74c3c; font-weight: bold; font-size: 20px; pointer-events: none; animation: floatUp 1.5s ease-out forwards; z-index: 30; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
        .emote-bubble { position: absolute; font-size: 24px; pointer-events: none; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25; }
        @keyframes popUp { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        #shop-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; background: rgba(255, 255, 255, 0.98); border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; user-select: none; z-index: 10; }
        #tabs { display: flex; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; text-align: center; padding: 10px 0; cursor: pointer; font-size: 14px; color: #666; }
        .tab.active { background: #fff; color: #333; font-weight: bold; border-bottom: 3px solid #ffaa00; }
        #items-scroll { display: flex; gap: 12px; padding: 15px; overflow-x: auto; white-space: nowrap; scrollbar-width: thin; }
        .item-btn { flex: 0 0 auto; width: 80px; height: 85px; border: 2px solid #eee; border-radius: 12px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; background: #fff; color: #333; position: relative; transition: all 0.2s; }
        .item-btn.selected { border: 3px solid #ffaa00; background: #fff8e1; transform: translateY(-3px); }
        .item-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; }
        .color-preview { width: 24px; height: 24px; border-radius: 50%; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.1); background-size: cover; }
        .price-tag { margin-top: 4px; font-size: 11px; color: #e74c3c; font-weight: bold; background: #fff0f0; padding: 2px 6px; border-radius: 8px; }
    </style>
    <!-- å…¨å±€é”™è¯¯æ•è· (å¼ºåŒ–ç‰ˆ) -->
    <script>
        window.onerror = function(msg, url, line) {
            const consoleDiv = document.getElementById('debug-console');
            consoleDiv.style.display = 'block';
            consoleDiv.innerHTML += `[Error] ${msg} (Line ${line})<br>`;
            document.getElementById('force-start-btn').style.display = 'block';
            return false;
        };
        // æ•è·æœªå¤„ç†çš„ Promise é”™è¯¯ (å¦‚ fetch å¤±è´¥)
        window.onunhandledrejection = function(event) {
            const consoleDiv = document.getElementById('debug-console');
            consoleDiv.style.display = 'block';
            consoleDiv.innerHTML += `[Promise Error] ${event.reason}<br>`;
        };
    </script>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-text">èµ„æºåŠ è½½ä¸­...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <button id="force-start-btn" onclick="window.forceStart()">âš ï¸ è·³è¿‡åŠ è½½</button>
    </div>
    
    <div id="debug-console"></div>

    <div id="top-ui">
        <div id="clock-panel">
            <span id="day-icon">â˜€ï¸</span>
            <span id="game-time">08:00</span>
        </div>
        <div id="heart-panel">
            â¤ï¸ <span id="heart-count">500</span>
            <div>
                <button class="debug-btn" onclick="debugAddMoney()">+$$</button>
                <button class="debug-btn" onclick="debugResetCat()">é‡ç½®çŒ«</button>
            </div>
        </div>
    </div>

    <div id="tutorial">
        <strong>V46 è¯Šæ–­ç‰ˆ</strong><br>
        1. ä¿®å¤å¯åŠ¨é»‘å±é—®é¢˜<br>
        2. æ¢å›ç¨³å®šCDN<br>
        3. å¦‚æœ‰æŠ¥é”™è¯·çœ‹å·¦ä¸‹è§’<br>
        <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;">
            <span id="status-text">åˆå§‹åŒ–...</span>
        </div>
    </div>

    <div id="context-menu">
        <div class="context-btn" id="btn-move">ç§»åŠ¨ä½ç½®</div>
        <div class="context-btn btn-delete" id="btn-delete">åˆ é™¤å®¶å…·</div>
        <div class="context-btn" id="btn-cancel">å–æ¶ˆé€‰ä¸­</div>
    </div>

    <div id="shop-panel">
        <div id="tabs">
            <div class="tab active" onclick="switchCategory('floor')">å®¶å…·</div>
            <div class="tab" onclick="switchCategory('small')">å°ç‰©</div>
            <div class="tab" onclick="switchCategory('wall')">å¢™å£</div>
            <div class="tab" onclick="switchCategory('decor')">è£…ä¿®</div>
        </div>
        <div id="items-scroll"></div>
    </div>

    <!-- âš ï¸ åˆ‡æ¢å› esm.shï¼Œè¿™é€šå¸¸å¯¹ Module æ”¯æŒæ›´ç¨³å®š -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // 5ç§’åæ˜¾ç¤ºè·³è¿‡æŒ‰é’®
        setTimeout(() => { 
            const ls = document.getElementById('loading-screen');
            if(ls && ls.style.display !== 'none') {
                document.getElementById('force-start-btn').style.display='block';
            }
        }, 5000);

        const CAT_CONFIG = { scale: 0.35, rotateX: 0, rotateY: 0, yOffset: 0, idleIndex: 2, walkIndex: 7, sleepIndex: 1, petIndex: 1 };
        const SKY_COLORS = { night: new THREE.Color(0x1a1a2e), dawn: new THREE.Color(0xffaa99), day: new THREE.Color(0xe0f7fa), dusk: new THREE.Color(0x6a5acd) };
        const DEFAULT_DECOR = { floor: { color: 0xF5F5DC, texture: null }, wall:  { color: 0xEBE5D1, texture: null } };
        
        let scene, camera, renderer, controls;
        let raycaster, pointer, floorPlane, wallGroup;
        let sunLight, hemiLight;
        let sunMesh, moonMesh, celestialGroup;
        const gameClock = new THREE.Clock(); 
        
        let gameTime = 8.0; 
        const TIME_SPEED = 2.0; 

        const loadedModels = {}; 
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        
        let mode = 'idle', ghostMesh = null, currentItemData = null, currentRotation = 0, canPlace = false;
        let selectedObject = null, selectionBox = null, editingObjectOriginalPos = null, editingObjectOriginalQuat = null;
        let longPressTimer = null, startPointer = new THREE.Vector2();
        
        const obstacles = []; 
        const placedFurniture = []; 
        const cats = []; 
        let heartScore = 500; 
        let currentCategory = 'floor'; 
        let activeDecorId = { floor: null, wall: null };

        const FURNITURE_DB = [
            { id: 'rug',      type: 'floor', layer: 0, name: 'åœ†åœ°æ¯¯', price: 10,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'rug.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'bed',      type: 'floor', layer: 1, name: 'çŒ«çª',   price: 40,  color: 0xe67e22, size: {x:1, y:0.5, z:1}, modelFile: 'bed.glb', modelScale: 1.0, canSleep: true, fixBottom: true },
            { id: 'sofa',     type: 'floor', layer: 1, name: 'å¤§æ²™å‘', price: 150, color: 0xe74c3c, size: {x:3, y:1, z:1},   modelFile: 'sofa.glb', modelScale: 1.0, canSleep: true, fixBottom: true },
            { id: 'cat_tree', type: 'floor', layer: 1, name: 'çŒ«çˆ¬æ¶', price: 100, color: 0x8e44ad, size: {x:1, y:2, z:1},   modelFile: 'cat_tree.glb', modelScale: 1.0 },
            { id: 'table',    type: 'floor', layer: 1, isSurface: true, surfaceHeight: 0.8, name: 'æœ¨æ¡Œ', price: 60,  color: 0x8d6e63, size: {x:1.5, y:0.8, z:1.5}, modelFile: 'table.glb', modelScale: 1.0 },
            { id: 'mug',      type: 'small', layer: 2, name: 'é©¬å…‹æ¯', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'mug.glb', modelScale: 1.0, fixBottom: true },
            { id: 'lamp',     type: 'small', layer: 2, name: 'å°ç¯',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'lamp.glb', modelScale: 1.0, fixBottom: true },
            { id: 'plant',    type: 'wall',  layer: 1, name: 'å£æŒ‚è—¤', price: 20,  color: 0x2ecc71, size: {x:0.5, y:1, z:0.2}, modelFile: 'plant.glb', modelScale: 1.0 },
            { id: 'painting', type: 'wall',  layer: 1, name: 'é£æ™¯ç”»', price: 50,  color: 0xFFD700, size: {x:1, y:1, z:0.1}, modelFile: 'painting.glb', modelScale: 1.0 },
            { id: 'window',   type: 'wall',  layer: 1, name: 'è½åœ°çª—', price: 120, color: 0x87CEEB, size: {x:1.5, y:2, z:0.2}, light: true, lightType: 'spot', modelFile: 'window_large.glb', modelScale: 1.0 },
            { id: 'floor_wood', type: 'decor', name: 'æœ¨çº¹åœ°æ¿', price: 50, color: 0x8d6e63, decorType: 'floor', textureFile: 'wood.jpg' }, 
            { id: 'floor_tile', type: 'decor', name: 'ç™½ç“·ç –',   price: 50, color: 0xeeeeee, decorType: 'floor', textureFile: 'tile.jpg' },
            { id: 'wall_pink',  type: 'decor', name: 'æ¸©é¦¨ç²‰å¢™', price: 50, color: 0xffcdd2, decorType: 'wall',  textureFile: 'wallpaper.jpg' },
            { id: 'wall_blue',  type: 'decor', name: 'æ¸…çˆ½è“å¢™', price: 50, color: 0xb3e5fc, decorType: 'wall' }
        ];

        window.switchCategory = function(cat) {
            currentCategory = cat;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const tabs = document.querySelectorAll('.tab');
            if(cat==='floor') tabs[0].classList.add('active'); 
            else if(cat==='small') tabs[1].classList.add('active'); 
            else if(cat==='wall') tabs[2].classList.add('active');
            else tabs[3].classList.add('active'); 
            renderShopItems(cat);
        };

        window.forceStart = function() { 
            const ls = document.getElementById('loading-screen');
            if(ls) ls.style.display = 'none';
            if(!scene) startGame();
        }
        window.debugAddMoney = function() { updateMoney(100); };
        window.debugResetCat = function() { cats.forEach(c => c.resetCooldown()); updateStatusText("çŒ«å’ªä¸å†ç”Ÿæ°”äº†"); };

        function sanitizeMaterial(child) {
            if (child.isMesh) {
                child.castShadow = true; child.receiveShadow = true;
                if (child.material.map) child.material.map.colorSpace = THREE.SRGBColorSpace;
                child.material.metalness = 0.0; child.material.roughness = 0.8; 
                child.material.needsUpdate = true;
            }
        }

        function loadAssets(callback) {
            const loadingScreen = document.getElementById('loading-screen');
            const progressFill = document.getElementById('progress-fill');
            const files = [];
            files.push({ key: 'cat', path: './assets/models/cat.glb' });
            FURNITURE_DB.forEach(i => { if(i.modelFile) files.push({ key: i.id, path: './assets/models/'+i.modelFile }); });

            if(files.length===0) { callback(); return; }
            let count = 0;
            files.forEach(f => {
                const isObj = f.path.toLowerCase().endsWith('.obj');
                const l = isObj ? objLoader : gltfLoader;
                l.load(f.path, (data) => {
                    const sceneData = isObj ? data : data.scene;
                    const anims = isObj ? [] : data.animations;
                    sceneData.traverse(sanitizeMaterial);
                    loadedModels[f.key] = { scene: sceneData, animations: anims };
                    count++; check();
                }, undefined, (err)=>{ console.warn("Missing: "+f.path); count++; check(); });
            });
            function check() {
                progressFill.style.width = Math.floor((count/files.length)*100)+'%';
                if(count===files.length) { setTimeout(()=>{ if(loadingScreen) loadingScreen.remove(); callback(); }, 500); }
            }
        }

        function applyDecorVisuals(item) {
            const setMaterial = (mesh, config) => {
                if (config.textureFile) {
                    textureLoader.load('./assets/textures/' + config.textureFile, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                        if (config.decorType === 'floor') tex.repeat.set(4, 4); else tex.repeat.set(2, 1);
                        mesh.material.map = tex; mesh.material.color.setHex(0xffffff); mesh.material.needsUpdate = true;
                    });
                } else {
                    mesh.material.map = null; mesh.material.color.setHex(config.color); mesh.material.needsUpdate = true;
                }
            };
            if (item.decorType === 'floor') setMaterial(floorPlane, item);
            else if (item.decorType === 'wall') wallGroup.forEach(wall => setMaterial(wall, item));
        }
        function restoreDecorState(type) {
            const currentId = activeDecorId[type];
            if (currentId) { const item = FURNITURE_DB.find(i => i.id === currentId); if (item) applyDecorVisuals(item); } 
            else { const def = DEFAULT_DECOR[type]; applyDecorVisuals({ decorType: type, color: def.color, textureFile: def.texture }); }
        }
        function handleDecorClick(item) {
            const type = item.decorType;
            if (activeDecorId[type] === item.id) { activeDecorId[type] = null; restoreDecorState(type); updateStatusText("å·²æ¢å¤é»˜è®¤æ ·å¼"); } 
            else { if (heartScore >= item.price) { updateMoney(-item.price); activeDecorId[type] = item.id; applyDecorVisuals(item); updateStatusText("å·²è£…ä¿®: " + item.name); } else { alert("é‡‘é’±ä¸è¶³ï¼"); } }
            renderShopItems('decor'); 
        }

        function spawnMysteryBox(sourceItem) {
            if (placedFurniture.find(f => f.userData.isBox)) return;
            const x = (Math.random() - 0.5) * 8; const z = (Math.random() - 0.5) * 8;
            let size = { x: 0.6, y: 0.5, z: 0.6 };
            if (sourceItem) {
                if (sourceItem.id === 'rug') { size = { x: 1.0, y: 0.8, z: 0.5 }; }
                else {
                    size.x = Math.max(0.5, sourceItem.size.x * 0.8);
                    size.y = Math.max(0.5, sourceItem.size.y * 0.8);
                    size.z = Math.max(0.5, sourceItem.size.z * 0.8);
                }
            }
            const boxGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xcd853f });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.set(x, size.y/2, z); box.castShadow = true; box.receiveShadow = true;
            box.userData = { isBox: true, dbItem: { layer: 1, name: "å¿«é€’ç®±", type: 'floor' } };
            scene.add(box); placedFurniture.push(box);
            showEmote(box.position, 'ğŸ“¦');
        }

        function getSkyColor(hour) {
            let c1, c2, ratio;
            if (hour < 5) return SKY_COLORS.night;
            else if (hour < 7) { 
                if(hour < 6) { c1=SKY_COLORS.night; c2=SKY_COLORS.dawn; ratio=hour-5; }
                else { c1=SKY_COLORS.dawn; c2=SKY_COLORS.day; ratio=hour-6; }
            }
            else if (hour < 17) return SKY_COLORS.day;
            else if (hour < 19) {
                if(hour < 18) { c1=SKY_COLORS.day; c2=SKY_COLORS.dusk; ratio=hour-17; }
                else { c1=SKY_COLORS.dusk; c2=SKY_COLORS.night; ratio=hour-18; }
            }
            else return SKY_COLORS.night;
            return c1.clone().lerp(c2, ratio);
        }

        function updateEnvironment(dt) {
            gameTime += dt * TIME_SPEED;
            if (gameTime >= 24) gameTime = 0;
            
            const hour = Math.floor(gameTime);
            const min = Math.floor((gameTime - hour) * 60);
            document.getElementById('game-time').innerText = `${hour.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}`;
            document.getElementById('day-icon').innerText = (hour >= 6 && hour < 18) ? 'â˜€ï¸' : 'ğŸŒ™';

            const skyColor = getSkyColor(gameTime);
            scene.background = skyColor;
            document.body.style.backgroundColor = `rgb(${skyColor.r*255},${skyColor.g*255},${skyColor.b*255})`;

            const angle = (gameTime - 12) / 12 * Math.PI; 
            const radius = 60;
            const sunX = Math.sin(angle) * radius;
            const sunY = Math.cos(angle) * radius;

            if (sunMesh && moonMesh) {
                sunMesh.position.set(sunX, sunY, -20);
                moonMesh.position.set(-sunX, -sunY, -20);
                sunMesh.scale.set(0.2, 0.2, 0.2); moonMesh.scale.set(0.2, 0.2, 0.2);
            }

            if (sunY > 0) {
                sunLight.intensity = 1.2 * (sunY / radius); 
                sunLight.position.set(sunX, sunY, 10);
                hemiLight.intensity = 0.8 + 0.2 * (sunY / radius);
                
                placedFurniture.forEach(f => {
                    const light = f.children.find(c => c.isLight);
                    if (light) light.visible = false;
                });
            } else {
                sunLight.intensity = 0;
                hemiLight.intensity = 0.4; 
                
                placedFurniture.forEach(f => {
                    const light = f.children.find(c => c.isLight);
                    if (light) light.visible = true;
                });
            }
        }

        class Cat {
            constructor(scene, color) {
                this.scene = scene; this.state='idle'; this.targetPos=new THREE.Vector3(); this.interactTarget=null; this.timer=0; this.mixer=null; this.actions={}; this.isAnimated=false;
                this.petCount = 0; this.patience = 5 + Math.floor(Math.random() * 6); 
                this.angryTime = 0; 
                this.mesh=new THREE.Group(); this.scene.add(this.mesh); this.downRay=new THREE.Raycaster(); this.downRay.ray.direction.set(0,-1,0); this.forwardRay=new THREE.Raycaster();

                try {
                    if (loadedModels['cat']) {
                        const model = SkeletonUtils.clone(loadedModels['cat'].scene);
                        model.scale.set(CAT_CONFIG.scale, CAT_CONFIG.scale, CAT_CONFIG.scale);
                        model.position.y = CAT_CONFIG.yOffset;
                        model.rotation.x = CAT_CONFIG.rotateX; model.rotation.y = CAT_CONFIG.rotateY;
                        this.mesh.add(model);

                        if (loadedModels['cat'].animations.length > 0) {
                            this.isAnimated = true; this.mixer = new THREE.AnimationMixer(model);
                            const anims = loadedModels['cat'].animations;
                            const idleAnim = anims[CAT_CONFIG.idleIndex] || anims[0]; 
                            const walkAnim = anims[CAT_CONFIG.walkIndex] || anims[1];
                            const sleepAnim = anims[CAT_CONFIG.sleepIndex] || anims[0];
                            const petAnim = anims[CAT_CONFIG.petIndex] || anims[0]; 

                            this.actions['idle'] = this.mixer.clipAction(idleAnim);
                            this.actions['walk'] = this.mixer.clipAction(walkAnim);
                            this.actions['sleep'] = this.mixer.clipAction(sleepAnim);
                            this.actions['pet'] = this.mixer.clipAction(petAnim); 
                            
                            this.actions['sleep'].setLoop(THREE.LoopOnce); this.actions['sleep'].clampWhenFinished = true;
                            this.actions['idle'].play(); this.currentAction = this.actions['idle'];
                        }
                    } else { this.mesh.add(this.createBlockCat(color)); }
                } catch (e) {
                    console.error("Cat init error:", e);
                    this.mesh.add(this.createBlockCat(color)); // Fallback if SkeletonUtils fails
                }

                this.mesh.position.set(0, 0, 0); this.chooseNewAction();
            }
            createBlockCat(color) { const g=new THREE.Group(); const m=new THREE.MeshStandardMaterial({color:color}); const b=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.6),m); b.position.y=0.15; g.add(b); const h=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.3,0.3),m); h.position.set(0,0.4,0.4); g.add(h); return g; }
            
            update(dt) {
                if(this.isAnimated && this.mixer) this.mixer.update(dt);
                const rayOrigin=this.mesh.position.clone(); rayOrigin.y=5; this.downRay.set(rayOrigin, new THREE.Vector3(0,-1,0));
                const hitCandidates=[floorPlane, ...placedFurniture.filter(f=>f.userData.dbItem&&f.userData.dbItem.layer===1)];
                const hits=this.downRay.intersectObjects(hitCandidates, true); 
                let targetY=0; if(hits.length>0) targetY=hits[0].point.y;
                this.mesh.position.y += (targetY - this.mesh.position.y) * 0.2;

                if(this.interactTarget) { if(!placedFurniture.includes(this.interactTarget)||!this.interactTarget.visible) { this.interrupt(); return; } }
                if (this.state === 'angry') { if (Date.now() > this.angryTime) { this.state = 'idle'; this.patience = 5 + Math.floor(Math.random() * 6); this.petCount = 0; updateStatusText("çŒ«å’ªæ°”æ¶ˆäº†"); } }

                if(this.state==='walking') {
                    this.playAction('walk');
                    const dir=new THREE.Vector3().subVectors(this.targetPos,this.mesh.position); dir.y=0;
                    const dist=dir.length();
                    const forwardDir = dir.clone().normalize();
                    this.forwardRay.set(this.mesh.position.clone().add(new THREE.Vector3(0,0.3,0)), forwardDir);
                    const obstacles = placedFurniture.filter(f => f.userData.dbItem.layer > 0 && f !== this.interactTarget);
                    const cols = this.forwardRay.intersectObjects(obstacles, true);
                    if(cols.length>0 && cols[0].distance<0.5) { this.chooseNewAction(); return; }

                    if(dist<0.1) {
                        this.mesh.position.x=this.targetPos.x; this.mesh.position.z=this.targetPos.z;
                        if(this.interactTarget) this.enterInteraction(); else { this.state='idle'; this.timer=2; }
                    } else {
                        dir.normalize(); this.mesh.position.add(dir.multiplyScalar(2.0*dt)); this.mesh.lookAt(this.targetPos.x, this.mesh.position.y, this.targetPos.z);
                    }
                } else if(this.state==='idle') {
                    this.playAction('idle');
                    this.timer-=dt; if(this.timer<=0) this.chooseNewAction();
                } else if(this.state==='interacting') {
                    if (this.interactTarget && this.interactTarget.userData.dbItem.canSleep) this.playAction('sleep');
                    else this.playAction('idle');
                    this.timer-=dt; if(Math.random()<0.01)spawnHeart(this.mesh.position); if(this.timer<=0)this.leaveInteraction();
                } else if(this.state==='petting') {
                    this.playAction('pet'); 
                }
            }
            playAction(name) { if(this.isAnimated && this.currentAction !== this.actions[name]) { this.currentAction.fadeOut(0.2); this.actions[name].reset().fadeIn(0.2).play(); this.currentAction = this.actions[name]; } }
            
            pet() {
                if (this.state === 'angry') { showEmote(this.mesh.position, 'ğŸ’¢'); return; }
                if (this.petCount >= this.patience) {
                    showEmote(this.mesh.position, 'ğŸ’¢'); 
                    this.state = 'angry';
                    this.angryTime = Date.now() + 15 * 60 * 1000; 
                    this.chooseNewAction(); 
                    updateStatusText("çŒ«å’ªç”Ÿæ°”äº† (15m CD)");
                } else {
                    this.petCount++;
                    spawnHeart(this.mesh.position);
                    showEmote(this.mesh.position, 'ğŸ˜»');
                    this.state = 'petting';
                    if (this.resetTimer) clearTimeout(this.resetTimer);
                    this.resetTimer = setTimeout(() => { if (this.state === 'petting') this.state = 'idle'; }, 2000);
                }
            }
            resetCooldown() { this.angryTime = 0; this.state = 'idle'; this.petCount = 0; this.patience = 10; showEmote(this.mesh.position, 'â¤ï¸'); }
            interrupt() { showEmote(this.mesh.position,'â“'); this.state='idle'; this.interactTarget=null; this.timer=1; } 
            chooseNewAction() {
                const boxes = placedFurniture.filter(f => f.userData.isBox);
                const valid=placedFurniture.filter(f=>f.userData.dbItem.layer===1 && f.visible && f.userData.type!=='wall' && !f.userData.isBox);
                let target = null;
                if (boxes.length > 0 && Math.random() < 0.8) target = boxes[0];
                else if (valid.length > 0 && Math.random() < 0.6) target = valid[Math.floor(Math.random()*valid.length)];

                if(target) { this.interactTarget=target; this.targetPos.copy(this.interactTarget.position); this.state='walking'; }
                else { this.interactTarget=null; this.targetPos.set((Math.random()-0.5)*8,0,(Math.random()-0.5)*8); this.state='walking'; }
            }
            enterInteraction() { 
                this.state='interacting'; this.timer=5+Math.random()*5; 
                if (this.interactTarget && this.interactTarget.userData.isBox) { this.timer = 15; showEmote(this.mesh.position, 'ğŸ“¦'); }
                if(this.interactTarget) this.mesh.rotation.y=Math.random()*Math.PI*2; 
            }
            leaveInteraction() { this.state='idle'; this.timer=0.5; }
        }

        function startGame() {
            try {
                document.getElementById('heart-count').innerText = heartScore;
                window.switchCategory('floor');
                
                renderer = new THREE.WebGLRenderer({ antialias: true }); 
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true; 
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace; 
                document.body.appendChild(renderer.domElement);
                
                scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0f7fa);
                const aspect=window.innerWidth/window.innerHeight; const d=12;
                camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
                camera.position.set(20, 20, 20); camera.lookAt(0,0,0);
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2.1;
                
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.2); 
                scene.add(hemiLight);
                
                const al = new THREE.AmbientLight(0xffffff, 0.9); 
                scene.add(al);
                
                sunLight = new THREE.DirectionalLight(0xffdfba, 1.2); 
                sunLight.position.set(15,25,10); sunLight.castShadow=true;
                sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.left=-20; sunLight.shadow.camera.right=20; 
                sunLight.shadow.camera.top=20; sunLight.shadow.camera.bottom=-20; 
                scene.add(sunLight);
                
                celestialGroup = new THREE.Group();
                scene.add(celestialGroup);
                sunMesh = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                celestialGroup.add(sunMesh);
                moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 }));
                celestialGroup.add(moonMesh);
                
                raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();
                
                const fg=new THREE.PlaneGeometry(12,12); const fm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.floor.color});
                floorPlane=new THREE.Mesh(fg, fm); floorPlane.rotation.x=-Math.PI/2; floorPlane.receiveShadow=true; scene.add(floorPlane);
                const gh=new THREE.GridHelper(12,24,0xffffff,0xffffff); gh.position.y=0.01; gh.material.opacity=0.2; gh.material.transparent=true; scene.add(gh);
                const wm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.wall.color});
                const w1=new THREE.Mesh(new THREE.BoxGeometry(10,3,0.5), wm); w1.position.set(0,1.5,-5.25); w1.receiveShadow=true; w1.castShadow=true; scene.add(w1); obstacles.push(w1);
                const w2=new THREE.Mesh(new THREE.BoxGeometry(0.5,3,10), wm); w2.position.set(-5.25,1.5,0); w2.receiveShadow=true; w2.castShadow=true; scene.add(w2); obstacles.push(w2);
                wallGroup = [w1, w2];
                
                cats.push(new Cat(scene, 0xffa502));

                window.addEventListener('resize', onWindowResize);
                window.addEventListener('pointermove', onMove); window.addEventListener('pointerdown', onDown); window.addEventListener('pointerup', onUp);
                window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode==='placing_new') cancelPlace(); else if(mode==='moving_old') cancelMove(); else deselect(); });
                window.addEventListener('keydown', (e)=>{ if((e.key==='r'||e.key==='R') && ghostMesh && currentItemData.type!=='wall') rotateItem(); });
                animate();
            } catch (e) {
                console.error("Start Game Error:", e);
                const log = document.getElementById('error-log');
                if(log) log.innerText += "\nStart Error: " + e.message;
            }
        }
        
        let lastTime=0;
        function animate(time) {
            requestAnimationFrame(animate); 
            const dt = gameClock.getDelta(); 
            updateEnvironment(dt); 
            controls.update(); 
            if(selectionBox) selectionBox.material.opacity=0.5+Math.sin(Date.now()*0.005)*0.5;
            for(const cat of cats) cat.update(dt);
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>