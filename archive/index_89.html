<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áå´Âí™ÁöÑÂÆ∂ - V89 Âä®ÁîªÊ∑±Â∫¶ÂÆöÂà∂Áâà</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f7fa; font-family: 'Microsoft YaHei', sans-serif; transition: background-color 1s; }
        canvas { display: block; outline: none; }
        
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s;}
        #loading-text { font-size: 20px; color: #555; margin-bottom: 10px; }
        #progress-bar { width: 200px; height: 5px; background: #ddd; margin-bottom: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #ffaa00; transition: width 0.2s; }
        #force-start-btn { display: none; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-top: 10px;}
        
        #debug-console { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 80%; max-height: 150px; overflow-y: auto;
            background: rgba(0, 0, 0, 0.7); color: #0f0; 
            padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px;
            z-index: 10001; pointer-events: none; display: none; 
        }
        .log-error { color: #ff5555; font-weight: bold; }
        .log-warn { color: #ffaa00; }

        #top-ui { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 20; }
        #clock-wrapper { background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); pointer-events: auto; display: flex; flex-direction: column; gap: 5px; align-items: center; min-width: 140px; }
        #clock-display { font-size: 24px; font-weight: bold; color: #333; display: flex; align-items: center; gap: 8px; }
        #day-icon { font-size: 24px; }
        #time-control { display: flex; align-items: center; gap: 5px; font-size: 10px; color: #666; width: 100%; }
        input[type=range] { flex: 1; cursor: pointer; height: 4px; accent-color: #ffaa00; }

        #heart-panel { background: rgba(255,255,255,0.95); padding: 8px 15px; border-radius: 20px; font-size: 18px; color: #e74c3c; font-weight: bold; display: flex; gap: 10px; align-items: center; pointer-events: auto; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .debug-btn { background: #555; color: white; border: none; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; }

        #tutorial { position: absolute; top: 150px; left: 20px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; pointer-events: none; z-index: 5; }
        #context-menu { position: absolute; display: none; background: white; padding: 8px; border-radius: 8px; z-index: 100; flex-direction: column; gap: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); pointer-events: auto; }
        .context-btn { padding: 8px 16px; border: 1px solid #eee; background: #f9f9f9; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-delete { color: red; background: #fff0f0; }
        
        #confirm-dialog {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 20000;
            text-align: center; display: none; width: 280px; font-family: 'Microsoft YaHei', sans-serif;
        }
        #confirm-dialog h3 { margin-top: 0; color: #333; }
        #confirm-dialog p { color: #666; margin-bottom: 20px; }
        .dialog-btns { display: flex; justify-content: space-around; margin-top: 20px; }
        .dialog-btn { padding: 8px 20px; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; transition: transform 0.1s; }
        .btn-yes { background: #ffaa00; color: white; }
        .btn-no { background: #eee; color: #333; }
        .dialog-btn:active { transform: scale(0.95); }

        .status-valid { color: green; font-weight: bold; }
        .status-invalid { color: red; font-weight: bold; }
        .heart-float { position: absolute; color: #e74c3c; font-weight: bold; font-size: 20px; pointer-events: none; animation: floatUp 1.5s ease-out forwards; z-index: 30; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
        .emote-bubble { position: absolute; font-size: 24px; pointer-events: none; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25; }
        @keyframes popUp { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        #shop-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; background: rgba(255, 255, 255, 0.98); border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; user-select: none; z-index: 10; }
        #tabs { display: flex; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; text-align: center; padding: 10px 0; cursor: pointer; font-size: 14px; color: #666; }
        .tab.active { background: #fff; color: #333; font-weight: bold; border-bottom: 3px solid #ffaa00; }
        #items-scroll { display: flex; gap: 12px; padding: 15px; overflow-x: auto; white-space: nowrap; scrollbar-width: thin; }
        .item-btn { flex: 0 0 auto; width: 80px; height: 85px; border: 2px solid #eee; border-radius: 12px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; background: #fff; color: #333; position: relative; transition: all 0.2s; }
        .item-btn.selected { border: 3px solid #ffaa00; background: #fff8e1; transform: translateY(-3px); }
        .item-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; }
        .color-preview { width: 24px; height: 24px; border-radius: 50%; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.1); background-size: cover; }
        .price-tag { margin-top: 4px; font-size: 11px; color: #e74c3c; font-weight: bold; background: #fff0f0; padding: 2px 6px; border-radius: 8px; }

        .bubble { position: absolute; top: -100px; left: -100px; background: white; padding: 8px 15px; border-radius: 20px; border: 2px solid #333; font-size: 20px; pointer-events: none; transform: translate(-50%, -100%); z-index: 1000; opacity: 1; transition: opacity 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .bubble.hidden { opacity: 0; visibility: hidden; }
        .bubble::after { content: ''; position: absolute; bottom: -6px; left: 50%; margin-left: -6px; border-width: 6px 6px 0; border-style: solid; border-color: #333 transparent transparent transparent; }
        .panel { position: absolute; bottom: 20px; left: 20px; background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 12px; width: 180px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); font-family: 'Arial', sans-serif; z-index: 900; display: block; }
        .panel.hidden { display: none !important; }
        .panel h3 { margin: 0 0 10px 0; font-size: 16px; color: #333; text-align: center; }
        .stat-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; }
        .stat-row span { width: 40px; font-weight: bold; color: #555; }
        .progress-bar { flex-grow: 1; background: #e0e0e0; height: 10px; border-radius: 5px; overflow: hidden; margin-left: 5px; border: 1px solid #ccc; }
        #bar-hunger { background: #ff9f43; height: 100%; transition: width 0.3s; }
        #bar-toilet { background: #54a0ff; height: 100%; transition: width 0.3s; }
    </style>
    <script>
        function logToScreen(msg, type = 'info') {
            const consoleDiv = document.getElementById('debug-console');
            if (consoleDiv) {
                consoleDiv.style.display = 'block';
                const line = document.createElement('div');
                line.textContent = `> ${msg}`;
                if (type === 'error') line.className = 'log-error';
                else if (type === 'warn') line.className = 'log-warn';
                consoleDiv.appendChild(line);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
            console.log(msg);
        }
        window.onerror = function(msg, url, line) { 
            logToScreen(`ERROR: ${msg} (Line ${line})`, 'error');
            document.getElementById('force-start-btn').style.display = 'block';
            return false; 
        };
    </script>
</head>
<body>

    <div id="debug-console">V89 Á≥ªÁªüÊó•Âøó...</div>

    <div id="loading-screen">
        <div id="loading-text">ËµÑÊ∫êÂä†ËΩΩ‰∏≠...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <button id="force-start-btn" onclick="window.forceStart()">‚ö†Ô∏è Âº∫Âà∂ËøõÂÖ•Ê∏∏Êàè</button>
    </div>

    <!-- Ë°•Ë¥ßÁ°ÆËÆ§ÂºπÁ™ó -->
    <div id="confirm-dialog">
        <h3 id="dialog-title">Ë°•ÂÖÖÁå´Á≤Æ?</h3>
        <p id="dialog-msg">ÈúÄË¶ÅÊ∂àËÄó 10 Áà±ÂøÉ</p>
        <div class="dialog-btns">
            <button class="dialog-btn btn-no" onclick="closeDialog()">ÂèñÊ∂à</button>
            <button class="dialog-btn btn-yes" id="btn-confirm-yes">Á°ÆÂÆö</button>
        </div>
    </div>

    <div id="top-ui">
        <div id="clock-wrapper">
            <div id="clock-display"><span id="day-icon">‚òÄÔ∏è</span><span id="game-time">08:00</span></div>
            <div id="time-control"><span>ÊÖ¢</span><input type="range" id="time-slider" min="0" max="10" value="2"><span>Âø´</span></div>
        </div>
        <div id="heart-panel">
            ‚ù§Ô∏è <span id="heart-count">500</span>
            <div><button class="debug-btn" onclick="debugAddMoney()">+$$</button><button class="debug-btn" onclick="debugResetCat()">ÈáçÁΩÆÁå´</button></div>
        </div>
    </div>

    <div id="tutorial">
        <strong>V89 Âä®ÁîªÊ∑±Â∫¶ÂÆöÂà∂Áâà</strong><br>
        1. Áù°Ëßâ‰∏çË¢´ÊâìÊñ≠(30Áßí)<br>
        2. Âä®‰Ωú‰ºòÂåñ(Ë∫∫„ÄÅÂêÉ„ÄÅÊãâ)<br>
        3. ‰øÆÂ§ç‰∫§‰∫í‰∏éÊä•Èîô<br>
        <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;">
            <span id="status-text">ÂàùÂßãÂåñ...</span>
        </div>
    </div>

    <div id="context-menu">
        <div class="context-btn" id="btn-move">ÁßªÂä®‰ΩçÁΩÆ</div>
        <div class="context-btn btn-delete" id="btn-delete">Âà†Èô§ÂÆ∂ÂÖ∑</div>
        <div class="context-btn" id="btn-cancel">ÂèñÊ∂àÈÄâ‰∏≠</div>
    </div>

    <div id="shop-panel">
        <div id="tabs">
            <div class="tab active" onclick="switchCategory('floor')">ÂÆ∂ÂÖ∑</div>
            <div class="tab" onclick="switchCategory('small')">Â∞èÁâ©</div>
            <div class="tab" onclick="switchCategory('wall')">Â¢ôÂ£Å</div>
            <div class="tab" onclick="switchCategory('decor')">Ë£Ö‰øÆ</div>
        </div>
        <div id="items-scroll"></div>
    </div>

    <div id="cat-bubble" class="bubble hidden"><span id="bubble-icon">üêü</span></div>
    <div id="cat-panel" class="panel hidden">
        <h3>Áå´Âí™Áä∂ÂÜµ</h3>
        <div class="stat-row"><span>È•øÈ•ø</span><div class="progress-bar"><div id="bar-hunger" style="width: 100%;"></div></div></div>
        <div class="stat-row"><span>‰æø‰æø</span><div class="progress-bar"><div id="bar-toilet" style="width: 100%;"></div></div></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.160.0", "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        setTimeout(() => { const ls = document.getElementById('loading-screen'); if(ls && ls.style.display !== 'none') document.getElementById('force-start-btn').style.display='block'; }, 5000);

        // === 1. ÂÖ®Â±ÄÈÖçÁΩÆ‰∏éÂèòÈáè ===
        const CAT_CONFIG = { 
            scale: 0.35, rotateX: 0, rotateY: 0, yOffset: 0, 
            // [‰øÆÊîπ] Âä®ÁîªÁ¥¢ÂºïÊò†Â∞Ñ
            anim: {
                sleep: 0,   // 1. ‰æßË∫∫
                happy: 1,   // 2. È´òÂÖ¥/‰πûËÆ®
                idle: 2,    // 3. ÂØªÊâæ (‰Ωú‰∏∫ÈªòËÆ§ÂæÖÊú∫)
                eat: 3,     // 4. ÂêÉÈ•≠
                urgent: 5,  // 6. ÁùÄÊÄ• (‰∏äÂéïÊâÄ)
                walk: 8     // ÂÅáËÆæËµ∞Ë∑ØÊòØ 7
            }
        };

        const SKY_COLORS = { night: new THREE.Color(0x1a1a2e), dawn: new THREE.Color(0xffaa99), day: new THREE.Color(0xe0f7fa), dusk: new THREE.Color(0x6a5acd) };
        const DEFAULT_DECOR = { floor: { color: 0xF5F5DC, texture: null }, wall:  { color: 0xEBE5D1, texture: null } };
        
        let scene, camera, renderer, controls;
        let raycaster, pointer, floorPlane, wallGroup;
        let sunLight, hemiLight;
        let sunMesh, moonMesh, celestialGroup;
        const gameClock = new THREE.Clock(); 
        
        let gameTime = 8.0; let timeSpeed = 0.2; 
        const moveKeys = { w: false, a: false, s: false, d: false };
        const loadedModels = {}; 
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        
        let mode = 'idle', ghostMesh = null, currentItemData = null, currentRotation = 0, canPlace = false;
        let selectedObject = null, selectionBox = null, editingObjectOriginalPos = null, editingObjectOriginalQuat = null;
        let longPressTimer = null, startPointer = new THREE.Vector2();
        
        const obstacles = []; const placedFurniture = []; const cats = []; 
        let heartScore = 500; let currentCategory = 'floor'; let activeDecorId = { floor: null, wall: null }; let skyPanels = []; 
        let pendingInteraction = null;

        // === 2. Êï∞ÊçÆÂ∫ì (FURNITURE_DB) ===
        const FURNITURE_DB = [
            { 
                id: 'food_bowl', name: 'Áå´È£üÁõÜ', price: 50, type: 'functional', subType: 'food', color: 0xffffff,
                modelFile: 'FoodBowl_Empty.glb',      
                fullModelFile: 'FoodBowl_Full.glb',   
                modelScale: 0.3, fixBottom: true, size: {x:0.8, y:0.5, z:0.8}
            },
            { 
                id: 'litter_box', name: 'Áå´Á†ÇÁõÜ', price: 80, type: 'functional', subType: 'toilet', color: 0x888888,
                modelFile: 'LitterBox_Dirty.glb',    
                fullModelFile: 'LitterBox_Clean.glb',
                modelScale: 0.5, fixBottom: true, size: {x:1.0, y:0.6, z:1.0}
            },
            { id: 'rug',      type: 'floor', layer: 0, name: 'ÂúÜÂú∞ÊØØ', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'RoundRug.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'rug_squre',type: 'floor', layer: 0, name: 'ÊñπÂú∞ÊØØ', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'rug_squre.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'bed',      type: 'floor', layer: 1, name: 'Áå´Á™ù',   price: 40,  color: 0xe67e22, size: {x:1, y:0.5, z:1}, modelFile: 'bed.glb', modelScale: 0.8, canSleep: true, fixBottom: true },
            { id: 'sofa',     type: 'floor', layer: 1, name: 'Â§ßÊ≤ôÂèë', price: 150, color: 0xe74c3c, size: {x:3, y:1, z:1},   modelFile: 'sofa.glb', modelScale: 2.0, canSleep: true, fixBottom: true },
            { id: 'cat_tree', type: 'floor', layer: 1, name: 'Áå´Áà¨Êû∂', price: 100, color: 0x8e44ad, size: {x:1, y:2, z:1},   modelFile: 'cat_tree.glb', modelScale: 1.0 , fixBottom: true},
            { id: 'book_shelf', type: 'floor', layer: 1, name: '‰π¶Êû∂', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'book_shelf.glb', modelScale: 1.0, fixBottom: true },
            { id: 'Television', type: 'floor', layer: 1, name: 'ÁîµËßÜ', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'Television.glb', modelScale: 1.0, fixBottom: true },
            { id: 'table',    type: 'floor', layer: 1, isSurface: true, surfaceHeight: 0.8, name: 'Êú®Ê°å', price: 60,  color: 0x8d6e63, size: {x:1.5, y:0.8, z:1.5}, modelFile: 'table.glb', modelScale: 1.0, fixBottom: true },
            { id: 'ChrismasTree',    type: 'floor', layer: 1, name: 'Âú£ËØûÊ†ë', price: 100,  color: 0x8d6e63, size: {x:1.5, y:2, z:1.5}, modelFile: 'ChrismasTree.glb', modelScale: 1.8, fixBottom: true },
            { id: 'fireplace',    type: 'floor', layer: 1, name: 'Â£ÅÁÇâ', price: 100,  color: 0x8d6e63, size: {x:1.5, y:2, z:1.5}, modelFile: 'fireplace.glb', modelScale: 1.8, fixBottom: true },
            { id: 'mug',      type: 'small', layer: 2, name: 'È©¨ÂÖãÊùØ', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'mug.glb', modelScale: 0.2, fixBottom: true },
            { id: 'lamp',     type: 'small', layer: 2, name: 'Âè∞ÁÅØ',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'lamp.glb', modelScale: 1.0, fixBottom: true },
            { id: 'floor_lamp',     type: 'small', layer: 2, name: 'ËêΩÂú∞ÁÅØ',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'floor_lamp.glb', modelScale: 1.0, fixBottom: true, lightOffset: { x: 0, y: 1.8, z: 0 }  },
            { id: 'books',     type: 'small', layer: 2, name: '‰π¶',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4},  modelFile: 'books.glb', modelScale: 5.0, fixBottom: true },
            { id: 'wall_plant',    type: 'wall',  layer: 1, name: 'Â£ÅÊåÇËó§', price: 20,  color: 0x2ecc71, size: {x:2, y:0.5, z:0.5}, modelFile: 'wall_plant.glb', modelScale: 0.8 },
            { id: 'painting', type: 'wall',  layer: 1, name: 'È£éÊôØÁîª', price: 50,  color: 0xFFD700, size: {x:1, y:1, z:0.1}, modelFile: 'painting.glb', modelScale: 1.0 },
            { id: 'curtain', type: 'wall', layer: 1, name: 'Á™óÂ∏ò', price: 80, color: 0xFFFFFF, size: {x:2.0, y:2.0, z:0.5}, modelFile: 'curtain.glb', modelScale: 1.5, autoCenter: true, allowOverlap: true },
            { id: 'wall_star', type: 'wall', layer: 1, name: 'ÊòüÊòüÊåÇÈ•∞', price: 30, color: 0xFFFF00, size: {x:0.5, y:0.5, z:0.5}, modelFile: 'WallDecorate_Star.glb', modelScale: 1.0, autoCenter: true, allowOverlap: true },
            { id: 'window',   type: 'wall',  layer: 1, name: 'Â§ßÁ™ó', price: 120, color: 0x87CEEB, size: {x:1.8, y:1.8, z:0.2}, light: true, lightType: 'spot', modelFile: 'window_large.glb', autoCenter: true, modelScale: 1, manualOffset: { x: 0, y: 0, z: 0 } },
            { id: 'window2', type: 'wall',  layer: 1, name: 'Â∞èÁ™ó', price: 120, color: 0x87CEEB, size: {x:1.8, y:2, z:0.2}, light: true, lightType: 'spot', modelFile: 'window_large.glb', modelScale: 0.5, autoCenter: true },
            { id: 'floor_wood', type: 'decor', name: 'Êú®Á∫πÂú∞Êùø', price: 50, color: 0x8d6e63, decorType: 'floor', textureFile: 'wood.jpg' }, 
            { id: 'floor_tile', type: 'decor', name: 'ÁôΩÁì∑Á†ñ',   price: 50, color: 0xdbc2a3, decorType: 'floor', textureFile: 'tile.jpg' },
            { id: 'wall_pink',  type: 'decor', name: 'Ê∏©È¶®Á≤âÂ¢ô', price: 50, color: 0xffcdd2, decorType: 'wall',  textureFile: 'wallpaper.jpg' },
            { id: 'wall_blue',  type: 'decor', name: 'Ê∏ÖÁàΩËìùÂ¢ô', price: 50, color: 0xb3e5fc, decorType: 'wall' }
        ];

        // === 3. ËæÖÂä©ÂáΩÊï∞ ===
        function setDomText(id, text) { const el = document.getElementById(id); if (el) el.innerText = text; else console.warn(`Element #${id} not found`); }
        window.closeDialog = function() { document.getElementById('confirm-dialog').style.display = 'none'; pendingInteraction = null; }
        
        function showConfirmDialog(title, msg, onYes) {
            setDomText('dialog-title', title); setDomText('dialog-msg', msg);
            document.getElementById('confirm-dialog').style.display = 'block';
            const yesBtn = document.getElementById('btn-confirm-yes'); const newBtn = yesBtn.cloneNode(true); yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.onclick = () => { onYes(); window.closeDialog(); };
        }
        function updateStatusText(t,c) { const e = document.getElementById('status-text'); if(e) { e.innerText = t; e.className = c === 'valid' ? 'status-valid' : (c === 'invalid' ? 'status-invalid' : ''); } }
        function updateMoney(amt) { heartScore += amt; setDomText('heart-count', heartScore); refreshShopState(); }
        function refreshShopState() { document.querySelectorAll('.item-btn').forEach(b=>{ const p = parseInt(b.dataset.price); if(heartScore >= p) b.classList.remove('disabled'); else b.classList.add('disabled'); }); }
        function spawnHeart(pos) { const v=pos.clone(); v.y+=1; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='heart-float'; e.innerText='‚ù§ +5'; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); updateMoney(5); setTimeout(()=>e.remove(),1500); }
        function showEmote(pos,t) { const v=pos.clone(); v.y+=1.2; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='emote-bubble'; e.innerText=t; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); setTimeout(()=>e.remove(),1000); }

        function sanitizeMaterial(child) {
            if (child.isMesh) {
                child.castShadow = true; child.receiveShadow = true;
                if (child.material.map) child.material.map.colorSpace = THREE.SRGBColorSpace;
                const isGlass = child.name.toLowerCase().includes('glass') || child.name.toLowerCase().includes('window');
                child.material.metalness = 0.0; child.material.roughness = 0.8; 
                if (isGlass) { child.material.transparent = true; child.material.opacity = 0.3; child.material.color.setHex(0x88ccff); } 
                else { child.material.transparent = false; child.material.opacity = 1.0; }
                child.material.needsUpdate = true;
            }
        }

        function loadAssets(callback) {
            const files = [];
            files.push({ key: 'cat', path: './assets/models/cat.glb' });
            files.push({ key: 'box', path: './assets/models/cardboardBoxOpen.glb' });
            FURNITURE_DB.forEach(i => { 
                if(i.modelFile) files.push({ key: i.id, path: './assets/models/'+i.modelFile }); 
                if(i.fullModelFile) files.push({ key: i.fullModelFile, path: './assets/models/'+i.fullModelFile });
            });

            if(files.length===0) { callback(); return; }
            let count = 0;
            const progressFill = document.getElementById('progress-fill');
            const loadingScreen = document.getElementById('loading-screen');
            logToScreen(`Start loading ${files.length} assets...`);
            
            files.forEach(f => {
                const isObj = f.path.toLowerCase().endsWith('.obj');
                const l = isObj ? objLoader : gltfLoader;
                l.load(f.path, (data) => {
                    const sceneData = isObj ? data : data.scene;
                    const anims = isObj ? [] : data.animations;
                    sceneData.traverse(sanitizeMaterial);
                    loadedModels[f.key] = { scene: sceneData, animations: anims };
                    count++; check();
                }, undefined, (err)=>{ 
                    console.warn("Missing asset:", f.path); 
                    logToScreen(`Failed to load: ${f.path}`, 'warn'); 
                    count++; check(); 
                });
            });
            function check() {
                if(progressFill) progressFill.style.width = Math.floor((count/files.length)*100)+'%';
                if(count===files.length) { 
                    logToScreen("Assets loading finished.");
                    setTimeout(()=>{ if(loadingScreen) loadingScreen.remove(); callback(); }, 500); 
                }
            }
        }

        // [‰øÆÂ§ç] Ë°•Âõû Decor ÂáΩÊï∞
        function applyDecorVisuals(item) {
            const setMaterial = (mesh, config) => {
                if (config.textureFile) {
                    textureLoader.load('./assets/textures/' + config.textureFile, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace; tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                        if (config.decorType === 'floor') tex.repeat.set(4, 4); else tex.repeat.set(2, 1);
                        mesh.material.map = tex; mesh.material.color.setHex(0xffffff); mesh.material.needsUpdate = true;
                    }, undefined, (err) => {console.error("Failed to load texture:", config.textureFile, err);});
                } else { mesh.material.map = null; mesh.material.color.setHex(config.color); mesh.material.needsUpdate = true; }
            };
            if (item.decorType === 'floor') setMaterial(floorPlane, item);
            else if (item.decorType === 'wall') wallGroup.forEach(wall => setMaterial(wall, item));
        }
        function restoreDecorState(type) { const currentId = activeDecorId[type]; if (currentId) { const item = FURNITURE_DB.find(i => i.id === currentId); if (item) applyDecorVisuals(item); } else { const def = DEFAULT_DECOR[type]; applyDecorVisuals({ decorType: type, color: def.color, textureFile: def.texture }); } }



        function prepareModel(item) {
            let sceneData = null;
            if (loadedModels[item.id]) sceneData = loadedModels[item.id].scene;
            else if (item.modelFile && loadedModels[item.modelFile]) sceneData = loadedModels[item.modelFile].scene;

            if (!sceneData) return null;

            const raw = sceneData.clone();
            raw.traverse(sanitizeMaterial);
            if (item.fixBottom) { const box = new THREE.Box3().setFromObject(raw); raw.position.y = -box.min.y; }
            if (item.autoCenter) { const box = new THREE.Box3().setFromObject(raw); const c = new THREE.Vector3(); box.getCenter(c); raw.position.x -= c.x; raw.position.y -= c.y; raw.position.z -= c.z; }
            if (item.manualOffset) { raw.position.x += (item.manualOffset.x || 0); raw.position.y += (item.manualOffset.y || 0); raw.position.z += (item.manualOffset.z || 0); }
            
            raw.scale.set(1,1,1); // [ÂÖ≥ÈîÆ] Âº∫Âà∂ÈáçÁΩÆ raw mesh Áº©Êîæ

            const group = new THREE.Group();
            group.add(raw);
            const s = item.modelScale || 1.0; 
            group.scale.set(s, s, s);
            return group;
        }

        // === 4. ÁÆ±Â≠êÈÄªËæë ===
        function spawnMysteryBox(sourceItem) {
            let x, z, attempts = 0;
            do {
                x = (Math.random() - 0.5) * 7; z = (Math.random() - 0.5) * 7; attempts++;
                var tooClose = placedFurniture.some(f => {
                    const dist = Math.hypot(f.position.x - x, f.position.z - z); let otherRadius = 0.5;
                    if (f.userData.dbItem && f.userData.dbItem.size) otherRadius = Math.max(f.userData.dbItem.size.x, f.userData.dbItem.size.z) / 2;
                    return dist < (otherRadius + 0.7);
                });
            } while (tooClose && attempts < 20);

            let boxMesh; let isTall = false; let realHeight = 0.5;
            if (loadedModels['box']) {
                const raw = loadedModels['box'].scene.clone(); raw.traverse(sanitizeMaterial);
                const box3_raw = new THREE.Box3().setFromObject(raw); const center = new THREE.Vector3(); box3_raw.getCenter(center); raw.position.sub(center); 
                boxMesh = new THREE.Group(); boxMesh.add(raw);
                let sx = 0.5, sy = 0.5, sz = 0.5;
                if (sourceItem && sourceItem.size) {
                    let tx = Math.max(0.6, sourceItem.size.x * 1.2); let ty = Math.max(0.2, sourceItem.size.y * 1.2); let tz = Math.max(0.6, sourceItem.size.z * 1.2);
                    if (sourceItem.id.includes('rug')) ty = 0.2;
                    const box3 = new THREE.Box3().setFromObject(raw); const baseSize = new THREE.Vector3(); box3.getSize(baseSize);
                    sx = baseSize.x > 0.01 ? tx / baseSize.x : 1; sy = baseSize.y > 0.01 ? ty / baseSize.y : 1; sz = baseSize.z > 0.01 ? tz / baseSize.z : 1;
                }
                raw.scale.set(sx, sy, sz); isTall = sy > sx * 1.5 || sy > sz * 1.5; if (isTall) raw.rotation.x = Math.PI / 2; raw.updateMatrix(); 
                const finalBox = new THREE.Box3().setFromObject(raw); raw.position.y -= finalBox.min.y; realHeight = finalBox.max.y - finalBox.min.y;
            } else {
                let size = { x: 0.6, y: 0.5, z: 0.6 }; const boxGeo = new THREE.BoxGeometry(size.x, size.y, size.z); const boxMat = new THREE.MeshStandardMaterial({ color: 0xcd853f });
                boxMesh = new THREE.Mesh(boxGeo, boxMat); boxMesh.position.y = size.y / 2; realHeight = size.y;
            }
            boxMesh.position.set(x, 0, z); boxMesh.rotation.y = Math.random() * Math.PI * 2;
            boxMesh.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            scene.add(boxMesh); 
            const boxDbItem = { id: 'mystery_box', name: "Âø´ÈÄíÁÆ±", price: 0, type: 'floor', layer: 1 };
            const boxFurnitureInstance = new Furniture(boxMesh, boxDbItem); boxFurnitureInstance.isBox = true; boxFurnitureInstance.isTipped = isTall; boxFurnitureInstance.boxHeight = realHeight;
            placedFurniture.push(boxMesh); showEmote(boxMesh.position, 'üì¶');
        }

        // === 5. ÁéØÂ¢É‰∏éÁ±ª ===
        function addSkyBacking(mesh, size) {
            const width = size.x * 0.85; const height = size.y * 0.85;
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({ color: 0xe0f7fa }));
            const zPos = -size.z / 2 + 0.05; plane.position.set(0, 0, zPos); plane.rotation.set(0, 0, 0); plane.userData = { isSky: true };
            mesh.add(plane); skyPanels.push(plane);
        }

        function getSkyColor(hour) {
            let c1, c2, ratio;
            if (hour < 5) return SKY_COLORS.night; else if (hour < 7) { if(hour < 6) { c1=SKY_COLORS.night; c2=SKY_COLORS.dawn; ratio=hour-5; } else { c1=SKY_COLORS.dawn; c2=SKY_COLORS.day; ratio=hour-6; } }
            else if (hour < 17) return SKY_COLORS.day; else if (hour < 19) { if(hour < 18) { c1=SKY_COLORS.day; c2=SKY_COLORS.dusk; ratio=hour-17; } else { c1=SKY_COLORS.dusk; c2=SKY_COLORS.night; ratio=hour-18; } }
            else return SKY_COLORS.night; return c1.clone().lerp(c2, ratio);
        }
        function updateEnvironment(dt) {
            gameTime += dt * timeSpeed; if (gameTime >= 24) gameTime = 0;
            const hour = Math.floor(gameTime); const min = Math.floor((gameTime - hour) * 60);
            setDomText('game-time', `${hour.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}`);
            setDomText('day-icon', (hour >= 6 && hour < 18) ? '‚òÄÔ∏è' : 'üåô');
            const skyColor = getSkyColor(gameTime); scene.background = skyColor; document.body.style.backgroundColor = `rgb(${skyColor.r*255},${skyColor.g*255},${skyColor.b*255})`;
            skyPanels.forEach(panel => { panel.material.color.copy(skyColor); });
            const angle = (gameTime - 12) / 12 * Math.PI; const radius = 80; const sunX = Math.sin(angle) * radius; const sunY = Math.cos(angle) * radius;
            if (sunMesh && moonMesh) { sunMesh.position.set(sunX, sunY, -20); moonMesh.position.set(-sunX, -sunY, -20); sunMesh.scale.set(0.2, 0.2, 0.2); moonMesh.scale.set(0.2, 0.2, 0.2); sunMesh.visible = true; moonMesh.visible = true; }
            if (sunY > 0) { sunLight.intensity = 1.2 * (sunY / radius); sunLight.position.set(sunX, sunY, 10); hemiLight.intensity = 0.8 + 0.2 * (sunY / radius); placedFurniture.forEach(f => { const light = f.children.find(c => c.isLight); if (light) light.visible = false; }); } 
            else { sunLight.intensity = 0; hemiLight.intensity = 0.4; placedFurniture.forEach(f => { const light = f.children.find(c => c.isLight); if (light) light.visible = true; }); }
        }

        class Furniture {
            constructor(mesh, dbItem) {
                this.mesh = mesh; this.dbItem = dbItem; this.mesh.userData.parentClass = this; 
                this.functionalState = null; this.isBox = false; this.modelEmpty = null; this.modelFull = null;
                if (this.dbItem.type === 'functional') { this.initFunctionalState(); }
            }

            initFunctionalState() {
                if (this.mesh.children.length > 0) { this.modelEmpty = this.mesh.children[0]; }
                if (this.dbItem.fullModelFile) {
                    const fullItemConfig = { ...this.dbItem, id: this.dbItem.id + '_full', modelFile: this.dbItem.fullModelFile };
                    const fullGroup = prepareModel(fullItemConfig);
                    if (fullGroup) {
                        // [ÂÖ≥ÈîÆ] ÂéªÂ£≥ÈÄªËæë
                        this.modelFull = fullGroup.children[0]; 
                        this.mesh.add(this.modelFull); 
                    } else {
                        logToScreen(`Warning: Full model missing: ${this.dbItem.fullModelFile}`, 'error');
                    }
                }
                
                if (this.dbItem.subType === 'food') this.functionalState = 'full';
                else if (this.dbItem.subType === 'toilet') this.functionalState = 'clean';
                
                this.updateVisuals();
            }

            updateVisuals() {
                if (!this.modelEmpty) return;
                const setVis = (emptyVis, fullVis) => {
                    this.modelEmpty.visible = emptyVis;
                    if(this.modelFull) this.modelFull.visible = fullVis;
                }
                if (this.dbItem.subType === 'food') {
                    this.functionalState === 'full' ? setVis(false, true) : setVis(true, false);
                } else if (this.dbItem.subType === 'toilet') {
                    this.functionalState === 'clean' ? setVis(false, true) : setVis(true, false);
                }
            }

            interact() {
                const needsRefill = (this.dbItem.subType === 'food' && this.functionalState === 'empty') || 
                                    (this.dbItem.subType === 'toilet' && this.functionalState === 'dirty');

                if (needsRefill) {
                    let title = this.dbItem.subType === 'food' ? "Ë°•ÂÖÖÁå´Á≤Æ?" : "Ê∏ÖÁêÜÁå´Á†Ç?";
                    showConfirmDialog(title, "ÈúÄË¶ÅÊ∂àËÄó 10 Áà±ÂøÉ", () => {
                        this.confirmRefill();
                    });
                    return true;
                }
                return false;
            }

            confirmRefill() {
                if (heartScore >= 10) {
                    updateMoney(-10);
                    if (this.dbItem.subType === 'food') {
                        this.functionalState = 'full'; showEmote(this.mesh.position, 'üçö'); updateStatusText("Áå´Á≤ÆÂ∑≤Âä†Êª°");
                    } else {
                        this.functionalState = 'clean'; showEmote(this.mesh.position, '‚ú®'); updateStatusText("Áå´Á†ÇÁõÜÂ∑≤Ê∏ÖÁêÜ");
                    }
                    this.updateVisuals();
                } else {
                    alert("Áà±ÂøÉ‰∏çË∂≥ÔºÅ");
                }
            }

            useByCat() {
                if (this.dbItem.subType === 'food' && this.functionalState === 'full') {
                    this.functionalState = 'empty'; this.updateVisuals(); showEmote(this.mesh.position, 'üòã');
                } else if (this.dbItem.subType === 'toilet' && this.functionalState === 'clean') {
                    this.functionalState = 'dirty'; this.updateVisuals(); showEmote(this.mesh.position, 'üí©');
                }
            }
        }

        class Cat {
            constructor(scene, color) {
                this.scene = scene; 
                this.state = 'idle'; // walking, sleeping, interacting, begging, eating, pooping
                this.stats = { hunger: 80, toilet: 80 };
                this.targetFurniture = null; this.nextAction = null; 
                this.bubbleEl = document.getElementById('cat-bubble'); this.bubbleIcon = document.getElementById('bubble-icon');
                this.targetPos = new THREE.Vector3(); this.stopPos = new THREE.Vector3(); 
                this.jumpStart = new THREE.Vector3(); this.jumpEnd = new THREE.Vector3();   
                this.interactTarget = null; this.timer = 0; this.mixer = null; this.actions = {}; this.isAnimated = false;
                this.petCount = 0; this.patience = 5 + Math.floor(Math.random() * 6); this.angryTime = 0; 
                
                // Sleep Logic
                this.sleepMinDuration = 0; // Remaining forced sleep time

                this.mesh = new THREE.Group(); this.scene.add(this.mesh); 
                this.downRay = new THREE.Raycaster(); this.downRay.ray.direction.set(0,-1,0); 
                this.forwardRay = new THREE.Raycaster();

                try {
                    if (loadedModels['cat']) {
                        const model = SkeletonUtils.clone(loadedModels['cat'].scene);
                        model.scale.set(CAT_CONFIG.scale, CAT_CONFIG.scale, CAT_CONFIG.scale);
                        model.position.y = CAT_CONFIG.yOffset; model.rotation.x = CAT_CONFIG.rotateX; model.rotation.y = CAT_CONFIG.rotateY;
                        this.mesh.add(model);
                        if (loadedModels['cat'].animations.length > 0) {
                            this.isAnimated = true; this.mixer = new THREE.AnimationMixer(model);
                            const anims = loadedModels['cat'].animations; 
                            const getAnim = (idx) => anims[idx] || anims[0];
                            
                            // Map Actions based on User Request
                            this.actions['sleep'] = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.sleep));
                            this.actions['happy'] = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.happy));
                            this.actions['idle']  = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.idle));
                            this.actions['eat']   = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.eat));
                            this.actions['urgent']= this.mixer.clipAction(getAnim(CAT_CONFIG.anim.urgent));
                            this.actions['walk']  = this.mixer.clipAction(getAnim(CAT_CONFIG.anim.walk));
                            
                            // Configure Sleep Action: Once + Clamp
                            this.actions['sleep'].setLoop(THREE.LoopOnce); 
                            this.actions['sleep'].clampWhenFinished = true;

                            this.playAction('idle');
                        }
                    } else { this.mesh.add(this.createBlockCat(color)); }
                } catch (e) { console.error("Cat error:", e); this.mesh.add(this.createBlockCat(color)); }
                this.mesh.position.set(0, 0, 0); this.chooseNewAction(); 
            }
            createBlockCat(color) { const g=new THREE.Group(); const m=new THREE.MeshStandardMaterial({color:color}); const b=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.6),m); b.position.y=0.15; g.add(b); const h=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.3,0.3),m); h.position.set(0,0.4,0.4); g.add(h); return g; }
            showBubble(icon) { if (!this.bubbleEl || !this.bubbleIcon) return; this.bubbleIcon.innerText = icon; this.bubbleEl.classList.remove('hidden'); }
            hideBubble() { if (!this.bubbleEl) return; this.bubbleEl.classList.add('hidden'); }
            updateBubblePosition() { if (!this.bubbleEl || this.bubbleEl.classList.contains('hidden')) return; const pos = this.mesh.position.clone(); pos.y += 1.2; pos.project(camera); const x = (pos.x * .5 + .5) * window.innerWidth; const y = (-(pos.y * .5) + .5) * window.innerHeight; this.bubbleEl.style.left = `${x}px`; this.bubbleEl.style.top = `${y}px`; }
            updateUI() { const catPanel = document.getElementById('cat-panel'); if(!catPanel || catPanel.classList.contains('hidden')) return; const hungerBar = document.getElementById('bar-hunger'); const toiletBar = document.getElementById('bar-toilet'); if(hungerBar) hungerBar.style.width = this.stats.hunger + '%'; if(toiletBar) toiletBar.style.width = this.stats.toilet + '%'; }
            
            playAction(name) { 
                if(this.isAnimated && this.actions[name] && this.currentAction !== this.actions[name]) { 
                    if(this.currentAction) this.currentAction.fadeOut(0.2); 
                    this.actions[name].reset().fadeIn(0.2).play(); 
                    this.currentAction = this.actions[name]; 
                } 
            }

            update(dt) {
                if(this.isAnimated && this.mixer) this.mixer.update(dt);
                this.decayStats(dt); this.updateBubblePosition(); this.updateUI();

                // Âº∫Âà∂Áù°Áú†Áä∂ÊÄÅÊ£ÄÊü•
                if (this.state === 'sleeping') {
                    this.sleepMinDuration -= dt;
                    // Âè™ÊúâÂú®ÁîüÂëΩÂûÇÂç±Êó∂ÊâçÊâìÊñ≠Áù°Áú†
                    if (this.stats.hunger < 5 || this.stats.toilet < 5) {
                         this.state = 'idle'; 
                         this.sleepMinDuration = 0;
                    } 
                    else if (this.sleepMinDuration <= 0) {
                        this.state = 'idle';
                        this.chooseNewAction(); // Áù°ÈÜí‰∫Ü
                    }
                    return; // Áù°Áú†‰∏≠‰∏çÊâßË°åÂÖ∂‰ªñÈÄªËæë
                }

                if (this.state !== 'jumping') {
                    const rayOrigin = this.mesh.position.clone(); rayOrigin.y = 5; this.downRay.set(rayOrigin, new THREE.Vector3(0,-1,0));
                    const hitCandidates = [floorPlane, ...placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem && f.userData.parentClass.dbItem.layer === 1 && !f.userData.parentClass.isBox)];
                    const hits = this.downRay.intersectObjects(hitCandidates, true); let targetY = 0; if(hits.length > 0) targetY = hits[0].point.y;
                    this.mesh.position.y += (targetY - this.mesh.position.y) * 0.2;
                }
                
                // ÁõÆÊ†áÊ£ÄÊü•
                if(this.interactTarget && (!placedFurniture.includes(this.interactTarget) || !this.interactTarget.visible)) { this.interrupt(); return; }
                
                if (this.state === 'angry') { if (Date.now() > this.angryTime) { this.state = 'idle'; this.patience = 5 + Math.floor(Math.random() * 6); this.petCount = 0; updateStatusText("Áå´Âí™Ê∞îÊ∂à‰∫Ü"); document.getElementById('cat-panel').classList.add('hidden'); } }
                
                // Áä∂ÊÄÅÊú∫ÂàÜÂèë
                if(this.state === 'walking') { this.handleWalkingLogic(dt); } 
                else if (this.state === 'jumping') { this.updateJumping(dt); } 
                else if(this.state === 'idle') { this.handleIdleLogic(dt); } 
                else if(this.state === 'interacting') { this.handleInteractingLogic(dt); } 
                else if(this.state === 'petting') { this.playAction('happy'); } // Êë∏Áå´Êí≠ÊîæHappy
                else if (this.state === 'begging') { 
                    this.playAction('happy'); // ‰πûËÆ®‰πüÊòØHappy
                    this.checkIfNeedsSatisfied(); 
                    this.mesh.lookAt(camera.position.x, this.mesh.position.y, camera.position.z); 
                }
            }

            handleIdleLogic(dt) {
                this.playAction('idle'); // ÈªòËÆ§ Idle ÊòØ Searching
                // Level 1: Needs
                if (this.stats.hunger < 30) { const foodBowl = this.findAvailableFurniture('food', 'full'); if (foodBowl) { this.targetFurniture = foodBowl; this.setPath(foodBowl.userData.parentClass.mesh.position); this.state = 'walking'; this.nextAction = 'EAT'; this.hideBubble(); return; } else { this.showBubble('üêü'); this.state = 'begging'; return; } }
                if (this.stats.toilet < 40) { const litterBox = this.findAvailableFurniture('toilet', 'clean'); if (litterBox) { this.targetFurniture = litterBox; this.setPath(litterBox.userData.parentClass.mesh.position); this.state = 'walking'; this.nextAction = 'POOP'; this.hideBubble(); return; } else { this.showBubble('üí©'); this.state = 'begging'; return; } }
                
                // Random wander interval
                this.timer -= dt; if(this.timer <= 0) this.chooseNewAction();
            }

            handleWalkingLogic(dt) {
                this.playAction('walk'); const dir = new THREE.Vector3().subVectors(this.stopPos, this.mesh.position); dir.y = 0; const dist = dir.length();
                if (dist > 0.5) { const forwardDir = dir.clone().normalize(); this.forwardRay.set(this.mesh.position.clone().add(new THREE.Vector3(0,0.3,0)), forwardDir); const obstacleMeshes = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem.layer > 0 && f !== this.interactTarget); const cols = this.forwardRay.intersectObjects(obstacleMeshes, true); if(cols.length > 0 && cols[0].distance < 0.5) { this.chooseNewAction(); return; } }
                if (dist < 0.1) { this.onArriveDest(); } else { dir.normalize(); this.mesh.position.add(dir.multiplyScalar(2.0 * dt)); this.mesh.lookAt(this.stopPos.x, this.mesh.position.y, this.stopPos.z); }
            }

            handleInteractingLogic(dt) {
                // Â¶ÇÊûúÊòØÁù°Ëßâ (Áî± enterInteraction ËÆæÁΩÆ)ÔºåËøôÈáåÂÖ∂ÂÆû‰∏ç‰ºöÊâßË°åÔºåÂõ†‰∏∫ state ÂèòÊàê‰∫Ü sleeping
                // ËøôÈáåÂ§ÑÁêÜÁöÑÊòØÁé©Á∫∏ÁÆ±Á≠âÁü≠Êúü‰∫§‰∫í
                const isInsideBox = this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox && !this.interactTarget.userData.parentClass.isTipped;
                if (isInsideBox) { this.playAction('sleep'); } else { this.playAction('idle'); } // ÊöÇÊó∂Áî® idle
                
                this.timer -= dt; if(Math.random() < 0.01) spawnHeart(this.mesh.position); 
                if(this.timer <= 0) { if (isInsideBox) { this.mesh.position.copy(this.jumpStart); this.mesh.position.y = 0; } this.leaveInteraction(); }
            }

            startJump() { this.state = 'jumping'; this.playAction('idle'); this.jumpTimer = 0; this.jumpDuration = 0.6; this.jumpStart.copy(this.mesh.position); this.jumpEnd.copy(this.interactTarget.position); let h = this.interactTarget.userData.parentClass.boxHeight || 0.5; this.jumpEnd.y = h * 0.5; if (this.jumpEnd.y < 0.2) this.jumpEnd.y = 0.2; }
            updateJumping(dt) {
                this.jumpTimer += dt; let t = this.jumpTimer / this.jumpDuration; if (t > 1) t = 1;
                this.mesh.position.x = THREE.MathUtils.lerp(this.jumpStart.x, this.jumpEnd.x, t); this.mesh.position.z = THREE.MathUtils.lerp(this.jumpStart.z, this.jumpEnd.z, t);
                const height = this.jumpEnd.y + 0.5; const yBase = THREE.MathUtils.lerp(this.jumpStart.y, this.jumpEnd.y, t); const yArc = Math.sin(t * Math.PI) * height; this.mesh.position.y = yBase + yArc; this.mesh.lookAt(this.jumpEnd.x, this.mesh.position.y, this.jumpEnd.z);
                if (t >= 1) { this.mesh.rotation.x = 0; this.mesh.rotation.z = 0; this.enterInteraction(); }
            }

            pet() { 
                if (this.state === 'angry') { showEmote(this.mesh.position, 'üí¢'); return; } 
                if (this.petCount >= this.patience) { showEmote(this.mesh.position, 'üí¢'); this.state = 'angry'; this.angryTime = Date.now() + 15 * 60 * 1000; this.chooseNewAction(); updateStatusText("Áå´Âí™ÁîüÊ∞î‰∫Ü (15m CD)"); document.getElementById('cat-panel').classList.add('hidden'); } 
                else { this.petCount++; spawnHeart(this.mesh.position); showEmote(this.mesh.position, 'üòª'); this.state = 'petting'; if (this.resetTimer) clearTimeout(this.resetTimer); this.resetTimer = setTimeout(() => { if (this.state === 'petting') this.state = 'idle'; }, 2000); document.getElementById('cat-panel').classList.remove('hidden'); } 
            }
            resetCooldown() { this.angryTime = 0; this.state = 'idle'; this.petCount = 0; this.patience = 10; showEmote(this.mesh.position, '‚ù§Ô∏è'); }
            interrupt() { showEmote(this.mesh.position,'‚ùì'); this.state='idle'; this.interactTarget=null; this.timer=1; this.hideBubble();}
            leaveInteraction() { this.state = 'idle'; this.interactTarget = null; this.timer = 1; }

            // [Ê†∏ÂøÉ] ÂÜ≥Á≠ñÊ†ë
            chooseNewAction() {
                const isDay = (gameTime >= 6 && gameTime < 18);
                const boxes = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.isBox);
                const sleepers = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem.canSleep);
                const others = placedFurniture.filter(f => f.userData.parentClass && !f.userData.parentClass.isBox && !f.userData.parentClass.dbItem.canSleep && f.userData.parentClass.dbItem.layer === 1);

                let rnd = Math.random();
                let target = null;

                // Level 2: Fun (Box)
                if (boxes.length > 0 && rnd < 0.3) {
                    target = boxes[Math.floor(Math.random() * boxes.length)];
                }
                // Level 3: Sleep or Wander
                else {
                    let sleepRnd = Math.random();
                    let wantSleep = isDay ? (sleepRnd < 0.8) : (sleepRnd < 0.2); // ÁôΩÂ§©Â§öÁù°
                    
                    if (wantSleep && sleepers.length > 0) {
                        target = sleepers[Math.floor(Math.random() * sleepers.length)];
                    } else {
                        if (others.length > 0 && Math.random() < 0.5) {
                            target = others[Math.floor(Math.random() * others.length)];
                        } else {
                            target = null; // Wander
                        }
                    }
                }

                if(target) { 
                    this.interactTarget = target; 
                    this.setPath(target.position);
                    this.state = 'walking'; 
                } else { 
                    this.interactTarget = null; 
                    const randPos = new THREE.Vector3((Math.random()-0.5)*8, 0, (Math.random()-0.5)*8);
                    this.setPath(randPos);
                    this.state = 'walking'; 
                }
            }

            enterInteraction() { 
                // Âà§Êñ≠ÊòØÂê¶Áù°Ëßâ
                if (this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.dbItem.canSleep) {
                    this.state = 'sleeping';
                    this.sleepMinDuration = 30.0; // Âº∫Âà∂Áù°30Áßí
                    this.playAction('sleep'); 
                    showEmote(this.mesh.position, 'üí§');
                    return;
                }

                this.state = 'interacting'; 
                this.timer = 5 + Math.random() * 5; 
                
                // ÁÆ±Â≠êÈÄªËæë
                if (this.interactTarget && this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox) { 
                    this.timer = 15; showEmote(this.mesh.position, 'üì¶'); 
                }

                if(this.interactTarget) { 
                    const isInsideBox = this.interactTarget.userData.parentClass && this.interactTarget.userData.parentClass.isBox && !this.interactTarget.userData.parentClass.isTipped; 
                    if (!isInsideBox) { this.mesh.rotation.y = Math.random() * Math.PI * 2; } 
                }
            }

            setPath(targetPosition) { this.targetPos.copy(targetPosition); const vec = new THREE.Vector3().subVectors(this.mesh.position, targetPosition); vec.y = 0; vec.normalize(); if (this.interactTarget && this.interactTarget.userData.parentClass && (this.interactTarget.userData.parentClass.isBox || this.interactTarget.userData.parentClass.dbItem.type === 'functional')) { this.stopPos.copy(targetPosition).add(vec.multiplyScalar(0.7)); } else { this.stopPos.copy(targetPosition); } }
            decayStats(dt) { this.stats.hunger -= 0.5 * dt; this.stats.toilet -= 0.4 * dt; if(this.stats.hunger < 0) this.stats.hunger = 0; if(this.stats.toilet < 0) this.stats.toilet = 0; }
            findAvailableFurniture(subType, requiredState) { return placedFurniture.find(f => f.userData.parentClass && f.userData.parentClass.dbItem.subType === subType && f.userData.parentClass.functionalState === requiredState); }
            checkIfNeedsSatisfied() { this.playAction('happy'); if (this.stats.hunger < 30) { const food = this.findAvailableFurniture('food', 'full'); if (food || this.stats.hunger > 90) { this.state = 'idle'; this.hideBubble(); } } if (this.stats.toilet < 40) { const box = this.findAvailableFurniture('toilet', 'clean'); if (box || this.stats.toilet > 90) { this.state = 'idle'; this.hideBubble(); } } }
            
            onArriveDest() {
                if (!this.targetFurniture) { this.state = 'idle'; return; }
                const parent = this.targetFurniture.userData.parentClass;
                if (parent && parent.isBox && !parent.isTipped) { this.startJump(); return; }
                
                if (this.nextAction === 'EAT') { 
                    this.state = 'eating'; 
                    this.playAction('eat'); 
                    if(this.targetFurniture.position) this.mesh.lookAt(this.targetFurniture.position.x, this.mesh.position.y, this.targetFurniture.position.z); 
                    setTimeout(() => { 
                        if(this.state !== 'eating') return; this.stats.hunger = 100; if(this.targetFurniture && this.targetFurniture.userData.parentClass) this.targetFurniture.userData.parentClass.useByCat(); this.state = 'idle'; this.timer = 2; spawnHeart(this.mesh.position); this.targetFurniture = null; 
                    }, 5000); 
                } 
                else if (this.nextAction === 'POOP') { 
                    this.state = 'pooping'; 
                    this.playAction('urgent'); // ‰ΩøÁî®ÁùÄÊÄ•/‰∏äÂéïÊâÄÂä®Áîª
                    if(this.targetFurniture.position) this.mesh.lookAt(this.targetFurniture.position.x, this.mesh.position.y, this.targetFurniture.position.z); 
                    setTimeout(() => { 
                        if(this.state !== 'pooping') return; this.stats.toilet = 100; if(this.targetFurniture && this.targetFurniture.userData.parentClass) this.targetFurniture.userData.parentClass.useByCat(); this.state = 'idle'; this.timer = 2; spawnHeart(this.mesh.position); this.targetFurniture = null; 
                    }, 4000); 
                }
                else { 
                    if (this.interactTarget) { this.mesh.position.x = this.interactTarget.position.x; this.mesh.position.z = this.interactTarget.position.z; } this.enterInteraction(); this.nextAction = null; this.targetFurniture = null;
                }
            }
        }

        // === 6. ‰∫§‰∫í‰∏éÊ∏≤Êüì ===
        window.switchCategory = function(cat) {
            currentCategory = cat;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const tabs = document.querySelectorAll('.tab');
            const catMap = { 'floor': 0, 'small': 1, 'wall': 2, 'decor': 3 };
            if (tabs[catMap[cat]]) tabs[catMap[cat]].classList.add('active');
            renderShopItems(cat);
        };
        
        window.forceStart = function() { const ls = document.getElementById('loading-screen'); if(ls) ls.style.display = 'none'; if(!scene) startGame(); }
        window.debugAddMoney = function() { updateMoney(100); };
        window.debugResetCat = function() { cats.forEach(c => c.resetCooldown()); updateStatusText("Áå´Âí™‰∏çÂÜçÁîüÊ∞î‰∫Ü"); };

        function renderShopItems(cat) {
            const c = document.getElementById('items-scroll'); c.innerHTML = ''; 
            let typeFilter = cat; 
            FURNITURE_DB.filter(i => (i.type === typeFilter || (typeFilter === 'floor' && i.type === 'functional'))).forEach(item => {
                const b = document.createElement('div'); b.className = 'item-btn'; b.dataset.price = item.price;
                if (item.type === 'decor' && activeDecorId[item.decorType] === item.id) { b.classList.add('selected'); }
                b.onclick = (e) => { e.stopPropagation(); if (!b.classList.contains('disabled')) { startNewPlacement(item.id); } };
                if (item.type === 'decor') { b.onmouseenter = () => applyDecorVisuals(item); b.onmouseleave = () => restoreDecorState(item.decorType); }
                const col = document.createElement('div'); col.className = 'color-preview'; 
                if (item.textureFile) col.style.backgroundImage = `url(./assets/textures/${item.textureFile})`; else { const colorVal = item.color !== undefined ? item.color : 0xcccccc; col.style.background = '#' + colorVal.toString(16).padStart(6, '0'); }
                const t = document.createElement('span'); t.innerText = item.name; const p = document.createElement('div'); p.className = 'price-tag'; p.innerText = '‚ù§ ' + item.price;
                b.append(col, t, p); c.appendChild(b);
            }); 
            refreshShopState();
        }

        window.startNewPlacement = function(id) {
            const item = FURNITURE_DB.find(i => i.id === id);
            if (heartScore < item.price && !activeDecorId[item.decorType]) { alert("ÈáëÈí±‰∏çË∂≥"); return; } 
            if (item.type === 'decor') { handleDecorClick(item); return; }
            deselect(); mode = 'placing_new'; currentItemData = item; currentRotation = 0; createGhost(); updateStatusText("ÊîæÁΩÆ: " + item.name); document.querySelectorAll('.item-btn').forEach(b => b.classList.remove('selected'));
        }

        function handleDecorClick(item) {
            const type = item.decorType;
            if (activeDecorId[type] === item.id) { activeDecorId[type] = null; restoreDecorState(type); updateStatusText("Â∑≤ÊÅ¢Â§çÈªòËÆ§Ê†∑Âºè"); } 
            else { if (heartScore >= item.price) { updateMoney(-item.price); activeDecorId[type] = item.id; applyDecorVisuals(item); updateStatusText("Â∑≤Ë£Ö‰øÆ: " + item.name); } else { alert("ÈáëÈí±‰∏çË∂≥ÔºÅ"); } }
            renderShopItems('decor'); 
        }

        function createGhost() {
            if (ghostMesh) scene.remove(ghostMesh);
            const item = currentItemData; const modelGroup = prepareModel(item);
            if (modelGroup) { ghostMesh = modelGroup; } else { let mat = new THREE.MeshStandardMaterial({ color: item.color, transparent: true, opacity: 0.6 }); let geo = new THREE.BoxGeometry(item.size?.x || 1, item.size?.y || 1, item.size?.z || 1); ghostMesh = new THREE.Mesh(geo, mat); }
            ghostMesh.traverse((c) => { if (c.isMesh) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.5; } });
            ghostMesh.position.set(0, -100, 0); if (item.type !== 'wall') ghostMesh.rotation.y = currentRotation; scene.add(ghostMesh);
        }

        function checkColl(isWall) {
            ghostMesh.updateMatrixWorld();
            const box = new THREE.Box3().setFromObject(ghostMesh);
            if (currentItemData.layer === 0) { 
                 box.min.x += 0.1; box.max.x -= 0.1;
                 box.min.z += 0.1; box.max.z -= 0.1;
            } else {
                 box.expandByScalar(-0.1);
            }

            let col = false;
            // 1. Wall structure collision
            if (!isWall) {
                for (let o of obstacles) {
                    if (box.intersectsBox(new THREE.Box3().setFromObject(o))) { col = true; break; }
                }
            }

            // 2. Furniture collision
            if (!col) {
                for (let f of placedFurniture) {
                    if (mode === 'moving_old' && f === selectedObject) continue;

                    // [‰øÆÂ§ç] Â±ÇÁ∫ßÂà§Êñ≠ÈÄªËæë
                    const myL = currentItemData.layer;
                    const otherL = f.userData.parentClass ? f.userData.parentClass.dbItem.layer : 1;

                    // Layer 0 (Rugs) ignores everything and is ignored by everything
                    if (myL === 0 || otherL === 0) continue;

                    // Layer 2 vs Layer 1 collision rules (simplified: ignore vertical stacking collision for horizontal placement)
                    if ((myL === 2 && otherL === 1) || (myL === 1 && otherL === 2)) continue;

                    // Overlap property
                    if (currentItemData.allowOverlap && f.userData.parentClass && f.userData.parentClass.dbItem.type === 'wall') continue;

                    if (box.intersectsBox(new THREE.Box3().setFromObject(f))) { col = true; break; }
                }
            }
            if (ghostMesh.position.y < 0 && currentItemData.layer !== 0) col = true;
            
            if (col) {
                ghostMesh.traverse(c => { if (c.isMesh) c.material.color.setHex(0xff0000) });
                canPlace = false;
                updateStatusText("‰ΩçÁΩÆÂÜ≤Á™Å", "invalid");
            } else {
                ghostMesh.traverse(c => { if (c.isMesh) c.material.color.setHex(0xffffff) });
                canPlace = true;
                updateStatusText("ÂèØÊîæÁΩÆ", "valid");
            }
        }

        function confirmPlace() {
            if (mode === 'placing_new') { if (heartScore >= currentItemData.price) updateMoney(-currentItemData.price); else { alert("ÈáëÈí±‰∏çË∂≥!"); cancelPlace(); return; } }
            let m = ghostMesh.clone();
            m.traverse(c => { 
                if (c.isMesh) { 
                    c.material.opacity = 1.0; 
                    c.material.transparent = false; 
                    if (!currentItemData.modelFile) c.material.color.setHex(currentItemData.color || 0xffffff); 
                } 
            });
            const newFurniture = new Furniture(m, currentItemData);
            scene.add(m); placedFurniture.push(m);
            if(currentItemData.light) {
                if (currentItemData.lightType === 'point') { 
                    const bulb = new THREE.PointLight(0xffaa00, 0.8, 5); 
                    let lx = 0, ly = 0.3, lz = 0;
                    if (currentItemData.lightOffset) { lx = currentItemData.lightOffset.x || 0; ly = currentItemData.lightOffset.y || 0; lz = currentItemData.lightOffset.z || 0; }
                    bulb.position.set(lx, ly, lz); bulb.castShadow = true; m.add(bulb); 
                } else { 
                    const sl = new THREE.SpotLight(0xfff0dd, 5); sl.position.set(0,0,0); sl.target.position.set(0,0,5); sl.angle = Math.PI / 3; sl.penumbra = 0.5; sl.castShadow = true; m.add(sl); m.add(sl.target); 
                }
            }
            
            if(currentItemData.light && currentItemData.type === 'wall') { 
                 addSkyBacking(m, currentItemData.size); 
            }

            if (mode === 'placing_new' && currentItemData.layer === 1) { const savedItem = currentItemData; setTimeout(() => spawnMysteryBox(savedItem), 1000); }
            if (mode === 'moving_old') { scene.remove(selectedObject); const i = placedFurniture.indexOf(selectedObject); if (i > -1) placedFurniture.splice(i, 1); deselect(); }
            cancelPlace(); playBounce(m);
        }

        function onDown(e) {
            if (e.target !== renderer.domElement) return;
            startPointer.x = e.clientX; startPointer.y = e.clientY;
            if (mode === 'idle' && e.button === 0) {
                raycaster.setFromCamera(pointer, camera);
                for(let cat of cats) { const hits = raycaster.intersectObject(cat.mesh, true); if(hits.length > 0) { cat.pet(); return; } }
                const hits = raycaster.intersectObjects(placedFurniture, true);
                if (hits.length > 0) {
                    let root = hits[0].object; while (root.parent && root.parent !== scene) root = root.parent;
                    
                    if (root.userData.isBox) { 
                        scene.remove(root); 
                        const i = placedFurniture.indexOf(root); 
                        if (i > -1) placedFurniture.splice(i, 1); 
                        updateMoney(10); spawnHeart(root.position); updateStatusText("ÂõûÊî∂Á∫∏ÁÆ±+10"); 
                        return; 
                    }
                    if (root.userData.parentClass) {
                        const didInteract = root.userData.parentClass.interact(); if (didInteract) return;
                        if (root.userData.parentClass.isBox) { scene.remove(root); const i = placedFurniture.indexOf(root); if (i > -1) placedFurniture.splice(i, 1); updateMoney(10); spawnHeart(root.position); updateStatusText("ÂõûÊî∂Á∫∏ÁÆ±+10"); return; }
                    }
                    longPressTimer = setTimeout(() => selectObj(root, e.clientX, e.clientY), 500);
                }
            }
            // [‰øÆÂ§ç] Á°Æ‰øù‰∏≠ÈîÆÊóãËΩ¨ÁîüÊïà
            if (e.button === 1 && ghostMesh && currentItemData.type !== 'wall') { 
                e.preventDefault(); 
                rotateItem(); 
                return; 
            }
            if (e.button === 0 && (mode === 'placing_new' || mode === 'moving_old') && canPlace && ghostMesh) confirmPlace();
        }

        function onUp() { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } }
        function selectObj(m, x, y) { deselect(); selectedObject = m; selectionBox = new THREE.BoxHelper(selectedObject, 0xffffff); scene.add(selectionBox); const menu = document.getElementById('context-menu'); menu.style.display = 'flex'; let px = x + 10, py = y + 10; if (px + 100 > window.innerWidth) px = window.innerWidth - 110; if (py + 100 > window.innerHeight) py = window.innerHeight - 110; menu.style.left = px + 'px'; menu.style.top = py + 'px'; updateStatusText("ÈÄâ‰∏≠: ÂÆ∂ÂÖ∑"); }
        function deselect() { selectedObject = null; if (selectionBox) { scene.remove(selectionBox); selectionBox = null; } document.getElementById('context-menu').style.display = 'none'; document.getElementById('cat-panel').classList.add('hidden'); }
        function cancelPlace() { if (ghostMesh) scene.remove(ghostMesh); mode = 'idle'; ghostMesh = null; currentItemData = null; updateStatusText("ÊµèËßà‰∏≠"); }
        function cancelMove() { if(mode==='moving_old'){if(ghostMesh)scene.remove(ghostMesh);if(selectedObject){selectedObject.position.copy(editingObjectOriginalPos);selectedObject.quaternion.copy(editingObjectOriginalQuat);selectedObject.visible=true;}} deselect(); mode='idle'; ghostMesh=null; }
        function showMenu(x,y) { const m=document.getElementById('context-menu'); m.style.display='flex'; let px=x+10, py=y+10; if(px+100>window.innerWidth)px=window.innerWidth-110; if(py+100>window.innerHeight)py=window.innerHeight-110; m.style.left=px+'px'; m.style.top=py+'px'; }
        function hideContextMenu() { document.getElementById('context-menu').style.display='none'; }
         
        
        
        function startMovingOld(m) { mode = 'moving_old'; m.visible = false; editingObjectOriginalPos = m.position.clone(); editingObjectOriginalQuat = m.quaternion.clone(); currentItemData = m.userData.parentClass ? m.userData.parentClass.dbItem : FURNITURE_DB[0]; currentRotation = m.rotation.y; createGhost(); updateStatusText("Ê≠£Âú®ÁßªÂä®..."); }
        function deleteSelected() { if (!selectedObject) return; scene.remove(selectedObject); const i = placedFurniture.indexOf(selectedObject); if (i > -1) placedFurniture.splice(i, 1); deselect(); }
        function onMove(e) {
            if (longPressTimer) { if (Math.hypot(e.clientX - startPointer.x, e.clientY - startPointer.y) > 5) { clearTimeout(longPressTimer); longPressTimer = null; } }
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1; pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            if ((mode === 'placing_new' || mode === 'moving_old') && ghostMesh) {
                raycaster.setFromCamera(pointer, camera); 
                if (currentItemData.type === 'wall') {
                    const hits = raycaster.intersectObjects(obstacles);
                    if (hits.length > 0) {
                        const h = hits[0]; const n = h.face.normal;
                        if (Math.abs(n.y) > 0.5) return; 
                        const offset = currentItemData.size.z / 2 + 0.01;
                        const pos = h.point.clone().add(n.clone().multiplyScalar(offset));
                        if (Math.abs(n.x) > 0.5) { pos.y = Math.round(pos.y / 0.5) * 0.5; pos.z = Math.round(pos.z / 0.5) * 0.5; } 
                        else { pos.x = Math.round(pos.x / 0.5) * 0.5; pos.y = Math.round(pos.y / 0.5) * 0.5; }
                        const hh = currentItemData.size.y / 2; if (pos.y < hh) pos.y = hh; if (pos.y + hh > 3) pos.y = 3 - hh;
                        ghostMesh.position.copy(pos); ghostMesh.lookAt(pos.clone().add(n)); checkColl(true);
                    }
                    return;
                }
                
                let onTable = false;
                if (currentItemData.layer === 2) {
                    const surfaceMeshes = placedFurniture.filter(f => f.userData.parentClass && f.userData.parentClass.dbItem && f.userData.parentClass.dbItem.isSurface);
                    const hits = raycaster.intersectObjects(surfaceMeshes, true);
                    if (hits.length > 0) {
                        const hit = hits[0]; let targetY = hit.point.y;
                        if (hit.object.parent && hit.object.parent.userData.parentClass && hit.object.parent.userData.parentClass.dbItem.surfaceHeight) {
                            targetY = hit.object.parent.position.y + hit.object.parent.userData.parentClass.dbItem.surfaceHeight;
                        }
                        if (currentItemData.yFix) targetY += currentItemData.yFix;
                        ghostMesh.position.set(hit.point.x, targetY, hit.point.z); ghostMesh.rotation.set(0, currentRotation, 0); checkColl(false); onTable = true;
                    }
                }
                if (!onTable) {
                    const hits = raycaster.intersectObject(floorPlane);
                    if (hits.length > 0) {
                        const p = hits[0].point; let targetY = 0; if (currentItemData.id.includes('rug')) targetY = 0.01;
                        ghostMesh.position.set(Math.round(p.x / 0.5) * 0.5, targetY, Math.round(p.z / 0.5) * 0.5);
                        ghostMesh.rotation.set(0, currentRotation, 0); checkColl(false);
                    }
                }
            }
        }
        function rotateItem() { currentRotation += Math.PI / 2; if (ghostMesh) { ghostMesh.rotation.y = currentRotation; checkColl(false); } }
        function playBounce(m) { let f=0; const baseScale = m.userData.parentClass.dbItem.modelScale || 1; function a(){ if(f<20){const k=f/20; const s=0.1+(0.9)*(Math.sin(k*Math.PI*1.5)*0.2+k); m.scale.set(baseScale*s, baseScale*s, baseScale*s); f++; requestAnimationFrame(a); }else m.scale.set(baseScale, baseScale, baseScale); } a(); }
        function onWindowResize() { const aspect = window.innerWidth / window.innerHeight; const d = 12; camera.left = -d * aspect; camera.right = d * aspect; camera.top = d; camera.bottom = -d; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function updateCameraMovement(dt) {
            if (!(moveKeys.w || moveKeys.a || moveKeys.s || moveKeys.d)) return;
            const moveSpeed = 10.0 * dt;
            const displacement = new THREE.Vector3();
            const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
            const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize();
            if (moveKeys.w) displacement.add(forward.multiplyScalar(moveSpeed));
            if (moveKeys.s) displacement.sub(forward.multiplyScalar(moveSpeed));
            if (moveKeys.d) displacement.add(right.multiplyScalar(moveSpeed));
            if (moveKeys.a) displacement.sub(right.multiplyScalar(moveSpeed));
            camera.position.add(displacement); controls.target.add(displacement);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = gameClock.getDelta(); 
            updateCameraMovement(dt);
            controls.update();
            updateEnvironment(dt);
            cats.forEach(c => c.update(dt)); 
            if(selectionBox) selectionBox.update();
            renderer.render(scene, camera);
        }

        function startGame() {
            try {
                logToScreen("Initializing Renderer & Scene...");
                setDomText('heart-count', heartScore);
                window.switchCategory('floor'); 
                
                renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.outputColorSpace = THREE.SRGBColorSpace; document.body.appendChild(renderer.domElement);
                scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0f7fa);
                const aspect=window.innerWidth/window.innerHeight; const d=12; camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000); camera.position.set(20, 20, 20); camera.lookAt(0,0,0);
                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2.1;

                window.addEventListener('keydown', (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    const key = e.key.toLowerCase();
                    if (key === 'r' && ghostMesh && currentItemData.type !== 'wall') { rotateItem(); }
                    switch (key) { case 'w': moveKeys.w = true; break; case 'a': moveKeys.a = true; break; case 's': moveKeys.s = true; break; case 'd': moveKeys.d = true; break; }
                });
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    switch (key) { case 'w': moveKeys.w = false; break; case 'a': moveKeys.a = false; break; case 's': moveKeys.s = false; break; case 'd': moveKeys.d = false; break; }
                });
                
                hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.2); scene.add(hemiLight);
                const al = new THREE.AmbientLight(0xffffff, 0.9); scene.add(al);
                sunLight = new THREE.DirectionalLight(0xffdfba, 1.2); sunLight.position.set(15,25,10); sunLight.castShadow=true; sunLight.shadow.mapSize.width=2048; sunLight.shadow.mapSize.height=2048; sunLight.shadow.camera.left=-20; sunLight.shadow.camera.right=20; sunLight.shadow.camera.top=20; sunLight.shadow.camera.bottom=-20; scene.add(sunLight);
                
                celestialGroup = new THREE.Group(); scene.add(celestialGroup);
                sunMesh = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color:0xffff00})); celestialGroup.add(sunMesh);
                moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,16,16), new THREE.MeshStandardMaterial({color:0xffffff,emissive:0x222222})); celestialGroup.add(moonMesh);
                sunMesh.visible = false; moonMesh.visible = false;
                
                raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();
                const fg=new THREE.PlaneGeometry(12,12); const fm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.floor.color}); floorPlane=new THREE.Mesh(fg, fm); floorPlane.rotation.x=-Math.PI/2; floorPlane.receiveShadow=true; scene.add(floorPlane);
                const gh=new THREE.GridHelper(12,24,0xffffff,0xffffff); gh.position.y=0.01; gh.material.opacity=0.2; gh.material.transparent=true; scene.add(gh);
                const wm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.wall.color});
                const w1=new THREE.Mesh(new THREE.BoxGeometry(10,3,0.5), wm); w1.position.set(0,1.5,-5.25); w1.receiveShadow=true; w1.castShadow=true; scene.add(w1); obstacles.push(w1);
                const w2=new THREE.Mesh(new THREE.BoxGeometry(0.5,3,10), wm); w2.position.set(-5.25,1.5,0); w2.receiveShadow=true; w2.castShadow=true; scene.add(w2); obstacles.push(w2);
                wallGroup = [w1, w2];
                
                logToScreen("Spawning Cat...");
                cats.push(new Cat(scene, 0xffa502));

                window.addEventListener('resize', onWindowResize); window.addEventListener('pointermove', onMove); window.addEventListener('pointerdown', onDown); window.addEventListener('pointerup', onUp);
                window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode==='placing_new') cancelPlace(); else if(mode==='moving_old') cancelMove(); else deselect(); });
                
                document.getElementById('btn-move').onclick=()=>{if(selectedObject)startMovingOld(selectedObject);hideContextMenu();}
                document.getElementById('btn-delete').onclick=()=>{if(selectedObject)deleteSelected();hideContextMenu();}
                document.getElementById('btn-cancel').onclick=()=>{deselect();hideContextMenu();}

                logToScreen("Game Loop Starting...");
                animate();
            } catch(e) {
                console.error(e);
                logToScreen("STARTGAME CRASH: " + e.message, 'error');
            }
        }

        function init() { try { loadAssets(() => { updateStatusText("ËµÑÊ∫êÂä†ËΩΩÂÆåÊØï"); const ls = document.getElementById('loading-screen'); if(ls) ls.style.display = 'none'; if(!scene) startGame(); }); } catch(e) { console.error(e); alert("Init Error: " + e.message); } }
        
        init();
    </script>
</body>
</html>
