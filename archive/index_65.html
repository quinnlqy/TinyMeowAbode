<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŒ«å’ªçš„å®¶ - é˜¶æ®µ63: çª—æˆ·ä¸æ¨¡å‹ä¿®å¤ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f7fa; font-family: 'Microsoft YaHei', sans-serif; transition: background-color 1s; }
        canvas { display: block; outline: none; }
        
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s;}
        #loading-text { font-size: 20px; color: #555; margin-bottom: 10px; }
        #progress-bar { width: 200px; height: 5px; background: #ddd; margin-bottom: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #ffaa00; transition: width 0.2s; }
        #force-start-btn { display: none; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-top: 10px;}
        #error-log { color: red; margin-top: 10px; font-size: 12px; max-width: 80%; text-align: center; background: #eee; padding: 5px; }

        #top-ui { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 20; }
        #clock-wrapper {
            background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 16px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); pointer-events: auto;
            display: flex; flex-direction: column; gap: 5px; align-items: center; min-width: 140px;
        }
        #clock-display { font-size: 24px; font-weight: bold; color: #333; display: flex; align-items: center; gap: 8px; }
        #day-icon { font-size: 24px; }
        #time-control { display: flex; align-items: center; gap: 5px; font-size: 10px; color: #666; width: 100%; }
        input[type=range] { flex: 1; cursor: pointer; height: 4px; accent-color: #ffaa00; }

        #heart-panel { background: rgba(255,255,255,0.95); padding: 8px 15px; border-radius: 20px; font-size: 18px; color: #e74c3c; font-weight: bold; display: flex; gap: 10px; align-items: center; pointer-events: auto; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        
        .debug-btn { background: #555; color: white; border: none; padding: 4px 8px; border-radius: 6px; font-size: 12px; cursor: pointer; }
        .debug-btn:hover { background: #333; }

        #tutorial { position: absolute; top: 100px; left: 20px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; pointer-events: none; z-index: 5; }
        #context-menu { position: absolute; display: none; background: white; padding: 8px; border-radius: 8px; z-index: 100; flex-direction: column; gap: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); pointer-events: auto; }
        .context-btn { padding: 8px 16px; border: 1px solid #eee; background: #f9f9f9; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn-delete { color: red; background: #fff0f0; }
        
        .status-valid { color: green; font-weight: bold; }
        .status-invalid { color: red; font-weight: bold; }
        .heart-float { position: absolute; color: #e74c3c; font-weight: bold; font-size: 20px; pointer-events: none; animation: floatUp 1.5s ease-out forwards; z-index: 30; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
        .emote-bubble { position: absolute; font-size: 24px; pointer-events: none; animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25; }
        @keyframes popUp { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        #shop-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; background: rgba(255, 255, 255, 0.98); border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; user-select: none; z-index: 10; }
        #tabs { display: flex; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tab { flex: 1; text-align: center; padding: 10px 0; cursor: pointer; font-size: 14px; color: #666; }
        .tab.active { background: #fff; color: #333; font-weight: bold; border-bottom: 3px solid #ffaa00; }
        #items-scroll { display: flex; gap: 12px; padding: 15px; overflow-x: auto; white-space: nowrap; scrollbar-width: thin; }
        .item-btn { flex: 0 0 auto; width: 80px; height: 85px; border: 2px solid #eee; border-radius: 12px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; background: #fff; color: #333; position: relative; transition: all 0.2s; }
        .item-btn.selected { border: 3px solid #ffaa00; background: #fff8e1; transform: translateY(-3px); }
        .item-btn.disabled { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; }
        .color-preview { width: 24px; height: 24px; border-radius: 50%; margin-bottom: 5px; border: 1px solid rgba(0,0,0,0.1); background-size: cover; }
        .price-tag { margin-top: 4px; font-size: 11px; color: #e74c3c; font-weight: bold; background: #fff0f0; padding: 2px 6px; border-radius: 8px; }
    </style>
    <!-- å…¨å±€é”™è¯¯æ•è· -->
    <script>
        window.onerror = function(msg, url, line) {
            const div = document.getElementById('error-log'); 
            if(div) div.innerText = `Error: ${msg}\nLine: ${line}`;
            const btn = document.getElementById('force-start-btn');
            if(btn) btn.style.display = 'block';
            return false;
        };
    </script>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-text">èµ„æºåŠ è½½ä¸­...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <div id="error-log"></div>
        <button id="force-start-btn" onclick="window.forceStart()">âš ï¸ å¼ºåˆ¶è¿›å…¥æ¸¸æˆ</button>
    </div>

    <div id="top-ui">
        <div id="clock-wrapper">
            <div id="clock-display">
                <span id="day-icon">â˜€ï¸</span>
                <span id="game-time">08:00</span>
            </div>
            <div id="time-control">
                <span>æ…¢</span>
                <input type="range" id="time-slider" min="0" max="10" value="2">
                <span>å¿«</span>
            </div>
        </div>

        <div id="heart-panel">
            â¤ï¸ <span id="heart-count">500</span>
            <div>
                <button class="debug-btn" onclick="debugAddMoney()">+$$</button>
                <button class="debug-btn" onclick="debugResetCat()">é‡ç½®çŒ«</button>
            </div>
        </div>
    </div>

    <div id="tutorial">
        <strong>V63 çª—æˆ·ä¸æ¨¡å‹ä¿®å¤ç‰ˆ</strong><br>
        1. ä¿®å¤çª—æˆ·æ¨¡å‹ä¸èƒŒæ™¯ä¸å¯¹é½<br>
        2. WASD ç§»åŠ¨æ‘„åƒå¤´<br>
        <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;">
            <span id="status-text">åˆå§‹åŒ–...</span>
        </div>
    </div>

    <div id="context-menu">
        <div class="context-btn" id="btn-move">ç§»åŠ¨ä½ç½®</div>
        <div class="context-btn btn-delete" id="btn-delete">åˆ é™¤å®¶å…·</div>
        <div class="context-btn" id="btn-cancel">å–æ¶ˆé€‰ä¸­</div>
    </div>

    <div id="shop-panel">
        <div id="tabs">
            <div class="tab active" onclick="switchCategory('floor')">å®¶å…·</div>
            <div class="tab" onclick="switchCategory('small')">å°ç‰©</div>
            <div class="tab" onclick="switchCategory('wall')">å¢™å£</div>
            <div class="tab" onclick="switchCategory('decor')">è£…ä¿®</div>
        </div>
        <div id="items-scroll"></div>
    </div>

    <!-- CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // 5ç§’åæ˜¾ç¤ºè·³è¿‡æŒ‰é’®
        setTimeout(() => { 
            const ls = document.getElementById('loading-screen');
            if(ls && ls.style.display !== 'none') {
                document.getElementById('force-start-btn').style.display='block';
            }
        }, 5000);

        const CAT_CONFIG = { scale: 0.35, rotateX: 0, rotateY: 0, yOffset: 0, idleIndex: 2, walkIndex: 7, sleepIndex: 1, petIndex: 1 };
        const SKY_COLORS = { night: new THREE.Color(0x1a1a2e), dawn: new THREE.Color(0xffaa99), day: new THREE.Color(0xe0f7fa), dusk: new THREE.Color(0x6a5acd) };
        const DEFAULT_DECOR = { floor: { color: 0xF5F5DC, texture: null }, wall:  { color: 0xEBE5D1, texture: null } };
        
        let scene, camera, renderer, controls;
        let raycaster, pointer, floorPlane, wallGroup;
        let sunLight, hemiLight;
        let sunMesh, moonMesh, celestialGroup;
        const gameClock = new THREE.Clock(); 
        
        let gameTime = 8.0; 
        let timeSpeed = 0.2; 

        // å­˜å‚¨ç§»åŠ¨æŒ‰é”®çŠ¶æ€
        const moveKeys = { w: false, a: false, s: false, d: false };

        const loadedModels = {}; 
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        
        let mode = 'idle', ghostMesh = null, currentItemData = null, currentRotation = 0, canPlace = false;
        let selectedObject = null, selectionBox = null, editingObjectOriginalPos = null, editingObjectOriginalQuat = null;
        let longPressTimer = null, startPointer = new THREE.Vector2();
        
        const obstacles = []; 
        const placedFurniture = []; 
        const cats = []; 
        let heartScore = 500; 
        let currentCategory = 'floor'; 
        let activeDecorId = { floor: null, wall: null };
        let skyPanels = []; 

        const FURNITURE_DB = [
            { id: 'rug',      type: 'floor', layer: 0, name: 'åœ†åœ°æ¯¯', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'RoundRug.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'rug_squre',type: 'floor', layer: 0, name: 'æ–¹åœ°æ¯¯', price: 20,  color: 0x3498db, size: {x:2, y:0.02, z:2}, modelFile: 'rug_squre.glb', modelScale: 1.5, yFix: 0.02, autoCenter: true },
            { id: 'bed',      type: 'floor', layer: 1, name: 'çŒ«çª',   price: 40,  color: 0xe67e22, size: {x:1, y:0.5, z:1}, modelFile: 'bed.glb', modelScale: 0.8, canSleep: true, fixBottom: true },
            { id: 'sofa',     type: 'floor', layer: 1, name: 'å¤§æ²™å‘', price: 150, color: 0xe74c3c, size: {x:3, y:1, z:1},   modelFile: 'sofa.glb', modelScale: 2.0, canSleep: true, fixBottom: true },
            { id: 'cat_tree', type: 'floor', layer: 1, name: 'çŒ«çˆ¬æ¶', price: 100, color: 0x8e44ad, size: {x:1, y:2, z:1},   modelFile: 'cat_tree.glb', modelScale: 1.0 , fixBottom: true},
            { id: 'book_shelf', type: 'floor', layer: 1, name: 'ä¹¦æ¶', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'book_shelf.glb', modelScale: 1.0, fixBottom: true },
            { id: 'Television', type: 'floor', layer: 1, name: 'ç”µè§†', price: 100, color: 0x8e44ad, size: {x:2, y:2, z:1},   modelFile: 'Television.glb', modelScale: 1.0, fixBottom: true },
            { id: 'table',    type: 'floor', layer: 1, isSurface: true, surfaceHeight: 0.8, name: 'æœ¨æ¡Œ', price: 60,  color: 0x8d6e63, size: {x:1.5, y:0.8, z:1.5}, modelFile: 'table.glb', modelScale: 1.0, fixBottom: true },
            { id: 'ChrismasTree',    type: 'floor', layer: 1, name: 'åœ£è¯æ ‘', price: 100,  color: 0x8d6e63, size: {x:1.5, y:2, z:1.5}, modelFile: 'ChrismasTree.glb', modelScale: 1.8, fixBottom: true },
            { id: 'fireplace',    type: 'floor', layer: 1, name: 'å£ç‚‰', price: 100,  color: 0x8d6e63, size: {x:1.5, y:2, z:1.5}, modelFile: 'fireplace.glb', modelScale: 1.8, fixBottom: true },
            { id: 'mug',      type: 'small', layer: 2, name: 'é©¬å…‹æ¯', price: 5,   color: 0xffffff, size: {x:0.3, y:0.3, z:0.3}, modelFile: 'mug.glb', modelScale: 0.2, fixBottom: true },
            { id: 'lamp',     type: 'small', layer: 2, name: 'å°ç¯',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'lamp.glb', modelScale: 1.0, fixBottom: true },
            { id: 'floor_lamp',     type: 'small', layer: 2, name: 'è½åœ°ç¯',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4}, light: true, lightType: 'point', modelFile: 'floor_lamp.glb', modelScale: 1.0, fixBottom: true, lightOffset: { x: 0, y: 1.8, z: 0 }  },
            { id: 'books',     type: 'small', layer: 2, name: 'ä¹¦',   price: 25,  color: 0xf1c40f, size: {x:0.4, y:0.6, z:0.4},  modelFile: 'books.glb', modelScale: 5.0, fixBottom: true },
            { id: 'wall_plant',    type: 'wall',  layer: 1, name: 'å£æŒ‚è—¤', price: 20,  color: 0x2ecc71, size: {x:2, y:0.5, z:0.5}, modelFile: 'wall_plant.glb', modelScale: 0.8 },
            { id: 'painting', type: 'wall',  layer: 1, name: 'é£æ™¯ç”»', price: 50,  color: 0xFFD700, size: {x:1, y:1, z:0.1}, modelFile: 'painting.glb', modelScale: 1.0 },
            // [æ–°å¢] çª—å¸˜ï¼šå…è®¸é‡å ï¼Œä¸”è®¾ç½® size.z ä¸º 0.3 (æ¯”çª—æˆ·çš„ 0.2 åš)ï¼Œè¿™æ ·å®ƒä¼šè‡ªåŠ¨æ’åœ¨çª—æˆ·å‰é¢
            { 
                id: 'curtain', 
                type: 'wall', 
                layer: 1, 
                name: 'çª—å¸˜', 
                price: 80, 
                color: 0xFFFFFF, 
                size: {x:2.0, y:2.0, z:0.5}, // z æ”¹å¤§ä¸€ç‚¹ï¼Œè®©å®ƒç¦»å¢™è¿œä¸€ç‚¹
                modelFile: 'curtain.glb', 
                modelScale: 1.5, 
                autoCenter: true,
                allowOverlap: true // [æ ¸å¿ƒæ ‡è®°] å…è®¸é‡å 
            },

            // [æ–°å¢] æ˜Ÿæ˜ŸæŒ‚é¥°ï¼šå…è®¸é‡å 
            { 
                id: 'wall_star', 
                type: 'wall', 
                layer: 1, 
                name: 'æ˜Ÿæ˜ŸæŒ‚é¥°', 
                price: 30, 
                color: 0xFFFF00, 
                size: {x:0.5, y:0.5, z:0.5}, // z æ”¹å¤§ä¸€ç‚¹ï¼Œæµ®åœ¨ç”»æ¡†è¡¨é¢
                modelFile: 'WallDecorate_Star.glb', 
                modelScale: 1.0, 
                autoCenter: true,
                allowOverlap: true // [æ ¸å¿ƒæ ‡è®°] å…è®¸é‡å 
            },
            // --- çª—æˆ·é…ç½®ä¿®æ­£ ---
            // æ³¨æ„ï¼šå¦‚æœä½ è§‰å¾—çª—æˆ·è¿˜æ˜¯å¤ªå¤§ï¼Œå‡å° modelScale
            // æ³¨æ„ï¼šå¦‚æœä½ è§‰å¾—ä½ç½®è¿˜æ˜¯ä¸å¯¹ï¼Œä¿®æ”¹ manualOffset (x,y,z)
            { 
                id: 'window',   
                type: 'wall',  
                layer: 1, 
                name: 'å¤§çª—', 
                price: 120, 
                color: 0x87CEEB, 
                size: {x:1.8, y:1.8, z:0.2}, // è¿™ä¸ªå°ºå¯¸å†³å®šäº†â€œå‡æ´â€çš„å¤§å°
                light: true, 
                lightType: 'spot', 
                modelFile: 'window_large.glb', 
                
                // [å…³é”®] å¼ºåˆ¶è‡ªåŠ¨å±…ä¸­ï¼Œè¿™ä¼šæŠŠæ¨¡å‹å‡ ä½•ä¸­å¿ƒç§»åˆ° (0,0,0)ï¼Œä»è€Œä¸å¤©ç©ºæ¿å¯¹é½
                autoCenter: true,
                
                // å¦‚æœæ¨¡å‹å¤ªå¤§ï¼Œæ”¹å°è¿™é‡Œ (ä¾‹å¦‚ 0.5)
                modelScale: 1, 
                
                // å¦‚æœè¿˜æ˜¯å¯¹ä¸é½ï¼Œç”¨è¿™é‡Œå¾®è°ƒ {x: 0, y: -0.2, z: 0}
                manualOffset: { x: 0, y: 0, z: 0 } 
            },
            
            { id: 'window2', type: 'wall',  layer: 1, name: 'å°çª—', price: 120, color: 0x87CEEB, size: {x:1.8, y:2, z:0.2}, light: true, lightType: 'spot', modelFile: 'window_large.glb', modelScale: 0.5, autoCenter: true },
            
            { id: 'floor_wood', type: 'decor', name: 'æœ¨çº¹åœ°æ¿', price: 50, color: 0x8d6e63, decorType: 'floor', textureFile: 'wood.jpg' }, 
            { id: 'floor_tile', type: 'decor', name: 'ç™½ç“·ç –',   price: 50, color: 0xdbc2a3, decorType: 'floor', textureFile: 'tile.jpg' },
            { id: 'wall_pink',  type: 'decor', name: 'æ¸©é¦¨ç²‰å¢™', price: 50, color: 0xffcdd2, decorType: 'wall',  textureFile: 'wallpaper.jpg' },
            { id: 'wall_blue',  type: 'decor', name: 'æ¸…çˆ½è“å¢™', price: 50, color: 0xb3e5fc, decorType: 'wall' }
        ];

        // æ»‘å—æ§åˆ¶é€»è¾‘
        const slider = document.getElementById('time-slider');
        if(slider) {
            slider.addEventListener('input', (e) => {
                timeSpeed = parseFloat(e.target.value) * 0.1; 
            });
        }

        // --- å…¨å±€å‡½æ•°æš´éœ² ---
        window.switchCategory = function(cat) {
            currentCategory = cat;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const tabs = document.querySelectorAll('.tab');
            if(cat==='floor') tabs[0].classList.add('active'); 
            else if(cat==='small') tabs[1].classList.add('active'); 
            else if(cat==='wall') tabs[2].classList.add('active');
            else tabs[3].classList.add('active'); 
            renderShopItems(cat);
        };
        window.forceStart = function() { 
            const ls = document.getElementById('loading-screen');
            if(ls) ls.style.display = 'none';
            if(!scene) startGame();
        }
        window.debugAddMoney = function() { updateMoney(100); };
        window.debugResetCat = function() { cats.forEach(c => c.resetCooldown()); updateStatusText("çŒ«å’ªä¸å†ç”Ÿæ°”äº†"); };

        function sanitizeMaterial(child) {
            if (child.isMesh) {
                child.castShadow = true; child.receiveShadow = true;
                if (child.material.map) child.material.map.colorSpace = THREE.SRGBColorSpace;
                
                const isGlass = child.name.toLowerCase().includes('glass') || 
                                child.name.toLowerCase().includes('window') ||
                                (child.material.name && child.material.name.toLowerCase().includes('glass'));

                child.material.metalness = 0.0; 
                child.material.roughness = 0.8; 

                if (isGlass) {
                    child.material.transparent = true;
                    child.material.opacity = 0.3; // ç»ç’ƒé€æ˜åº¦
                    child.material.color.setHex(0x88ccff);
                } else {
                    child.material.transparent = false;
                    child.material.opacity = 1.0;
                }
                
                child.material.needsUpdate = true;
            }
        }

        function loadAssets(callback) {
            const loadingScreen = document.getElementById('loading-screen');
            const progressFill = document.getElementById('progress-fill');
            const files = [];
            files.push({ key: 'cat', path: './assets/models/cat.glb' });
            // [æ–°å¢] æ·»åŠ ç®±å­æ¨¡å‹ (æ³¨æ„è·¯å¾„åˆ†éš”ç¬¦æ”¹ä¸ºæ–œæ  / ä»¥å…¼å®¹ç½‘é¡µ)
            files.push({ key: 'box', path: './assets/models/cardboardBoxOpen.glb' });

            FURNITURE_DB.forEach(i => { if(i.modelFile) files.push({ key: i.id, path: './assets/models/'+i.modelFile }); });

            if(files.length===0) { callback(); return; }
            let count = 0;
            files.forEach(f => {
                const isObj = f.path.toLowerCase().endsWith('.obj');
                const l = isObj ? objLoader : gltfLoader;
                l.load(f.path, (data) => {
                    const sceneData = isObj ? data : data.scene;
                    const anims = isObj ? [] : data.animations;
                    sceneData.traverse(sanitizeMaterial);
                    loadedModels[f.key] = { scene: sceneData, animations: anims };
                    count++; check();
                }, undefined, (err)=>{ console.warn("Missing: "+f.path); count++; check(); });
            });
            function check() {
                progressFill.style.width = Math.floor((count/files.length)*100)+'%';
                if(count===files.length) { setTimeout(()=>{ if(loadingScreen) loadingScreen.remove(); callback(); }, 500); }
            }
        }

        function applyDecorVisuals(item) {
            const setMaterial = (mesh, config) => {
                if (config.textureFile) {
                    textureLoader.load('./assets/textures/' + config.textureFile, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                        if (config.decorType === 'floor') tex.repeat.set(4, 4); else tex.repeat.set(2, 1);
                        mesh.material.map = tex; mesh.material.color.setHex(0xffffff); mesh.material.needsUpdate = true;
                    });
                } else {
                    mesh.material.map = null; mesh.material.color.setHex(config.color); mesh.material.needsUpdate = true;
                }
            };
            if (item.decorType === 'floor') setMaterial(floorPlane, item);
            else if (item.decorType === 'wall') wallGroup.forEach(wall => setMaterial(wall, item));
        }

        function restoreDecorState(type) {
            const currentId = activeDecorId[type];
            if (currentId) { const item = FURNITURE_DB.find(i => i.id === currentId); if (item) applyDecorVisuals(item); } 
            else { const def = DEFAULT_DECOR[type]; applyDecorVisuals({ decorType: type, color: def.color, textureFile: def.texture }); }
        }

        function handleDecorClick(item) {
            const type = item.decorType;
            if (activeDecorId[type] === item.id) { activeDecorId[type] = null; restoreDecorState(type); updateStatusText("å·²æ¢å¤é»˜è®¤æ ·å¼"); } 
            else { if (heartScore >= item.price) { updateMoney(-item.price); activeDecorId[type] = item.id; applyDecorVisuals(item); updateStatusText("å·²è£…ä¿®: " + item.name); } else { alert("é‡‘é’±ä¸è¶³ï¼"); } }
            renderShopItems('decor'); 
        }


        function spawnMysteryBox(sourceItem) {
            let x, z;
            let attempts = 0;
            
            // 1. å¯»æ‰¾ç©ºä½ (é€»è¾‘ä¿æŒä¸å˜)
            do {
                x = (Math.random() - 0.5) * 7; 
                z = (Math.random() - 0.5) * 7;
                attempts++;
                var tooClose = placedFurniture.some(f => {
                    const dist = Math.hypot(f.position.x - x, f.position.z - z);
                    let otherRadius = 0.5;
                    if (f.userData.dbItem && f.userData.dbItem.size) {
                        otherRadius = Math.max(f.userData.dbItem.size.x, f.userData.dbItem.size.z) / 2;
                    }
                    return dist < (otherRadius + 0.7);
                });
            } while (tooClose && attempts < 20);

            let box;

            if (loadedModels['box']) {
                const raw = loadedModels['box'].scene.clone();
                raw.traverse(sanitizeMaterial);
                
                // --- æ­¥éª¤ A: å‡ ä½•ä½“å½’å¿ƒ ---
                // å…ˆæŠŠå‡ ä½•ä½“å±…ä¸­ï¼Œæ–¹ä¾¿åç»­æ—‹è½¬
                const box3_raw = new THREE.Box3().setFromObject(raw);
                const center = new THREE.Vector3();
                box3_raw.getCenter(center);
                raw.position.sub(center); 
                
                // åˆ›å»ºå¤–å±‚å®¹å™¨
                box = new THREE.Group();
                box.add(raw);
                
                // --- æ­¥éª¤ B: ç¼©æ”¾ (åº”ç”¨åœ¨å†…å±‚ Mesh ä¸Š) ---
                let sx = 0.5, sy = 0.5, sz = 0.5;
                if (sourceItem && sourceItem.size) {
                    // ä¿æŒä¹‹å‰çš„æœ€å°å°ºå¯¸é€»è¾‘ï¼Œé˜²æ­¢çŒ«ä¸è¿›å»
                    let tx = Math.max(0.6, sourceItem.size.x * 1.2);
                    let ty = Math.max(0.2, sourceItem.size.y * 1.2); 
                    let tz = Math.max(0.6, sourceItem.size.z * 1.2);

                    if (sourceItem.id.includes('rug')) ty = 0.2;

                    const box3 = new THREE.Box3().setFromObject(raw);
                    const baseSize = new THREE.Vector3();
                    box3.getSize(baseSize);

                    sx = baseSize.x > 0.01 ? tx / baseSize.x : 1;
                    sy = baseSize.y > 0.01 ? ty / baseSize.y : 1;
                    sz = baseSize.z > 0.01 ? tz / baseSize.z : 1;
                }
                // æ³¨æ„ï¼šæŠŠç¼©æ”¾ç»™ rawï¼Œè€Œä¸æ˜¯ box
                raw.scale.set(sx, sy, sz);

                // --- æ­¥éª¤ C: å€’ä¼åˆ¤æ–­ä¸å§¿æ€è°ƒæ•´ (åº”ç”¨åœ¨å†…å±‚ Mesh ä¸Š) ---
                const isTall = sy > sx * 1.5 || sy > sz * 1.5;
                
                if (isTall) {
                    // [å…³é”®ä¿®æ”¹] åªç»• X è½´è½¬ 90 åº¦ï¼Œè®©å®ƒä»â€œç«™ç€â€å˜æˆâ€œèººç€â€
                    // å¼€å£åŸæœ¬æœä¸Š(+Y)ï¼Œç°åœ¨æœä¾§é¢
                    raw.rotation.x = Math.PI / 2; 
                } 

                // --- æ­¥éª¤ D: ä¸‡èƒ½è´´åœ°é€»è¾‘ ---
                // å¼ºåˆ¶æ›´æ–°å†…å±‚çŸ©é˜µï¼Œä»¥ä¾¿è®¡ç®—å‡†ç¡®çš„åŒ…å›´ç›’
                raw.updateMatrix(); 
                const finalBox = new THREE.Box3().setFromObject(raw);
                
                // è®¡ç®—æœ€ä½ç‚¹ (min.y)ï¼ŒæŠŠ raw å¾€ä¸Šæï¼ŒæŠµæ¶ˆè¿™ä¸ªè´Ÿå€¼
                // è¿™æ · raw çš„åº•éƒ¨å°±åˆšå¥½è´´åˆ box çš„åŸç‚¹ (y=0)
                raw.position.y -= finalBox.min.y;

                // è®¡ç®—çœŸå®é«˜åº¦ (ç»™çŒ«å’ªè·³è·ƒé€»è¾‘ç”¨)
                const realHeight = finalBox.max.y - finalBox.min.y;

                box.userData = { 
                    isBox: true, 
                    isTipped: isTall, 
                    boxHeight: realHeight, 
                    dbItem: { layer: 1, name: "å¿«é€’ç®±", type: 'floor' } 
                };

            } else {
                // åå¤‡æ–¹å—é€»è¾‘ (ä¿æŒä¸å˜)
                let size = { x: 0.6, y: 0.5, z: 0.6 };
                if (sourceItem && sourceItem.size) {
                    size.x = Math.max(0.6, sourceItem.size.x * 1.2);
                    size.y = Math.max(0.2, sourceItem.size.y * 1.2);
                    size.z = Math.max(0.6, sourceItem.size.z * 1.2);
                }
                const boxGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
                const boxMat = new THREE.MeshStandardMaterial({ color: 0xcd853f });
                box = new THREE.Mesh(boxGeo, boxMat);
                box.position.y = size.y / 2; 
                box.userData = { isBox: true, isTipped: false, boxHeight: size.y, dbItem: { layer: 1, name: "å¿«é€’ç®±", type: 'floor' } };
            }

            // --- æ­¥éª¤ E: æœ€ç»ˆæ”¾ç½® (åº”ç”¨åœ¨å¤–å±‚ Group ä¸Š) ---
            // Y å§‹ç»ˆä¸º 0ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨æ­¥éª¤ D å·²ç»æŠŠå†…å±‚åº•éƒ¨å¯¹å…¶åˆ° 0 äº†
            box.position.set(x, 0, z);
            
            // [å…³é”®] è¿™é‡Œåªæ—‹è½¬å¤–å±‚çš„ Y è½´æ¥éšæœºæ–¹å‘
            // å› ä¸ºå†…å±‚å·²ç»å¤„ç†å¥½äº†â€œèººä¸‹â€çš„å§¿æ€ï¼Œå¤–å±‚åªç®¡â€œæ°´å¹³è½¬åœˆâ€ï¼Œç»å¯¹ä¸ä¼šæ­ª
            box.rotation.y = Math.random() * Math.PI * 2;

            box.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            scene.add(box); 
            placedFurniture.push(box);
            showEmote(box.position, 'ğŸ“¦');
        }





        // [ä¿®æ”¹] å¤©ç©ºæ¿é€»è¾‘ä¼˜åŒ–ï¼šå¤§å°æ”¶ç¼©ï¼Œä½ç½®é å
        function addSkyBacking(mesh, size) {
            // ç¨å¾®æ¯”å®šä¹‰å°ºå¯¸å°ä¸€åœˆ (0.85)ï¼Œé˜²æ­¢éœ²è¾¹
            const width = size.x * 0.85;
            const height = size.y * 0.85;
            
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height), 
                new THREE.MeshBasicMaterial({ color: 0xe0f7fa })
            );

            // æ”¾åˆ°çª—æˆ·åšåº¦çš„èƒŒé¢ (-size.z/2)ï¼Œå†å¾€å‰ä¸€ç‚¹ç‚¹ (+0.05) é¿å…å’Œå¢™æ‰“æ¶
            // è¿™æ ·å®ƒå°±åœ¨å¢™çš„å‰é¢ï¼Œä½†åœ¨çª—æ¡†çš„åé¢
            const zPos = -size.z / 2 + 0.05;
            
            plane.position.set(0, 0, zPos);
            plane.rotation.set(0, 0, 0); // é¢æœå±‹å†…
            
            plane.userData = { isSky: true };
            mesh.add(plane); 
            skyPanels.push(plane);
        }

        // [æ–°å¢] æ ¸å¿ƒä¿®å¤ï¼šç»Ÿä¸€å¤„ç†æ¨¡å‹çš„ä¸­å¿ƒç‚¹å’Œç¼©æ”¾
        function prepareModel(item) {
            if (!item.modelFile || !loadedModels[item.id]) return null;
            
            const raw = loadedModels[item.id].scene.clone();
            raw.traverse(sanitizeMaterial);

            // 1. åº•éƒ¨å¯¹é½ï¼ˆé€‚ç”¨äºæ”¾åœ¨åœ°ä¸Šçš„å®¶å…·ï¼‰
            if (item.fixBottom) { 
                const box = new THREE.Box3().setFromObject(raw); 
                raw.position.y = -box.min.y; 
            }
            
            // 2. è‡ªåŠ¨å±…ä¸­ (ä¿®å¤ä½ çš„çª—æˆ·é—®é¢˜ï¼šè®¡ç®—å‡ ä½•ä¸­å¿ƒå¹¶åå‘ç§»åŠ¨ï¼Œè®©ä¸­å¿ƒå½’é›¶)
            if (item.autoCenter) { 
                const box = new THREE.Box3().setFromObject(raw); 
                const c = new THREE.Vector3(); 
                box.getCenter(c); 
                raw.position.x -= c.x; 
                raw.position.y -= c.y; // å…³é”®ï¼šæŠŠä¸Šä¸‹é‡å¿ƒä¹Ÿå½’é›¶ï¼Œè¿™æ ·å°±å’Œå¤©ç©ºæ¿å¯¹é½äº†
                raw.position.z -= c.z; 
            }

            // 3. æ‰‹åŠ¨åç§» (ä»¥é˜²ä¸‡ä¸€è¿˜éœ€è¦å¾®è°ƒ)
            if (item.manualOffset) {
                raw.position.x += (item.manualOffset.x || 0);
                raw.position.y += (item.manualOffset.y || 0);
                raw.position.z += (item.manualOffset.z || 0);
            }

            const group = new THREE.Group();
            group.add(raw);
            
            // 4. åº”ç”¨ç¼©æ”¾
            const s = item.modelScale || 1.0; 
            group.scale.set(s, s, s);
            
            return group;
        }

        function getSkyColor(hour) {
            let c1, c2, ratio;
            if (hour < 5) return SKY_COLORS.night;
            else if (hour < 7) { 
                if(hour < 6) { c1=SKY_COLORS.night; c2=SKY_COLORS.dawn; ratio=hour-5; }
                else { c1=SKY_COLORS.dawn; c2=SKY_COLORS.day; ratio=hour-6; }
            }
            else if (hour < 17) return SKY_COLORS.day;
            else if (hour < 19) {
                if(hour < 18) { c1=SKY_COLORS.day; c2=SKY_COLORS.dusk; ratio=hour-17; }
                else { c1=SKY_COLORS.dusk; c2=SKY_COLORS.night; ratio=hour-18; }
            }
            else return SKY_COLORS.night;
            return c1.clone().lerp(c2, ratio);
        }

        function updateEnvironment(dt) {
            gameTime += dt * timeSpeed;
            if (gameTime >= 24) gameTime = 0;
            
            const hour = Math.floor(gameTime);
            const min = Math.floor((gameTime - hour) * 60);
            document.getElementById('game-time').innerText = `${hour.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}`;
            document.getElementById('day-icon').innerText = (hour >= 6 && hour < 18) ? 'â˜€ï¸' : 'ğŸŒ™';

            const skyColor = getSkyColor(gameTime);
            scene.background = skyColor;
            document.body.style.backgroundColor = `rgb(${skyColor.r*255},${skyColor.g*255},${skyColor.b*255})`;
            
            skyPanels.forEach(panel => { panel.material.color.copy(skyColor); });

            const angle = (gameTime - 12) / 12 * Math.PI; 
            const radius = 80;
            const sunX = Math.sin(angle) * radius;
            const sunY = Math.cos(angle) * radius;

            if (sunMesh && moonMesh) {
                sunMesh.position.set(sunX, sunY, -20);
                moonMesh.position.set(-sunX, -sunY, -20);
                sunMesh.scale.set(0.2, 0.2, 0.2); moonMesh.scale.set(0.2, 0.2, 0.2);
                sunMesh.visible = true; moonMesh.visible = true;
            }

            if (sunY > 0) {
                sunLight.intensity = 1.2 * (sunY / radius); 
                sunLight.position.set(sunX, sunY, 10);
                hemiLight.intensity = 0.8 + 0.2 * (sunY / radius);
                
                placedFurniture.forEach(f => {
                    const light = f.children.find(c => c.isLight);
                    if (light) light.visible = false;
                });
            } else {
                sunLight.intensity = 0;
                hemiLight.intensity = 0.4; 
                
                placedFurniture.forEach(f => {
                    const light = f.children.find(c => c.isLight);
                    if (light) light.visible = true;
                });
            }
        }


        class Cat {
            constructor(scene, color) {
            this.scene = scene; 
            this.state = 'idle'; 
            
            // å„ç§ä½ç½®å‘é‡ç¼“å­˜
            this.targetPos = new THREE.Vector3(); 
            this.stopPos = new THREE.Vector3(); // [æ–°å¢] èµ°è·¯åœæ­¢ç‚¹(è¾¹ç¼˜)
            this.jumpStart = new THREE.Vector3(); // [æ–°å¢] èµ·è·³ç‚¹
            this.jumpEnd = new THREE.Vector3();   // [æ–°å¢] è½åœ°ç‚¹
            
            this.interactTarget = null; 
            this.timer = 0; 
            this.mixer = null; 
            this.actions = {}; 
            this.isAnimated = false;
            this.petCount = 0; 
            this.patience = 5 + Math.floor(Math.random() * 6); 
            this.angryTime = 0; 
            
            this.mesh = new THREE.Group(); 
            this.scene.add(this.mesh); 
            
            this.downRay = new THREE.Raycaster(); 
            this.downRay.ray.direction.set(0,-1,0); 
            this.forwardRay = new THREE.Raycaster();

            // æ¨¡å‹åŠ è½½é€»è¾‘ (ä¿æŒä¸å˜)
            try {
                if (loadedModels['cat']) {
                    const model = SkeletonUtils.clone(loadedModels['cat'].scene);
                    model.scale.set(CAT_CONFIG.scale, CAT_CONFIG.scale, CAT_CONFIG.scale);
                    model.position.y = CAT_CONFIG.yOffset;
                    model.rotation.x = CAT_CONFIG.rotateX; 
                    model.rotation.y = CAT_CONFIG.rotateY;
                    this.mesh.add(model);

                    if (loadedModels['cat'].animations.length > 0) {
                        this.isAnimated = true; 
                        this.mixer = new THREE.AnimationMixer(model);
                        const anims = loadedModels['cat'].animations;
                        // è·å–åŠ¨ç”» (åŠ äº†äº›å®¹é”™)
                        const getAnim = (idx) => anims[idx] || anims[0];
                        
                        this.actions['idle'] = this.mixer.clipAction(getAnim(CAT_CONFIG.idleIndex));
                        this.actions['walk'] = this.mixer.clipAction(getAnim(CAT_CONFIG.walkIndex));
                        this.actions['sleep'] = this.mixer.clipAction(getAnim(CAT_CONFIG.sleepIndex));
                        this.actions['pet'] = this.mixer.clipAction(getAnim(CAT_CONFIG.petIndex)); 
                        
                        this.actions['sleep'].setLoop(THREE.LoopOnce); 
                        this.actions['sleep'].clampWhenFinished = true;
                        this.actions['idle'].play(); 
                        this.currentAction = this.actions['idle'];
                    }
                } else { this.mesh.add(this.createBlockCat(color)); }
            } catch (e) {
                console.error("Cat init error:", e);
                this.mesh.add(this.createBlockCat(color)); 
            }

            this.mesh.position.set(0, 0, 0); 
            this.chooseNewAction();
        }

        createBlockCat(color) { 
            const g=new THREE.Group(); 
            const m=new THREE.MeshStandardMaterial({color:color}); 
            const b=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.3,0.6),m); b.position.y=0.15; g.add(b); 
            const h=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.3,0.3),m); h.position.set(0,0.4,0.4); g.add(h); 
            return g; 
        }
        
        update(dt) {
            if(this.isAnimated && this.mixer) this.mixer.update(dt);

            // 1. é‡åŠ›/è´´åœ°é€»è¾‘
            // æ³¨æ„ï¼šåªæœ‰åœ¨éè·³è·ƒçŠ¶æ€æ‰è´´åœ°ï¼Œå¦åˆ™ä¼šæŠŠè·³åˆ°ç©ºä¸­çš„çŒ«æ‹‰ä¸‹æ¥
            if (this.state !== 'jumping') {
                const rayOrigin = this.mesh.position.clone(); 
                rayOrigin.y = 5; 
                this.downRay.set(rayOrigin, new THREE.Vector3(0,-1,0));
                const hitCandidates = [floorPlane, ...placedFurniture.filter(f => f.userData.dbItem && f.userData.dbItem.layer === 1 && !f.userData.isBox)];
                const hits = this.downRay.intersectObjects(hitCandidates, true); 
                let targetY = 0; 
                if(hits.length > 0) targetY = hits[0].point.y;
                // å¹³æ»‘ç§»åŠ¨ y è½´
                this.mesh.position.y += (targetY - this.mesh.position.y) * 0.2;
            }

            // 2. çŠ¶æ€æœº
            if(this.interactTarget && (!placedFurniture.includes(this.interactTarget) || !this.interactTarget.visible)) { 
                this.interrupt(); return; 
            }
            
            if (this.state === 'angry') { 
                if (Date.now() > this.angryTime) { 
                    this.state = 'idle'; 
                    this.patience = 5 + Math.floor(Math.random() * 6); 
                    this.petCount = 0; 
                    updateStatusText("çŒ«å’ªæ°”æ¶ˆäº†"); 
                } 
            }

            if(this.state === 'walking') {
                this.playAction('walk');
                // èµ°åˆ° stopPos (è¾¹ç¼˜) è€Œä¸æ˜¯ targetPos (ä¸­å¿ƒ)
                const dir = new THREE.Vector3().subVectors(this.stopPos, this.mesh.position); 
                dir.y = 0;
                const dist = dir.length();
                
                // å°„çº¿é¿éšœ (ç®€å•çš„)
                if (dist > 0.5) {
                    const forwardDir = dir.clone().normalize();
                    this.forwardRay.set(this.mesh.position.clone().add(new THREE.Vector3(0,0.3,0)), forwardDir);
                    const obstacles = placedFurniture.filter(f => f.userData.dbItem.layer > 0 && f !== this.interactTarget);
                    const cols = this.forwardRay.intersectObjects(obstacles, true);
                    if(cols.length > 0 && cols[0].distance < 0.5) { 
                        this.chooseNewAction(); 
                        return; 
                    }
                }

                if(dist < 0.1) {
                    // åˆ°è¾¾ç›®æ ‡é™„è¿‘
                    this.mesh.position.x = this.stopPos.x; 
                    this.mesh.position.z = this.stopPos.z;
                    
                    if(this.interactTarget) {
                        // [æ ¸å¿ƒé€»è¾‘]ï¼šå¦‚æœæ˜¯ç®±å­ä¸”æ²¡å€’ä¼ï¼Œå°±è·³è¿›å»ï¼›å¦åˆ™ç›´æ¥äº¤äº’
                        if (this.interactTarget.userData.isBox && !this.interactTarget.userData.isTipped) {
                            this.startJump();
                        } else {
                            // å€’ä¼çš„ç®±å­ï¼Œç›´æ¥èµ°è¿›å» (ç¨å¾®ç¬ç§»ä¸€ä¸‹åˆ°ä¸­å¿ƒï¼Œå‡è£…èµ°è¿›å»)
                            if (this.interactTarget.userData.isBox) {
                            this.mesh.position.x = this.interactTarget.position.x;
                            this.mesh.position.z = this.interactTarget.position.z;
                            }
                            this.enterInteraction(); 
                        }
                    } else { 
                        this.state = 'idle'; 
                        this.timer = 2; 
                    }
                } else {
                    dir.normalize(); 
                    this.mesh.position.add(dir.multiplyScalar(2.0 * dt)); 
                    this.mesh.lookAt(this.stopPos.x, this.mesh.position.y, this.stopPos.z);
                }
            } 
            else if (this.state === 'jumping') {
                this.updateJumping(dt);
            }
            else if(this.state === 'idle') {
                this.playAction('idle');
                this.timer -= dt; 
                if(this.timer <= 0) this.chooseNewAction();
            } 
            else if(this.state === 'interacting') {
                if (this.interactTarget && (this.interactTarget.userData.dbItem.canSleep || this.interactTarget.userData.isBox)) this.playAction('sleep');
                else this.playAction('idle');
                
                this.timer -= dt; 
                if(Math.random() < 0.01) spawnHeart(this.mesh.position); 
                if(this.timer <= 0) {
                    // å¦‚æœåœ¨ç®±å­é‡Œï¼Œå‡ºæ¥çš„æ—¶å€™è¦è·³å‡ºæ¥ï¼Œç®€åŒ–èµ·è§ï¼Œæˆ‘ä»¬ç›´æ¥ç¬ç§»åˆ°è¾¹ç¼˜ç„¶åèµ°å¼€
                    // æˆ–è€…å¯ä»¥åšä¸€ä¸ª jumping_out çŠ¶æ€ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
                    if (this.interactTarget && this.interactTarget.userData.isBox && !this.interactTarget.userData.isTipped) {
                        // ç¬ç§»å›èµ·è·³ç‚¹ï¼Œé˜²æ­¢å¡åœ¨ç®±å­é‡Œ
                        this.mesh.position.copy(this.jumpStart);
                        this.mesh.position.y = 0; // å›åˆ°åœ°é¢
                    }
                    this.leaveInteraction();
                }
            } 
            else if(this.state === 'petting') {
                this.playAction('pet'); 
            }
        }

        // [æ–°å¢] å‡†å¤‡è·³è·ƒ
        startJump() {
            this.state = 'jumping';
            this.playAction('idle'); // æˆ–è€…æ˜¯ jump åŠ¨ç”»
            this.jumpTimer = 0;
            this.jumpDuration = 0.6; // è·³è·ƒè€—æ—¶ 0.6ç§’
            
            this.jumpStart.copy(this.mesh.position);
            
            // ç›®æ ‡æ˜¯ç®±å­ä¸­å¿ƒï¼Œé«˜åº¦ç¨å¾®æµ®èµ·æ¥ä¸€ç‚¹
            this.jumpEnd.copy(this.interactTarget.position);
            
            // è·å–ç®±å­é«˜åº¦ï¼Œè·³åˆ°é«˜åº¦ä¸Šæ–¹ä¸€ç‚¹
            let h = this.interactTarget.userData.boxHeight || 0.5;
            this.jumpEnd.y = h * 0.5; // ç®±å­å†…éƒ¨åº•éƒ¨å¤§æ¦‚åœ¨é«˜åº¦çš„ä¸€åŠä½ç½® (å› ä¸ºæ¨¡å‹æ˜¯åŸç‚¹å±…ä¸­ç¼©æ”¾çš„)
            // å®é™…ä¸Šä¸ºäº†ä¸ç©¿æ¨¡åº•éƒ¨ï¼Œæˆ‘ä»¬å¯ä»¥è®©å®ƒæ‚¬æµ®åœ¨ 0.2 å·¦å³
            if (this.jumpEnd.y < 0.2) this.jumpEnd.y = 0.2;
        }

        // [æ–°å¢] å¤„ç†è·³è·ƒè¿‡ç¨‹ (æŠ›ç‰©çº¿)
    updateJumping(dt) {
        this.jumpTimer += dt;
        let t = this.jumpTimer / this.jumpDuration;
        if (t > 1) t = 1;

        // çº¿æ€§æ’å€¼ X å’Œ Z (æ°´å¹³ç§»åŠ¨)
        this.mesh.position.x = THREE.MathUtils.lerp(this.jumpStart.x, this.jumpEnd.x, t);
        this.mesh.position.z = THREE.MathUtils.lerp(this.jumpStart.z, this.jumpEnd.z, t);
        
        // æŠ›ç‰©çº¿ Y (å‚ç›´ç§»åŠ¨)
        const height = this.jumpEnd.y + 0.5; 
        const yBase = THREE.MathUtils.lerp(this.jumpStart.y, this.jumpEnd.y, t);
        const yArc = Math.sin(t * Math.PI) * height;
        
        this.mesh.position.y = yBase + yArc;

        // [æ ¸å¿ƒä¿®æ­£] æœå‘ç›®æ ‡ï¼Œä½†ä¿æŒè§†çº¿æ°´å¹³ï¼Œé˜²æ­¢å¤´æœä¸‹ç©¿æ¨¡
        // æˆ‘ä»¬è®©çŒ«çœ‹ç€ (ç›®æ ‡X, çŒ«å½“å‰Y, ç›®æ ‡Z)ï¼Œè¿™æ ·å®ƒèº«ä½“å°±æ˜¯æ°´å¹³çš„
        this.mesh.lookAt(this.jumpEnd.x, this.mesh.position.y, this.jumpEnd.z);

        if (t >= 1) {
            // [åŒé‡ä¿é™©] è½åœ°æ—¶å¼ºåˆ¶èº«ä½“å›æ­£ï¼Œé˜²æ­¢ä»»ä½•å€¾æ–œ
            this.mesh.rotation.x = 0;
            this.mesh.rotation.z = 0;
            
            this.enterInteraction();
        }
    }

        playAction(name) { 
            if(this.isAnimated && this.currentAction !== this.actions[name]) { 
                this.currentAction.fadeOut(0.2); 
                this.actions[name].reset().fadeIn(0.2).play(); 
                this.currentAction = this.actions[name]; 
            } 
        }
        
        pet() {
            if (this.state === 'angry') { showEmote(this.mesh.position, 'ğŸ’¢'); return; }
            if (this.petCount >= this.patience) {
                showEmote(this.mesh.position, 'ğŸ’¢'); 
                this.state = 'angry';
                this.angryTime = Date.now() + 15 * 60 * 1000; 
                this.chooseNewAction(); 
                updateStatusText("çŒ«å’ªç”Ÿæ°”äº† (15m CD)");
            } else {
                this.petCount++;
                spawnHeart(this.mesh.position);
                showEmote(this.mesh.position, 'ğŸ˜»');
                this.state = 'petting';
                if (this.resetTimer) clearTimeout(this.resetTimer);
                this.resetTimer = setTimeout(() => { if (this.state === 'petting') this.state = 'idle'; }, 2000);
            }
        }

        resetCooldown() { this.angryTime = 0; this.state = 'idle'; this.petCount = 0; this.patience = 10; showEmote(this.mesh.position, 'â¤ï¸'); }
        interrupt() { showEmote(this.mesh.position,'â“'); this.state='idle'; this.interactTarget=null; this.timer=1; } 
        
        chooseNewAction() {
            const boxes = placedFurniture.filter(f => f.userData.isBox);
            const valid = placedFurniture.filter(f => f.userData.dbItem.layer === 1 && f.visible && f.userData.type !== 'wall' && !f.userData.isBox);
            
            let target = null;
            // 80% æ¦‚ç‡å»é’»ç®±å­
            if (boxes.length > 0 && Math.random() < 0.8) target = boxes[Math.floor(Math.random() * boxes.length)];
            else if (valid.length > 0 && Math.random() < 0.6) target = valid[Math.floor(Math.random()*valid.length)];

            if(target) { 
                this.interactTarget = target; 
                this.targetPos.copy(this.interactTarget.position); 
                
                // [æ ¸å¿ƒä¿®æ”¹] è®¡ç®—åœæ­¢ç‚¹
                // å¦‚æœæ˜¯ç®±å­ï¼Œåœåœ¨ç®±å­è¾¹ç¼˜ (è·ç¦»ä¸­å¿ƒ 0.6 + åŠå¾„)
                // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬æ²¿ç€ "çŒ«->ç®±å­" çš„è¿çº¿ï¼Œåœ¨è·ç¦»ç®±å­ä¸­å¿ƒ 0.7 ç±³å¤„åœä¸‹
                if (target.userData.isBox) {
                    const vec = new THREE.Vector3().subVectors(this.mesh.position, target.position);
                    vec.y = 0;
                    vec.normalize();
                    // åœæ­¢ä½ç½® = ç®±å­ä½ç½® + æ–¹å‘ * è·ç¦»
                    this.stopPos.copy(target.position).add(vec.multiplyScalar(0.7));
                } else {
                    // æ™®é€šå®¶å…·ï¼Œç›´æ¥èµ°åˆ°ä½ç½® (å¯èƒ½ä¼šç©¿æ¨¡ï¼Œä½†æ™®é€šå®¶å…·é€šå¸¸æ²¡å…³ç³»)
                    this.stopPos.copy(this.targetPos);
                }
                
                this.state = 'walking'; 
            }
            else { 
                this.interactTarget = null; 
                this.targetPos.set((Math.random()-0.5)*8,0,(Math.random()-0.5)*8); 
                this.stopPos.copy(this.targetPos);
                this.state = 'walking'; 
            }
        }

        enterInteraction() { 
            this.state = 'interacting'; 
            // åœ¨ç®±å­é‡Œå¾…ä¹…ä¸€ç‚¹ (15ç§’)ï¼Œæ™®é€šå®¶å…·å¾… 5-10ç§’
            this.timer = 5 + Math.random() * 5; 
            
            if (this.interactTarget && this.interactTarget.userData.isBox) { 
                this.timer = 15; 
                showEmote(this.mesh.position, 'ğŸ“¦'); 
            }
            
            if(this.interactTarget) {
                // å¦‚æœä¸æ˜¯è·³è¿›å»çš„ç®±å­ï¼Œéšæœºè½¬ä¸ªèº«
                if (!(this.interactTarget.userData.isBox && !this.interactTarget.userData.isTipped)) {
                    this.mesh.rotation.y = Math.random() * Math.PI * 2; 
                }
            }
        }
        
        leaveInteraction() { this.state='idle'; this.timer=0.5; }
    }

        function updateMoney(amt) { heartScore+=amt; document.getElementById('heart-count').innerText=heartScore; refreshShopState(); }
        function refreshShopState() { 
            document.querySelectorAll('.item-btn').forEach(b=>{
                const p=parseInt(b.dataset.price); 
                if(heartScore>=p) b.classList.remove('disabled'); else b.classList.add('disabled');
            }); 
        }
        function spawnHeart(pos) { const v=pos.clone(); v.y+=1; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='heart-float'; e.innerText='â¤ +5'; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); updateMoney(5); setTimeout(()=>e.remove(),1500); }
        function showEmote(pos,t) { const v=pos.clone(); v.y+=1.2; v.project(camera); const x=(v.x*.5+.5)*window.innerWidth; const y=(-(v.y*.5)+.5)*window.innerHeight; const e=document.createElement('div'); e.className='emote-bubble'; e.innerText=t; e.style.left=x+'px'; e.style.top=y+'px'; document.body.appendChild(e); setTimeout(()=>e.remove(),1000); }

        window.startNewPlacement = function(id) {
            const item = FURNITURE_DB.find(i=>i.id===id);
            if(heartScore<item.price && !activeDecorId[item.decorType]) { alert("é‡‘é’±ä¸è¶³"); return; } 
            if (item.type === 'decor') { handleDecorClick(item); return; }
            deselect(); mode='placing_new'; currentItemData=item; currentRotation=0;
            createGhost(); 
            updateStatusText("æ”¾ç½®: "+item.name);
            document.querySelectorAll('.item-btn').forEach(b=>b.classList.remove('selected'));
        }
        document.getElementById('btn-move').onclick=()=>{if(selectedObject)startMovingOld(selectedObject);hideContextMenu();}
        document.getElementById('btn-delete').onclick=()=>{if(selectedObject)deleteSelected();hideContextMenu();}
        document.getElementById('btn-cancel').onclick=()=>{deselect();hideContextMenu();}

        function renderShopItems(cat) {
            const c=document.getElementById('items-scroll'); c.innerHTML='';
            let typeFilter = cat; if(cat==='small') typeFilter='small';
            FURNITURE_DB.filter(i=>i.type===typeFilter).forEach(item=>{
                const b=document.createElement('div'); b.className='item-btn'; b.dataset.price=item.price;
                if (item.type === 'decor' && activeDecorId[item.decorType] === item.id) { b.classList.add('selected'); }
                b.onclick=(e)=>{ e.stopPropagation(); if(!b.classList.contains('disabled')){ startNewPlacement(item.id); } };
                if (item.type === 'decor') { b.onmouseenter = () => applyDecorVisuals(item); b.onmouseleave = () => restoreDecorState(item.decorType); }
                const col=document.createElement('div'); col.className='color-preview'; 
                if(item.textureFile) col.style.backgroundImage = `url(./assets/textures/${item.textureFile})`;
                else col.style.background='#'+item.color.toString(16).padStart(6,'0');
                const t=document.createElement('span'); t.innerText=item.name;
                const p=document.createElement('div'); p.className='price-tag'; p.innerText='â¤ '+item.price;
                b.append(col,t,p); c.appendChild(b);
            }); refreshShopState();
        }

        // [ä¿®æ”¹] ä½¿ç”¨ prepareModel ç»Ÿä¸€åˆ›å»ºé€»è¾‘
        function createGhost() {
            if(ghostMesh) scene.remove(ghostMesh);
            const item = currentItemData;
            
            const modelGroup = prepareModel(item);
            
            if (modelGroup) {
                ghostMesh = modelGroup;
            } else {
                let mat = item.light ? new THREE.MeshStandardMaterial({color:item.color, emissive:item.color, emissiveIntensity:0.5, transparent:true, opacity:0.6}) : new THREE.MeshStandardMaterial({color:item.color, transparent:true, opacity:0.6});
                let geo;
                if (item.id === 'rug') { geo = new THREE.CylinderGeometry(item.size.x/2, item.size.x/2, item.size.y, 32); geo.translate(0, item.size.y/2, 0); } 
                else { geo = new THREE.BoxGeometry(item.size.x, item.size.y, item.size.z); if(!item.modelFile) geo.translate(0, item.size.y/2, 0); }
                ghostMesh = new THREE.Mesh(geo, mat);
            }
            
            ghostMesh.traverse((c) => { if (c.isMesh) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.5; } });
            ghostMesh.position.set(0,-100,0);
            if(item.type!=='wall') ghostMesh.rotation.y = currentRotation;
            scene.add(ghostMesh);
        }

        function checkColl(isWall) {
            ghostMesh.updateMatrixWorld(); 
            const box = new THREE.Box3().setFromObject(ghostMesh); 
            
            // åœ°æ¯¯ç¢°æ’ä¿®æ­£
            if (currentItemData.layer === 0) { 
                box.min.x += 0.1; box.max.x -= 0.1; 
                box.min.z += 0.1; box.max.z -= 0.1; 
            } else { 
                box.expandByScalar(-0.1); 
            }
            
            let col = false;
            
            // 1. æ£€æŸ¥æ˜¯å¦æ’åˆ°å¢™ä½“ç»“æ„ (ç¡¬å¢™) - è¿™ä¸ªä¸èƒ½ç©¿
            if(!isWall) {
                for(let o of obstacles) {
                    if(box.intersectsBox(new THREE.Box3().setFromObject(o))) { 
                        col = true; 
                        break; 
                    }
                }
            }

            // 2. æ£€æŸ¥æ˜¯å¦æ’åˆ°å…¶ä»–å®¶å…·
            if(!col) {
                for(let f of placedFurniture) { 
                    // ç§»åŠ¨æ—§å®¶å…·æ—¶ï¼Œå¿½ç•¥è‡ªå·±
                    if(mode === 'moving_old' && f === selectedObject) continue; 
                    
                    // å±‚çº§è¿‡æ»¤ (åœ°æ¯¯ä¸æ’å®¶å…·ï¼Œæ¡Œä¸Šç‰©ä¸æ’æ¡Œå­)
                    const myL = currentItemData.layer; 
                    const otherL = f.userData.dbItem.layer;
                    if(myL === 0 || otherL === 0) continue; 
                    if(myL === 2 && otherL === 1) continue; 
                    if(myL === 1 && otherL === 2) continue; 
                    
                    // [æ–°å¢] é‡å é€»è¾‘çš„æ ¸å¿ƒä¿®æ”¹
                    // å¦‚æœå½“å‰æ‰‹æŒçš„ç‰©å“å…è®¸é‡å  (ä¾‹å¦‚çª—å¸˜/æ˜Ÿæ˜Ÿ)ï¼Œä¸”å¯¹æ–¹ä¹Ÿæ˜¯å¢™é¢ç‰©å“ (ä¾‹å¦‚çª—æˆ·/ç”»/å¦ä¸€ä¸ªæ˜Ÿæ˜Ÿ)
                    // åˆ™ç›´æ¥è·³è¿‡ç¢°æ’æ£€æŸ¥ï¼Œå…è®¸é‡å ã€‚
                    if (currentItemData.allowOverlap && f.userData.type === 'wall') {
                        continue; 
                    }

                    // æ­£å¸¸çš„ç¢°æ’ç›’æ£€æµ‹
                    if(box.intersectsBox(new THREE.Box3().setFromObject(f))) { 
                        col = true; 
                        break; 
                    } 
                }
            }
            
            // åœ°æ¿ä¸‹æ–¹æ£€æµ‹
            if(ghostMesh.position.y < 0 && currentItemData.layer !== 0) col = true; 
            
            // çŠ¶æ€æ›´æ–°
            if(col) { 
                ghostMesh.traverse(c => { if(c.isMesh) c.material.color.setHex(0xff0000) }); 
                canPlace = false; 
                updateStatusText("ä½ç½®å†²çª", "invalid"); 
            } else { 
                ghostMesh.traverse(c => { if(c.isMesh) c.material.color.setHex(0xffffff) }); 
                canPlace = true; 
                updateStatusText("å¯æ”¾ç½®", "valid"); 
            }
        }
        
        // [ä¿®æ”¹] æ”¾ç½®é€»è¾‘ä¼˜åŒ–
        function confirmPlace() {
            if(mode === 'placing_new') { if(heartScore >= currentItemData.price) updateMoney(-currentItemData.price); else { alert("é‡‘é’±ä¸è¶³!"); cancelPlace(); return; } }
            let m;
            
            const modelGroup = prepareModel(currentItemData);
            
            if (modelGroup) {
                m = modelGroup;
            } else {
                m = ghostMesh.clone(); 
                m.traverse(c=>{if(c.isMesh){ c.material=c.material.clone(); c.material.transparent=false; c.material.opacity=1; c.material.color.setHex(currentItemData.color); }}); 
            }

            m.position.copy(ghostMesh.position); m.rotation.copy(ghostMesh.rotation);
            m.traverse(c => { 
                if(c.isMesh) { 
                    c.castShadow=true; c.receiveShadow=true; 
                    if (!currentItemData.modelFile) c.material.color.setHex(currentItemData.color); 
                    if(currentItemData.light) { c.material.emissiveIntensity = 0.8; if(!currentItemData.modelFile) c.material.emissive.setHex(currentItemData.color); } else { c.material.emissive.setHex(0); } 
                } 
            });
            m.userData={type:currentItemData.type, dbItem: currentItemData, origScale: m.scale.clone()}; 
            if(currentItemData.light) {
                if (currentItemData.lightType === 'point') { 
                    const bulb = new THREE.PointLight(0xffaa00, 0.8, 5); 
                    let lx = 0, ly = 0.3, lz = 0;
                    if (currentItemData.lightOffset) {
                        lx = currentItemData.lightOffset.x || 0;
                        ly = currentItemData.lightOffset.y || 0;
                        lz = currentItemData.lightOffset.z || 0;
                    }
                    bulb.position.set(lx, ly, lz); 
                    bulb.castShadow = true; 
                    m.add(bulb); 
                } 
                else { 
                    const sl = new THREE.SpotLight(0xfff0dd, 5); 
                    sl.position.set(0,0,0); 
                    sl.target.position.set(0,0,5); 
                    sl.angle = Math.PI / 3; 
                    sl.penumbra = 0.5; 
                    sl.castShadow = true; 
                    m.add(sl); 
                    m.add(sl.target);
                    if (currentItemData.type === 'wall') {
                        addSkyBacking(m, currentItemData.size);
                    }
                }
            }
            scene.add(m); 
            
            if (mode === 'placing_new' && currentItemData.layer === 1) { 
                // [ä¿®å¤ç‚¹]ï¼šå…ˆå°† item å­˜å…¥å±€éƒ¨å˜é‡ savedItem
                // è¿™æ ·å³ä½¿ 1ç§’å currentItemData å˜æˆäº† nullï¼ŒsavedItem ä¾ç„¶ä¿ç•™ç€æ•°æ®
                const savedItem = currentItemData;
                setTimeout(() => spawnMysteryBox(savedItem), 1000); 
            }

            if(mode==='moving_old') { scene.remove(selectedObject); const i=placedFurniture.indexOf(selectedObject); if(i>-1)placedFurniture.splice(i,1); deselect(); }
            placedFurniture.push(m); playBounce(m);
            if(mode==='moving_old') { mode='idle'; scene.remove(ghostMesh); ghostMesh=null; updateStatusText("ç§»åŠ¨å®Œæˆ"); }
            else { cancelPlace(); }
        }

        function onDown(e) { if(e.target!==renderer.domElement)return; startPointer.x=e.clientX; startPointer.y=e.clientY; if(mode==='idle' && e.button===0) { raycaster.setFromCamera(pointer, camera); for(let cat of cats) { const hits=raycaster.intersectObject(cat.mesh,true); if(hits.length>0){ cat.pet(); return; } } const hits=raycaster.intersectObjects(placedFurniture); if(hits.length>0) { const obj=hits[0].object; let root=obj; while(root.parent&&root.parent!==scene)root=root.parent; if(root.userData.isBox) { scene.remove(root); const i=placedFurniture.indexOf(root); if(i>-1)placedFurniture.splice(i,1); updateMoney(10); spawnHeart(root.position); updateStatusText("å›æ”¶çº¸ç®±+10"); return; } longPressTimer=setTimeout(()=>selectObj(root,e.clientX,e.clientY),500); } } if(e.button===1&&ghostMesh&&currentItemData.type!=='wall'){e.preventDefault();rotateItem();return;} if(e.button===0 && (mode==='placing_new'||mode==='moving_old')&&canPlace&&ghostMesh) confirmPlace(); }
        function onUp() { if(longPressTimer){clearTimeout(longPressTimer);longPressTimer=null;} }
        function handleLong(e) { /* handled in onDown */ }
        function selectObj(m,x,y) { deselect(); let t=m; while(t.parent&&t.parent!==scene)t=t.parent; selectedObject=t; selectionBox=new THREE.BoxHelper(selectedObject,0xffffff); scene.add(selectionBox); showMenu(x,y); updateStatusText("é€‰ä¸­: å®¶å…·"); }
        function deselect() { selectedObject=null; if(selectionBox){scene.remove(selectionBox);selectionBox=null;} document.getElementById('context-menu').style.display='none'; }
        function cancelPlace() { if(ghostMesh)scene.remove(ghostMesh); mode='idle'; ghostMesh=null; currentItemData=null; updateStatusText("æµè§ˆä¸­"); }
        function cancelMove() { if(mode==='moving_old'){if(ghostMesh)scene.remove(ghostMesh);if(selectedObject){selectedObject.position.copy(editingObjectOriginalPos);selectedObject.quaternion.copy(editingObjectOriginalQuat);selectedObject.visible=true;}} deselect(); mode='idle'; ghostMesh=null; }
        function showMenu(x,y) { const m=document.getElementById('context-menu'); m.style.display='flex'; let px=x+10, py=y+10; if(px+100>window.innerWidth)px=window.innerWidth-110; if(py+100>window.innerHeight)py=window.innerHeight-110; m.style.left=px+'px'; m.style.top=py+'px'; }
        function hideContextMenu() { document.getElementById('context-menu').style.display='none'; }
        function updateStatusText(t,c) { const e=document.getElementById('status-text'); e.innerText=t; e.className=c==='valid'?'status-valid':(c==='invalid'?'status-invalid':''); }
        function playBounce(m) { let f=0; const baseScale = m.userData.origScale || new THREE.Vector3(1,1,1); function a(){ if(f<20){const k=f/20; const s=0.1+(0.9)*(Math.sin(k*Math.PI*1.5)*0.2+k); m.scale.set(baseScale.x*s, baseScale.y*s, baseScale.z*s); f++; requestAnimationFrame(a); }else m.scale.copy(baseScale); } a(); }
        function rotateItem() { currentRotation += Math.PI/2; if(ghostMesh) { ghostMesh.rotation.y = currentRotation; checkColl(false); } }
        function startMovingOld(m) { mode = 'moving_old'; m.visible=false; editingObjectOriginalPos=m.position.clone(); editingObjectOriginalQuat=m.quaternion.clone(); const savedData = m.userData.dbItem || FURNITURE_DB[0]; currentItemData = savedData; if(currentItemData.type!=='wall') currentRotation=m.rotation.y; else currentRotation=0; createGhost(); updateStatusText("æ­£åœ¨ç§»åŠ¨..."); }
        function deleteSelected() { if(!selectedObject)return; scene.remove(selectedObject); const i=placedFurniture.indexOf(selectedObject); if(i>-1)placedFurniture.splice(i,1); deselect(); }
        function onMove(e) { 
            if(longPressTimer) { if(Math.hypot(e.clientX-startPointer.x, e.clientY-startPointer.y)>5) { clearTimeout(longPressTimer); longPressTimer=null; } } 
            pointer.x=(e.clientX/window.innerWidth)*2-1; 
            pointer.y=-(e.clientY/window.innerHeight)*2+1; 
            if((mode==='placing_new'||mode==='moving_old') && ghostMesh) { 
                raycaster.setFromCamera(pointer, camera); 
                if(currentItemData.type==='wall') { 
                    const hits = raycaster.intersectObjects(obstacles); 
                    if(hits.length>0) { 
                        const h=hits[0]; 
                        const n=h.face.normal; 
                        if(Math.abs(n.y)>0.5) return;
                        const offset = currentItemData.size.z / 2 + 0.01; 
                        const pos=h.point.clone().add(n.clone().multiplyScalar(offset)); 
                        if(Math.abs(n.x)>0.5) { pos.y=Math.round(pos.y/0.5)*0.5; pos.z=Math.round(pos.z/0.5)*0.5; }
                        else { pos.x=Math.round(pos.x/0.5)*0.5; pos.y=Math.round(pos.y/0.5)*0.5; }
                        const hh=currentItemData.size.y/2; 
                        if(pos.y<hh) pos.y=hh; 
                        if(pos.y+hh>3) pos.y=3-hh; 
                        ghostMesh.position.copy(pos); 
                        ghostMesh.lookAt(pos.clone().add(n)); 
                        checkColl(true); 
                    } 
                    return;
                } 
                let onTable = false; 
                if(currentItemData.layer === 2) { 
                    const hits = raycaster.intersectObjects(placedFurniture.filter(f=>f.visible && f.userData.dbItem.isSurface)); 
                    if(hits.length > 0) { 
                        const hit = hits[0]; 
                        let targetY = hit.point.y;
                        if(hit.object.parent && hit.object.parent.userData.dbItem && hit.object.parent.userData.dbItem.surfaceHeight) {
                            targetY = hit.object.parent.position.y + hit.object.parent.userData.dbItem.surfaceHeight;
                        }
                         if (currentItemData.yFix) targetY += currentItemData.yFix;
                        ghostMesh.position.set(hit.point.x, targetY, hit.point.z); 
                        ghostMesh.rotation.set(0, currentRotation, 0); 
                        checkColl(false); 
                        onTable = true; 
                    } 
                } 
                if(!onTable) { 
                    const hits = raycaster.intersectObject(floorPlane); 
                    if(hits.length>0) { 
                        const p=hits[0].point; 
                        let targetY = 0;
                        if(currentItemData.id.includes('rug')) targetY = 0.01;
                        ghostMesh.position.set(Math.round(p.x/0.5)*0.5, targetY, Math.round(p.z/0.5)*0.5); 
                        ghostMesh.rotation.set(0, currentRotation, 0); 
                        checkColl(false); 
                    } 
                } 
            } 
        }

        function onWindowResize() { const aspect = window.innerWidth / window.innerHeight; const d = 12; camera.left = -d * aspect; camera.right = d * aspect; camera.top = d; camera.bottom = -d; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function init() { 
            loadAssets(() => { 
                updateStatusText("èµ„æºåŠ è½½å®Œæ¯•"); 
                const ls = document.getElementById('loading-screen');
                if(ls) ls.style.display = 'none';
                if(!scene) startGame(); 
            }); 
        }

        function startGame() {
            document.getElementById('heart-count').innerText = heartScore;
            window.switchCategory('floor');
            
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.outputColorSpace = THREE.SRGBColorSpace; document.body.appendChild(renderer.domElement);
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xe0f7fa);
            const aspect=window.innerWidth/window.innerHeight; const d=12; camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000); camera.position.set(20, 20, 20); camera.lookAt(0,0,0);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2.1;

            window.addEventListener('keydown', (e) => {
                if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                const key = e.key.toLowerCase();
                if (key === 'r' && ghostMesh && currentItemData.type !== 'wall') {
                    rotateItem();
                }
                switch (key) {
                    case 'w': moveKeys.w = true; break;
                    case 'a': moveKeys.a = true; break;
                    case 's': moveKeys.s = true; break;
                    case 'd': moveKeys.d = true; break;
                }
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                switch (key) {
                    case 'w': moveKeys.w = false; break;
                    case 'a': moveKeys.a = false; break;
                    case 's': moveKeys.s = false; break;
                    case 'd': moveKeys.d = false; break;
                }
            });
            
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.2); scene.add(hemiLight);
            const al = new THREE.AmbientLight(0xffffff, 0.9); scene.add(al);
            sunLight = new THREE.DirectionalLight(0xffdfba, 1.2); sunLight.position.set(15,25,10); sunLight.castShadow=true; sunLight.shadow.mapSize.width=2048; sunLight.shadow.mapSize.height=2048; sunLight.shadow.camera.left=-20; sunLight.shadow.camera.right=20; sunLight.shadow.camera.top=20; sunLight.shadow.camera.bottom=-20; scene.add(sunLight);
            
            celestialGroup = new THREE.Group(); scene.add(celestialGroup);
            sunMesh = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshBasicMaterial({color:0xffff00})); celestialGroup.add(sunMesh);
            moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5,16,16), new THREE.MeshStandardMaterial({color:0xffffff,emissive:0x222222})); celestialGroup.add(moonMesh);
            sunMesh.visible = false; moonMesh.visible = false;
            
            raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();
            const fg=new THREE.PlaneGeometry(12,12); const fm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.floor.color}); floorPlane=new THREE.Mesh(fg, fm); floorPlane.rotation.x=-Math.PI/2; floorPlane.receiveShadow=true; scene.add(floorPlane);
            const gh=new THREE.GridHelper(12,24,0xffffff,0xffffff); gh.position.y=0.01; gh.material.opacity=0.2; gh.material.transparent=true; scene.add(gh);
            const wm=new THREE.MeshStandardMaterial({color:DEFAULT_DECOR.wall.color});
            const w1=new THREE.Mesh(new THREE.BoxGeometry(10,3,0.5), wm); w1.position.set(0,1.5,-5.25); w1.receiveShadow=true; w1.castShadow=true; scene.add(w1); obstacles.push(w1);
            const w2=new THREE.Mesh(new THREE.BoxGeometry(0.5,3,10), wm); w2.position.set(-5.25,1.5,0); w2.receiveShadow=true; w2.castShadow=true; scene.add(w2); obstacles.push(w2);
            wallGroup = [w1, w2];
            cats.push(new Cat(scene, 0xffa502));

            window.addEventListener('resize', onWindowResize); window.addEventListener('pointermove', onMove); window.addEventListener('pointerdown', onDown); window.addEventListener('pointerup', onUp);
            window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode==='placing_new') cancelPlace(); else if(mode==='moving_old') cancelMove(); else deselect(); });

            animate();
        }

        function updateCameraMovement(dt) {
            if (!(moveKeys.w || moveKeys.a || moveKeys.s || moveKeys.d)) return;

            const moveSpeed = 10.0 * dt;
            const displacement = new THREE.Vector3();

            // è·å–æ‘„åƒå¤´å½“å‰æœå‘ï¼Œç”¨äºè®¡ç®—ç›¸å¯¹ç§»åŠ¨
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            if (moveKeys.w) displacement.add(forward.multiplyScalar(moveSpeed));
            if (moveKeys.s) displacement.sub(forward.multiplyScalar(moveSpeed));
            if (moveKeys.d) displacement.add(right.multiplyScalar(moveSpeed));
            if (moveKeys.a) displacement.sub(right.multiplyScalar(moveSpeed));
            
            camera.position.add(displacement);
            controls.target.add(displacement);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = gameClock.getDelta();
            
            updateCameraMovement(dt);

            controls.update();
            updateEnvironment(dt);
            cats.forEach(c => c.update(dt));
            if(selectionBox) selectionBox.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>